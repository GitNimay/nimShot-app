### Tauri Plugin Setup with Builder Example (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/plugin

Demonstrates how to initialize a Tauri plugin using the Builder pattern, including a setup hook. This example shows a common convention for plugin initialization.

```rust
use tauri::{plugin::{Builder, TauriPlugin}, Runtime};

pub fn init<R: Runtime>() -> TauriPlugin<R> {
  Builder::new("example")
    .build()
}
```

--------------------------------

### run Method Example

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Example demonstrating how to use the `run` method to start the Tauri application with a given configuration context.

```APIDOC
## run

### Description
Builds and runs the Tauri application.

### Method
`run`

### Endpoint
N/A (Method on `Builder`)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
None

### Request Example
```rust
tauri::Builder::default()
  .run(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
  .expect("error while running tauri application");
```

### Response
#### Success Response (200)
The application runs successfully.

#### Response Example
```json
{
  "status": "Application started successfully"
}
```
```

--------------------------------

### Listen to Any Event Example (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/lib

Example of setting up a listener for any event named 'synchronized' during the application setup. When the event is received, it prints 'app is in sync' to the console.

```rust
tauri::Builder::default()
  .setup(|app| {
    app.listen_any("synchronized", |event| {
      println!("app is in sync");
    });
    Ok(())
  })
  .invoke_handler(tauri::generate_handler![synchronize]);
```

--------------------------------

### Example: Listen to Component Loaded Event (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/window/mod

Demonstrates how to set up a Tauri application and listen for a 'component-loaded' event on the main window. This example shows event registration within the `setup` hook.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let window = app.get_window("main").unwrap();
    window.listen("component-loaded", move |event| {
      println!("window just loaded a component");
    });

    Ok(())
  })
```

--------------------------------

### Tauri App Builder: Define Setup Hook

Source: https://docs.rs/tauri/2.8.5/tauri/struct

Defines the setup hook for the Tauri application, which runs once when the application starts. This hook can be used to perform initial setup tasks, such as setting window titles or managing windows.

```Rust
pub fn setup<F>(self, setup: F) -> Self
where F: FnOnce(&mut App<R>) -> Result<(), Box<dyn Error>> + Send + 'static,
```

```Rust
use tauri::Manager;
tauri::Builder::default()
  .setup(|app| {
    let main_window = app.get_webview_window("main").unwrap();
    main_window.set_title("Tauri!")?;
    Ok(())
  });
```

--------------------------------

### Tauri: Example of Adding Capabilities

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Demonstrates how to add capabilities to a Tauri application during the setup phase. It shows conditional compilation for different features and how to include capability JSON files. This example highlights the use of `tauri_build` for configuring capability paths.

```rust
tauri::Builder::default()
  .setup(|app| {
    #[cfg(feature = "beta")]
    app.add_capability(include_str!("../capabilities/beta/cap.json"));

    #[cfg(feature = "stable")]
    app.add_capability(include_str!("../capabilities/stable/cap.json"));
    Ok(())
  });

// Example of configuring capability path pattern in build script:
// let attributes = tauri_build::Attributes::new().capabilities_path_pattern("./capabilities/app/*.json");
// tauri_build::try_build(attributes).unwrap();
```

--------------------------------

### Example: Adding Capabilities in Tauri Setup

Source: https://docs.rs/tauri/latest/src/tauri/lib

Demonstrates how to add capabilities to a Tauri application during the setup phase. It shows conditional compilation for different features ('beta', 'stable') and how to use `include_str!` to load capability definitions from JSON files. It also touches upon configuring capability paths in `tauri.conf.json` and `tauri_build`.

```rust
tauri::Builder::default()
  .setup(|app| {
    #[cfg(feature = "beta")]
    app.add_capability(include_str!("../capabilities/beta/cap.json"));

    #[cfg(feature = "stable")]
    app.add_capability(include_str!("../capabilities/stable/cap.json"));
    Ok(())
  });

// Example build script configuration:
// let attributes = tauri_build::Attributes::new().capabilities_path_pattern("./capabilities/app/*.json");
// tauri_build::try_build(attributes).unwrap();
```

--------------------------------

### Define Tauri Setup Hook

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Configures a setup hook that runs when the Tauri application is initialized. This hook can be used for initial setup tasks, such as setting window titles. It requires the `unstable` feature to be enabled for the extended documentation example.

```rust
/// Defines the setup hook.
///
/// # Examples
#[cfg_attr(
  feature = "unstable",
  doc = r####"`\nuse tauri::Manager;\ntauri::Builder::default()\n  .setup(|app| {\n    let main_window = app.get_webview_window("main").unwrap();\n    main_window.set_title("Tauri!")?;\n    Ok(())\n  });\n`####
)]
#[must_use]
pub fn setup<F>(mut self, setup: F) -> Self
where
  F: FnOnce(&mut App<R>) -> std::result::Result<(), Box<dyn std::error::Error>> + Send + 'static,
{
  self.setup = Box::new(setup);
  self
}
```

--------------------------------

### NSIS Installer Hooks Example (nsh)

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Provides examples of NSIS macros that can be hooked into the main installer script for pre- and post-installation/uninstallation actions. These hooks allow custom logic execution at specific stages of the installer lifecycle.

```nsh
!macro NSIS_HOOK_PREINSTALL
  MessageBox MB_OK "PreInstall"
!macroend

!macro NSIS_HOOK_POSTINSTALL
  MessageBox MB_OK "PostInstall"
!macroend

!macro NSIS_HOOK_PREUNINSTALL
  MessageBox MB_OK "PreUnInstall"
!macroend

!macro NSIS_HOOK_POSTUNINSTALL
  MessageBox MB_OK "PostUninstall"
!macroend
```

--------------------------------

### App Setup

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Handles the initial setup of the Tauri application, including window creation and running custom setup logic.

```APIDOC
## App Setup

### Description
This function is responsible for the initial setup of the Tauri application. It creates windows based on configuration, sets up asset management, and executes any user-defined setup logic.

### Method
`setup<R: Runtime>(app: &mut App<R>) -> crate::Result<()>`

### Endpoint
N/A (Internal function)

### Parameters
- **app** (`&mut App<R>`) - A mutable reference to the application instance.

### Request Example
```rust
// This function is typically called internally by Tauri
tauri::Builder::new()
  .setup(|app| {
    // Custom setup logic here
    Ok(())
  })
  .run(tauri::generate_context!());
```

### Response
#### Success Response (200)
- **()** - Indicates successful setup.

#### Error Response
- **crate::Error::Setup** - If the custom setup logic returns an error.

```

--------------------------------

### WebviewBuilder::new

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Initializes a webview builder with a specified label and URL. Includes important notes on potential deadlocks on Windows and provides examples for setup, separate threads, and command-based creation.

```APIDOC
## POST /webview/new

### Description
Initializes a webview builder with the given webview label and URL to load.

On Windows, this function deadlocks when used in a synchronous command or event handlers. You should use `async` commands and separate threads when creating webviews.

### Method
POST

### Endpoint
/webview/new

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **label** (string) - Required - The unique label for the webview.
- **url** (WebviewUrl) - Required - The URL to load in the webview.

### Request Example
```json
{
  "label": "main-webview",
  "url": {
    "type": "App",
    "url": "index.html"
  }
}
```

### Response
#### Success Response (200)
- **webview_builder** (WebviewBuilder) - The initialized webview builder.

#### Response Example
```json
{
  "webview_builder": {
    "label": "main-webview",
    "webview_attributes": {
      "url": {
        "type": "App",
        "url": "index.html"
      }
    }
  }
}
```
```

--------------------------------

### Rust: Tauri Application Setup Function

Source: https://docs.rs/tauri/latest/src/tauri/app

The `setup` function initializes the Tauri application, sets the `ran_setup` flag, creates initial windows based on configuration, sets up assets, and executes any user-defined setup logic. It handles potential errors during the setup process.

```rust
#[cfg_attr(feature = "tracing", tracing::instrument(name = "app::setup"))]
fn setup<R: Runtime>(app: &mut App<R>) -> crate::Result<()> {
  app.ran_setup = true;

  for window_config in app.config().app.windows.iter().filter(|w| w.create) {
    WebviewWindowBuilder::from_config(app.handle(), window_config)?.build()?;
  }

  app.manager.assets.setup(app);

  if let Some(setup) = app.setup.take() {
    (setup)(app).map_err(|e| crate::Error::Setup(e.into()))?;
  }

  Ok(())
}
```

--------------------------------

### Tauri: Example of Listening to Events

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Illustrates how to set up an event listener within the Tauri application's setup. The example shows listening for a 'synchronized' event and logging a message when it's received. It also includes an example command that emits this event.

```rust
use tauri::{Manager, Listener, Emitter};

#[tauri::command]
fn synchronize(window: tauri::Window) {
  // emits the synchronized event to all windows
  window.emit("synchronized", ());
}

tauri::Builder::default()
  .setup(|app| {
    app.listen("synchronized", |event| {
      println!("app is in sync");
    });
    Ok(())
  })
  .invoke_handler(tauri::generate_handler![synchronize]);
```

--------------------------------

### Tauri Builder Setup with ResolveCommandScope Example

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Illustrates setting up a Tauri application and using `resolve_command_scope` within the `setup` hook to obtain command scope information for a specific webview window. This example requires a custom `ScopeType` struct for deserialization.

```rust
use tauri::Manager;

#[derive(Debug, serde::Deserialize)]
struct ScopeType {
  some_value: String,
}

tauri::Builder::default()
  .setup(|app| {
    let webview = app.get_webview_window("main").unwrap();
    let scope = webview.resolve_command_scope::<ScopeType>("my-plugin", "read");
    Ok(())
  });
```

--------------------------------

### Setup Tauri Application in Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Configures and initializes the Tauri application. This function creates initial windows based on configuration, sets up asset handling, and executes any user-defined setup logic. It marks the application as having run setup and returns a `Result` indicating success or failure.

```rust
#[cfg_attr(feature = "tracing", tracing::instrument(name = "app::setup"))]
fn setup<R: Runtime>(app: &mut App<R>) -> crate::Result<()>
{
  app.ran_setup = true;

  for window_config in app.config().app.windows.iter().filter(|w| w.create) {
    WebviewWindowBuilder::from_config(app.handle(), window_config)?.build()?;
  }

  app.manager.assets.setup(app);

  if let Some(setup) = app.setup.take() {
    (setup)(app).map_err(|e| crate::Error::Setup(e.into()))?;
  }

  Ok(())
}
```

--------------------------------

### Tauri Webview Module Initialization Script Example

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Demonstrates how to define initialization scripts for a Tauri webview. These scripts are executed before the main page content is loaded, allowing for early setup or injection of code.

```rust
/// Initialization script for the webview.
///
/// # Stability
///
/// This re-exported crate is still on an alpha release and might receive updates in minor Tauri releases.
pub use cookie;
use http::HeaderMap;
use serde::Serialize;
use tauri_macros::default_runtime;
pub use tauri_runtime::webview::{NewWindowFeatures, PageLoadEvent};
// Remove this re-export in v3
pub use tauri_runtime::Cookie;
#[cfg(desktop)]
use tauri_runtime::{
  dpi::{PhysicalPosition, PhysicalSize, Position, Size},
  WindowDispatch,
};
use tauri_runtime::{
  webview::{DetachedWebview, InitializationScript, PendingWebview, WebviewAttributes},
  WebviewDispatch,
};
pub use tauri_utils::config::Color;
use tauri_utils::config::{BackgroundThrottlingPolicy, WebviewUrl, WindowConfig};
pub use url::Url;

use crate::{
  app::{UriSchemeResponder, WebviewEvent},
  event::{EmitArgs, EventTarget},
  ipc::{
    CallbackFn, CommandArg, CommandItem, CommandScope, GlobalScope, Invoke, InvokeBody,
    InvokeError, InvokeMessage, InvokeResolver, Origin, OwnedInvokeResponder, ScopeObject,
  },
  manager::AppManager,
  sealed::{ManagerBase, RuntimeOrDispatch},
  AppHandle, Emitter, Event, EventId, EventLoopMessage, EventName, Listener, Manager,
  ResourceTable, Runtime, Window,
};

use std::{
  borrow::Cow,
  hash::{Hash, Hasher},
  path::{Path, PathBuf},
  sync::{Arc, Mutex, MutexGuard},
};

pub(crate) type WebResourceRequestHandler = 
  dyn Fn(http::Request<Vec<u8>>, &mut http::Response<Cow<'static, [u8]>>) + Send + Sync;
pub(crate) type NavigationHandler = dyn Fn(&Url) -> bool + Send;
pub(crate) type NewWindowHandler<R> = 
  dyn Fn(Url, NewWindowFeatures) -> NewWindowResponse<R> + Send + Sync;
pub(crate) type UriSchemeProtocolHandler = 
  Box<dyn Fn(&str, http::Request<Vec<u8>>, UriSchemeResponder) + Send + Sync>;
pub(crate) type OnPageLoad<R> = dyn Fn(Webview<R>, PageLoadPayload<'_>) + Send + Sync + 'static;
pub(crate) type OnDocumentTitleChanged<R> = dyn Fn(Webview<R>, String) + Send + 'static;
pub(crate) type DownloadHandler<R> = dyn Fn(Webview<R>, DownloadEvent<'_>) -> bool + Send + Sync;

#[derive(Clone, Serialize)]
pub(crate) struct CreatedEvent {
  pub(crate) label: String,
}

/// Download event for the [`WebviewBuilder#method.on_download`] hook.
#[non_exhaustive]
pub enum DownloadEvent<'a> {
  /// Download requested.
  Requested {
    /// The url being downloaded.
    url: Url,
    /// Represents where the file will be downloaded to.
    /// Can be used to set the download location by assigning a new path to it.
    /// The assigned path _must_ be absolute.
    destination: &'a mut PathBuf,
  },
  /// Download finished.
  Finished {
    /// The URL of the original download request.
    url: Url,
    /// Potentially representing the filesystem path the file was downloaded to.
    ///
    /// A value of `None` being passed instead of a `PathBuf` does not necessarily indicate that the download
    /// did not succeed, and may instead indicate some other failure - always check the third parameter if you need to
    /// know if the download succeeded.
    ///
    /// ## Platform-specific:
    ///
    /// - **macOS**: The second parameter indicating the path the file was saved to is always empty, due to API
    ///   limitations.
    path: Option<PathBuf>,
    /// Indicates if the download succeeded or not.
    success: bool,
  },
}

/// The payload for the [`WebviewBuilder::on_page_load`] hook.
#[derive(Debug, Clone)]
pub struct PageLoadPayload<'a> {
  pub(crate) url: &'a Url,
  pub(crate) event: PageLoadEvent,
}

impl<'a> PageLoadPayload<'a> {
  /// The page URL.
  pub fn url(&self) -> &'a Url {
    self.url
  }

  /// The page load event.
  pub fn event(&self) -> PageLoadEvent {
    self.event
  }
}

/// The IPC invoke request.
///
/// # Stability
///
/// This struct is **NOT** part of the public stable API and is only meant to be used
/// by internal code and external testing/fuzzing tools or custom invoke systems.
#[derive(Debug)]
pub struct InvokeRequest {
  /// The invoke command.
  pub cmd: String,
  /// The success callback.
  pub callback: CallbackFn,
  /// The error callback.
  pub error: CallbackFn,
  /// URL of the frame that requested this command.
  pub url: Url,
  /// The body of the request.
  pub body: InvokeBody,
  /// The request headers.

```

--------------------------------

### Example: Initialize JavaScript in Tauri

Source: https://docs.rs/tauri/2/tauri/webview/struct

Demonstrates how to use the `initialization_script` method within a Tauri application setup to inject custom JavaScript into a webview window. The example shows defining a script and passing it to the builder.

```rust
const INIT_SCRIPT: &str = r#"\n  if (window.location.origin === 'https://tauri.app') {\n    console.log(\"hello world from js init script\");\n\n    window.__MY_CUSTOM_PROPERTY__ = { foo: 'bar' };\n  }\n"#;

fn main() {
  tauri::Builder::default()
    .setup(|app| {
      let webview = tauri::WebviewWindowBuilder::new(app, "label", tauri::WebviewUrl::App("index.html".into()))
        .initialization_script(INIT_SCRIPT)
        .build()?;
      Ok(())
    });
}
```

--------------------------------

### Setup Plugin Initialization - Rust

Source: https://docs.rs/tauri/2.8.5/src/tauri/plugin

Defines a closure that runs when the plugin is registered. This setup function is essential for initializing plugin state, managing resources, or performing any necessary setup logic before the plugin becomes active. It takes an AppHandle and PluginApi as arguments and returns a Result.

```rust
pub fn setup<F>(mut self, setup: F) -> Self
    where
      F: FnOnce(&AppHandle<R>, PluginApi<R, C>) -> Result<(), Box<dyn std::error::Error>>
        + Send
        + 'static,
  {
    self.setup.replace(Box::new(setup));
    self
  }
```

--------------------------------

### Build and Initialize Tauri Application

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Constructs the Tauri application instance, incorporating setup logic, core plugins, and managed services like environment and scope configurations. It prepares the application for execution, including optional menu and tray icon setup.

```rust
let mut app = App {
  runtime: Some(runtime),
  setup: Some(self.setup),
  manager: manager.clone(),
  handle: AppHandle {
    runtime_handle,
    manager,
    event_loop: Arc::new(Mutex::new(EventLoop {
      main_thread_id: std::thread::current().id(),
    })),
  },
  ran_setup: false,
};

#[cfg(desktop)]
if let Some(menu) = self.menu {
  let menu = menu(&app.handle)?;
  app
    .manager
    .menu
    .menus_stash_lock()
    .insert(menu.id().clone(), menu.clone());

  #[cfg(target_os = "macos")]
  init_app_menu(&menu)?;

  app.manager.menu.menu_lock().replace(menu);
}

app.register_core_plugins()?;

let env = Env::default();
app.manage(env);

app.manage(Scopes {
  #[cfg(feature = "protocol-asset")]
  asset_protocol: crate::scope::fs::Scope::new(
    &app,
    &app.config().app.security.asset_protocol.scope,
  )?,
});

app.manage(ChannelDataIpcQueue::default());
app.handle.plugin(crate::ipc::channel::plugin())?;

let handle = app.handle();

// initialize default tray icon if defined
#[cfg(all(desktop, feature = "tray-icon"))]
{
  let config = app.config();
  if let Some(tray_config) = &config.app.tray_icon {
    #[allow(deprecated)]
    let mut tray =
      TrayIconBuilder::with_id(tray_config.id.clone().unwrap_or_else(|| "main".into()))
        .icon_as_template(tray_config.icon_as_template)
        .menu_on_left_click(tray_config.menu_on_left_click)
        .show_menu_on_left_click(tray_config.show_menu_on_left_click);
    if let Some(icon) = &app.manager.tray.icon {
      tray = tray.icon(icon.clone());
    }
    if let Some(title) = &tray_config.title {
      tray = tray.title(title);
    }
    if let Some(tooltip) = &tray_config.tooltip {
      tray = tray.tooltip(tooltip);
    }
    tray.build(handle)?;
  }
}

app.manager.initialize_plugins(handle)?;

Ok(app)
```

--------------------------------

### Configure Start Menu Folder in Tauri Installer

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

Set a custom folder name for application shortcuts in the Windows Start Menu. This is useful for organizing shortcuts, especially when deploying multiple applications from the same publisher. If not specified, shortcuts are placed directly under the 'Programs' folder. For example, 'AwesomePublisher' will create shortcuts under '%AppData%\Microsoft\Windows\Start Menu\Programs\AwesomePublisher'.

```Rust
pub start_menu_folder: Option<String>
```

--------------------------------

### Example: Setting Up a Menu and Event Listener in Rust

Source: https://docs.rs/tauri/latest/src/tauri/window/mod

Demonstrates how to create a menu with items and attach an event listener to it for a specific window in a Tauri application. This example requires the 'unstable' feature.

```rust
use tauri::menu::{Menu, Submenu, MenuItem};
tauri::Builder::default()
  .setup(|app| {
    let handle = app.handle();
    let save_menu_item = MenuItem::new(handle, "Save", true, None::<&str>)?;
    let menu = Menu::with_items(handle, &[
      &Submenu::with_items(handle, "File", true, &[
        &save_menu_item,
      ])?,
    ])?;
    let window = tauri::window::WindowBuilder::new(app, "editor")
      .menu(menu)
      .build()
      .unwrap();

    window.on_menu_event(move |window, event| {
      if event.id == save_menu_item.id() {
          // save menu item
      }
    });

    Ok(())
  });
```

--------------------------------

### Build and Run Tauri Application Example

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Demonstrates how to build and run a Tauri application using the Builder. This example showcases the basic usage of the `Builder::default()` and `run()` methods, including how to specify the configuration file for the application context.

```rust
tauri::Builder::default()
  // on an actual app, remove the string argument
  .run(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
 .expect("error while running tauri application");

```

--------------------------------

### Example: Tauri Devtools and Close Example

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Demonstrates how to open developer tools, wait for a specified duration, and then close them within a Tauri application setup. This example is conditional on the `debug_assertions` feature being enabled.

```rust
use tauri::Manager;
tauri::Builder::default()
  .setup(|app| {
    #[cfg(debug_assertions)]
    {
      let webview = app.get_webview("main").unwrap();
      webview.open_devtools();
      std::thread::spawn(move || {
        std::thread::sleep(std::time::Duration::from_secs(10));
        webview.close_devtools();
      });
    }
    Ok(())
  });
```

--------------------------------

### WebviewBuilder::new

Source: https://docs.rs/tauri/latest/src/tauri/webview/mod

Initializes a webview builder with the given webview label and URL to load. It includes known issues and examples for creating webviews in different contexts like setup hooks, separate threads, and commands.

```APIDOC
## WebviewBuilder::new

### Description
Initializes a webview builder with the given webview label and URL to load.

### Method
`new`

### Endpoint
N/A (Constructor)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
None

### Request Example
```rust
let webview_builder = tauri::webview::WebviewBuilder::new("label", tauri::WebviewUrl::App("index.html".into()));
```

### Response
#### Success Response (200)
N/A (Constructor)

#### Response Example
N/A (Constructor)
```

--------------------------------

### Setup Plugin with State Management (Rust)

Source: https://docs.rs/tauri/2.8.5/tauri/plugin/struct

Defines a closure that runs when a Tauri plugin is registered. This example demonstrates managing plugin-specific state using `app.manage()`.

```rust
use tauri::{plugin::{Builder, TauriPlugin}, Runtime, Manager};
use std::path::PathBuf;

#[derive(Debug, Default)]
struct PluginState {
   dir: Option<PathBuf>
}

fn init<R: Runtime>() -> TauriPlugin<R> {
Builder::new("example")
  .setup(|app, api| {
    app.manage(PluginState::default());

    Ok(())
  })
  .build()
}
```

--------------------------------

### Setup Hook

Source: https://docs.rs/tauri/latest/src/tauri/app

Configures the setup hook for the Tauri application. This function is called once when the application is initialized.

```APIDOC
## POST /setup

### Description
Defines the setup hook for the Tauri application. This function is executed once during application initialization.

### Method
POST

### Endpoint
/setup

### Parameters
#### Request Body
- **setup** (function) - Required - A closure that takes a mutable reference to the `App` and returns a `Result`.

### Request Example
```rust
tauri::Builder::default()
  .setup(|app| {
    let main_window = app.get_webview_window("main").unwrap();
    main_window.set_title("Tauri!")?;
    Ok(())
  });
```

### Response
#### Success Response (200)
- **TauriBuilder** (object) - The updated Tauri builder instance.

#### Response Example
```json
{
  "message": "Setup hook configured successfully."
}
```
```

--------------------------------

### Example: Set macOS Activation Policy (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/app

An example illustrating how to set the activation policy for a macOS application using `tauri::ActivationPolicy::Accessory` within the `tauri::Builder::default().setup()` closure.

```rust
tauri::Builder::default()
  .setup(move |app| {
    #[cfg(target_os = "macos")]
    app.set_activation_policy(tauri::ActivationPolicy::Accessory);
    Ok(())
  });
```

--------------------------------

### Listen to Window Events (Rust Example)

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/mod

Allows listening to events emitted by a specific window. This is useful for reacting to actions within the UI, such as component loading. The handler is a closure that accepts an Event. This example demonstrates setting up an event listener during application setup.

```rust
use tauri::{Manager, Listener);

tauri::Builder::default()
  .setup(|app| {
    let window = app.get_window("main").unwrap();
    window.listen("component-loaded", move |event| {
      println!("window just loaded a component");
    });

    Ok(())
  });
```

--------------------------------

### Example: Set macOS Dock Visibility (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/app

Provides an example of how to set the Dock visibility for a macOS application to hidden (false) within the application setup.

```rust
tauri::Builder::default()
  .setup(move |app| {
    #[cfg(target_os = "macos")]
    app.set_dock_visibility(false);
    Ok(())
  });
```

--------------------------------

### Run Tauri App Builder

Source: https://docs.rs/tauri/latest/src/tauri/app

This example demonstrates how to use the Tauri `Builder` to configure and run a Tauri application. It uses `tauri::generate_context!` to load the application context from a `tauri.conf.json` file.  The `run` method starts the application and handles any potential errors.

```Rust
tauri::Builder::default()
  // on an actual app, remove the string argument
  .run(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
  .expect("error while running tauri application");
```

--------------------------------

### Tauri Setup Hook Configuration (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/app

Configures the setup hook for a Tauri application, which runs once the application is initialized. It accepts a closure that receives a mutable reference to the App and returns a Result. This is useful for initial setup tasks like setting window titles.

```Rust
/// Defines the setup hook.
///
/// # Examples
#[cfg_attr(
  feature = "unstable",
  doc = r####"
```
use tauri::Manager;
tauri::Builder::default()
  .setup(|app| {
    let main_window = app.get_webview_window("main").unwrap();
    main_window.set_title("Tauri!")?;
    Ok(())
  });
```
"####
)]
#[must_use]
pub fn setup<F>(mut self, setup: F) -> Self
where
  F: FnOnce(&mut App<R>) -> std::result::Result<(), Box<dyn std::error::Error>> + Send + 'static,
{
  self.setup = Box::new(setup);
  self
}
```

--------------------------------

### Build Basic Tauri Application - Rust

Source: https://context7.com/context7/rs-tauri/llms.txt

Constructs and configures a basic Tauri application using the `Builder` API. It includes a setup hook to print the application version upon startup. This is the entry point for most Tauri applications.

```rust
fn main() {
    tauri::Builder::default()
        .setup(|app| {
            println!("App version: {}", app.package_info().version);
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

--------------------------------

### Builder Setup and Configuration

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Details on initializing and configuring the Tauri application builder, including setting up invoke handlers, initialization scripts, and plugins.

```APIDOC
## Builder<R: Runtime>

### Description
Used to build and configure a Tauri application. It allows setting up various handlers, scripts, and plugins.

### Method
`Builder::new()`

### Endpoint
N/A (Struct method)

### Parameters
None

### Request Example
```rust
let builder = tauri::Builder::new();
```

### Response
#### Success Response (200)
Returns a new instance of `Builder`.

#### Response Example
```json
{
  "message": "Builder initialized successfully"
}
```
```

--------------------------------

### Example: Get IPC Response in Tauri (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/test/mod

Illustrates how to retrieve the response of an IPC message using `get_ipc_response` and then deserialize it to verify the command's output. This example showcases how to get raw IPC results for more granular testing.

```rust
use tauri::test::{mock_builder, mock_context, noop_assets};

#[tauri::command]
fn ping() -> &'static str {
    "pong"
}

fn create_app<R: tauri::Runtime>(builder: tauri::Builder<R>) -> tauri::App<R> {
    builder
        .invoke_handler(tauri::generate_handler![ping])
        // remove the string argument to use your app's config file
        .build(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
        .expect("failed to build app")
}

fn main() {
    let app = create_app(mock_builder());
    let webview = tauri::WebviewWindowBuilder::new(&app, "main", Default::default()).build().unwrap();

    // run the `ping` command and assert it returns `pong`
    let res = tauri::test::get_ipc_response(
        &webview,
        tauri::webview::InvokeRequest {
            cmd: "ping".into(),
            callback: tauri::ipc::CallbackFn(0),
            error: tauri::ipc::CallbackFn(1),
            url: "http://tauri.localhost".parse().unwrap(),
            body: tauri::ipc::InvokeBody::default(),
            headers: Default::default(),
            invoke_key: tauri::test::INVOKE_KEY.to_string(),
        },
    );
    assert!(res.is_ok());
    assert_eq!(res.unwrap().deserialize::<String>().unwrap(), String::from("pong"));
}
```

--------------------------------

### Example: Tauri Check Devtools Status

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Illustrates checking if the developer tools are open and opening them if they are not. This example is also conditional on `debug_assertions` and is part of the application setup process.

```rust
use tauri::Manager;
tauri::Builder::default()
  .setup(|app| {
    #[cfg(debug_assertions)]
    {
      let webview = app.get_webview("main").unwrap();
      if !webview.is_devtools_open() {
        webview.open_devtools();
      }
    }
    Ok(())
  });
```

--------------------------------

### App Setup and Configuration

Source: https://docs.rs/tauri/latest/src/tauri/app

Methods for setting up core plugins, running code on the main thread, and configuring application-specific settings like activation policy and dock visibility.

```APIDOC
## POST /app/setup/plugins

### Description
Registers the core plugins for the application.

### Method
POST

### Endpoint
/app/setup/plugins

### Parameters
No parameters are required for this operation.

### Request Example
(No request body)

### Response
#### Success Response (200)
- Indicates successful registration of core plugins.

#### Response Example
(No content)

## POST /app/run_on_main_thread

### Description
Runs the given closure on the main thread.

### Method
POST

### Endpoint
/app/run_on_main_thread

### Parameters
#### Request Body
- **f** (function) - Required - The closure to execute on the main thread.

### Request Example
```json
{
  "f": "function() { console.log('Running on main thread'); }"
}
```

### Response
#### Success Response (200)
- Indicates the closure was successfully scheduled and executed on the main thread.

#### Response Example
(No content)

## POST /app/set_activation_policy

### Description
Sets the activation policy for the application (macOS only).

### Method
POST

### Endpoint
/app/set_activation_policy

### Parameters
#### Request Body
- **activation_policy** (ActivationPolicy) - Required - The activation policy to set (e.g., Regular, Accessory, Prohibited, Error).

### Request Example
```json
{
  "activation_policy": "Accessory"
}
```

### Response
#### Success Response (200)
- Indicates the activation policy was successfully set.

#### Response Example
(No content)

## POST /app/set_dock_visibility

### Description
Sets the dock visibility for the application (macOS only).

### Method
POST

### Endpoint
/app/set_dock_visibility

### Parameters
#### Request Body
- **visible** (boolean) - Required - Whether the dock should be visible.

### Request Example
```json
{
  "visible": false
}
```

### Response
#### Success Response (200)
- Indicates the dock visibility was successfully set.

#### Response Example
(No content)

## POST /app/set_device_event_filter

### Description
Changes the device event filter mode. This affects how device events are captured when the window is unfocused.

### Method
POST

### Endpoint
/app/set_device_event_filter

### Parameters
#### Request Body
- **filter** (DeviceEventFilter) - Required - The new device event filter mode (e.g., Always, Blurred, Never).

### Request Example
```json
{
  "filter": "Always"
}
```

### Response
#### Success Response (200)
- Indicates the device event filter was successfully updated.

#### Response Example
(No content)
```

--------------------------------

### Get Available Monitors (Rust)

Source: https://docs.rs/tauri/2.8.4/x86_64-unknown-linux-gnu/tauri/app/struct

Fetches a list of all monitors currently connected and available to the system. This is essential for multi-monitor setups and UI scaling. Requires the Tauri runtime.

```rust
pub fn available_monitors(&self) -> Result<Vec<Monitor>>
```

--------------------------------

### Setup Hook Configuration in Tauri

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Defines the setup hook for a Tauri application. This function is executed once the application is ready. It allows for initialization tasks, such as setting window titles. Dependencies include the `tauri::Manager` trait. The input is a closure that returns a `Result`. Limitations include that it must be run once.

```rust
/// Defines the setup hook.
///
/// # Examples
#[cfg_attr(
  feature = "unstable",
  doc = r####"`
use tauri::Manager;
tauri::Builder::default()
  .setup(|app| {
    let main_window = app.get_window("main").unwrap();
    main_window.set_title("Tauri!")?;
    Ok(())
  });
`####
)]
#[must_use]
pub fn setup<F>(mut self, setup: F) -> Self
where
  F: FnOnce(&mut App<R>) -> std::result::Result<(), Box<dyn std::error::Error>> + Send + 'static,
{
  self.setup = Box::new(setup);
  self
}
```

--------------------------------

### JSON: Example Tauri Configuration File

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

This is an example JSON file for configuring a Tauri application. It includes settings for the product name, version, build process (like pre-build commands and frontend distribution paths), app-specific configurations (security, windows), bundle settings, and plugins. This file format is the default for Tauri projects.

```json
{
  "productName": "tauri-app",
  "version": "0.1.0",
  "build": {
    "beforeBuildCommand": "",
    "beforeDevCommand": "",
    "devUrl": "http://localhost:3000",
    "frontendDist": "../dist"
  },
  "app": {
    "security": {
      "csp": null
    },
    "windows": [
      {
        "fullscreen": false,
        "height": 600,
        "resizable": true,
        "title": "Tauri App",
        "width": 800
      }
    ]
  },
  "bundle": {},
  "plugins": {}
}
```

--------------------------------

### Create Tauri Webview Window in Setup Hook (Rust)

Source: https://docs.rs/tauri/2/tauri/webview/struct

Demonstrates how to create a new webview window using WebviewWindowBuilder within the setup hook of a Tauri application. This is a common pattern for initializing the main application window.

```rust
tauri::Builder::default()
  .setup(|app| {
    let webview_window = tauri::WebviewWindowBuilder::new(app, "label", tauri::WebviewUrl::App("index.html".into()))
      .build()?;
    Ok(())
  });

```

--------------------------------

### Listen to Webview Event (Rust Example)

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Listens for a specific event emitted by a webview. This example demonstrates setting up a listener within the `setup` hook of a Tauri application. The handler is executed whenever the 'component-loaded' event is received.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let webview = app.get_webview("main").unwrap();
    webview.listen("component-loaded", move |event| {
      println!("webview just loaded a component");
    });

    Ok(())
  });

```

--------------------------------

### Rust: Example of Dynamically Adding Capabilities in Tauri

Source: https://docs.rs/tauri/2.8.5/src/tauri/lib

Illustrates how to add custom capabilities to a Tauri application during the setup phase. The example shows conditional inclusion of capabilities based on build features (`#[cfg(feature = "beta")]` and `#[cfg(feature = "stable")]`). It also references the `tauri.conf.json` configuration and `tauri_build` for managing capability paths.

```rust
use tauri::Manager;

tauri::Builder::default()
  .setup(|app| {
    #[cfg(feature = "beta")]
    app.add_capability(include_str!("../capabilities/beta/cap.json"));

    #[cfg(feature = "stable")]
    app.add_capability(include_str!("../capabilities/stable/cap.json"));
    Ok(())
  });
```

--------------------------------

### HTTP Header Example Output (http)

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Illustrates the resulting HTTP response headers for a 'helloworld' example in Tauri. This snippet shows the exact string values that would be sent to the client for various headers, demonstrating the output of the `HeaderConfig` serialization process.

```http
access-control-allow-origin:  http://tauri.localhost
access-control-expose-headers: Tauri-Custom-Header
content-security-policy: default-src 'self'; connect-src ipc: http://ipc.localhost; script-src 'self' 'sha256-Wjjrs6qinmnr+tOry8x8PPwI77eGpUFR3EEGZktjJNs='
content-type: text/html
cross-origin-embedder-policy: require-corp
cross-origin-opener-policy: same-origin
tauri-custom-header: key1 'value1' 'value2'; key2 'value3'
timing-allow-origin: https://developer.mozilla.org, https://example.com
```

--------------------------------

### Rust Tauri State Management and Retrieval Examples

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Illustrates managing and retrieving different types of state within a Tauri application using Rust. It showcases the `manage` function to set up states and `app.state()` to access them, including examples with simple types like `isize` and `String`, and demonstrates the `State` guard for accessing state within commands.

```rust
use tauri::{Manager, State};

struct MyInt(isize);
struct MyString(String);

#[tauri::command]
fn int_command(state: State<MyInt>) -> String {
    format!("The stateful int is: {}", state.0)
}

#[tauri::command]
fn string_command<'r>(state: State<'r, MyString>) {
    println!("state: {}", state.inner().0);
}

tauri::Builder::default()
  .setup(|app| {
    app.manage(MyInt(0));
    app.manage(MyString("tauri".into()));
    // `MyInt` is already managed, so `manage()` returns false
    assert!(!app.manage(MyInt(1)));
    // read the `MyInt` managed state with the turbofish syntax
    let int = app.state::<MyInt>();
    assert_eq!(int.0, 0);
    // read the `MyString` managed state with the `State` guard
    let val: State<MyString> = app.state();
    assert_eq!(val.0, "tauri");
    Ok(())
  })
  .invoke_handler(tauri::generate_handler![int_command, string_command])
  // on an actual app, remove the string argument
  .run(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
  .expect("error while running tauri application");

```

--------------------------------

### Listen Once to Window Events (Rust Example)

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Similar to `listen`, but the handler is called only once for the specified event. This is useful for events that occur a single time. The example shows how to use `once` within a Tauri application setup.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let window = app.get_window("main").unwrap();
    let window_ = window.clone();
    let handler = window.listen("component-loaded", move |event| {
      println!("window just loaded a component");

      // we no longer need to listen to the event
      // we also could have used `window.once` instead
      window_.unlisten(event.id());
    });

    // stop listening to the event when you do not need it anymore
    window.unlisten(handler);

    Ok(())
  });
```

--------------------------------

### Get Cursor Position (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Gets the cursor's position relative to the desktop's top-left corner. This accounts for multi-monitor setups and can return negative coordinates.

```rust
/// Get the cursor position relative to the top-left hand corner of the desktop.
///
/// Note that the top-left hand corner of the desktop is not necessarily the same as the screen.
/// If the user uses a desktop with multiple monitors,
/// the top-left hand corner of the desktop is the top-left hand corner of the main monitor on Windows and macOS
/// or the top-left of the leftmost monitor on X11.
///
/// The coordinates can be negative if the top-left hand corner of the window is outside of the visible screen region.
pub fn cursor_position(&self) -> crate::Result<PhysicalPosition<f64>> {
  self.app_handle.cursor_position()
}
```

--------------------------------

### Example: Ping Command Test in Tauri (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/test/mod

Demonstrates how to set up a mock application, create a webview window, and use `assert_ipc_response` to test a simple 'ping' command. This example illustrates a common testing pattern for Tauri applications.

```rust
use tauri::test::{mock_builder, mock_context, noop_assets};

#[tauri::command]
fn ping() -> &'static str {
    "pong"
}

fn create_app<R: tauri::Runtime>(builder: tauri::Builder<R>) -> tauri::App<R> {
    builder
        .invoke_handler(tauri::generate_handler![ping])
        // remove the string argument to use your app's config file
        .build(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
        .expect("failed to build app")
}

fn main() {
    let app = create_app(mock_builder());
    let webview = tauri::WebviewWindowBuilder::new(&app, "main", Default::default()).build().unwrap();

    // run the `ping` command and assert it returns `pong`
    tauri::test::assert_ipc_response(
        &webview,
        tauri::webview::InvokeRequest {
            cmd: "ping".into(),
            callback: tauri::ipc::CallbackFn(0),
            error: tauri::ipc::CallbackFn(1),
            url: "http://tauri.localhost".parse().unwrap(),
            body: tauri::ipc::InvokeBody::default(),
            headers: Default::default(),
            invoke_key: tauri::test::INVOKE_KEY.to_string(),
        },
      Ok("pong")
    );
}
```

--------------------------------

### Tauri Webview Window Builder Example (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Illustrates the usage of `WebviewWindowBuilder` to create and configure a new webview window. This includes setting the window label, content, and other properties before building the window.

```rust
pub use webview_window::{WebviewWindow, WebviewWindowBuilder};

/// Cookie crate used for [`Webview::set_cookie`] and [`Webview::delete_cookie`].
///
/// # Stability
///
/// This re-exported crate is still on an alpha release and might receive updates in minor Tauri releases.
pub use cookie;
use http::HeaderMap;
use serde::Serialize;
use tauri_macros::default_runtime;
pub use tauri_runtime::webview::{NewWindowFeatures, PageLoadEvent};
// Remove this re-export in v3
pub use tauri_runtime::Cookie;
#[cfg(desktop)]
use tauri_runtime::{
  dpi::{PhysicalPosition, PhysicalSize, Position, Size},
  WindowDispatch,
};
use tauri_runtime::{
  webview::{DetachedWebview, InitializationScript, PendingWebview, WebviewAttributes},
  WebviewDispatch,
};
pub use tauri_utils::config::Color;
use tauri_utils::config::{BackgroundThrottlingPolicy, WebviewUrl, WindowConfig};
pub use url::Url;

use crate::{
  app::{UriSchemeResponder, WebviewEvent},
  event::{EmitArgs, EventTarget},
  ipc::{
    CallbackFn, CommandArg, CommandItem, CommandScope, GlobalScope, Invoke, InvokeBody,
    InvokeError, InvokeMessage, InvokeResolver, Origin, OwnedInvokeResponder, ScopeObject,
  },
  manager::AppManager,
  sealed::{ManagerBase, RuntimeOrDispatch},
  AppHandle, Emitter, Event, EventId, EventLoopMessage, EventName, Listener, Manager,
  ResourceTable, Runtime, Window,
};

use std::{
  borrow::Cow,
  hash::{Hash, Hasher},
  path::{Path, PathBuf},
  sync::{Arc, Mutex, MutexGuard},
};

pub(crate) type WebResourceRequestHandler = 
  dyn Fn(http::Request<Vec<u8>>, &mut http::Response<Cow<'static, [u8]>>) + Send + Sync;
pub(crate) type NavigationHandler = dyn Fn(&Url) -> bool + Send;
pub(crate) type NewWindowHandler<R> = 
  dyn Fn(Url, NewWindowFeatures) -> NewWindowResponse<R> + Send + Sync;
pub(crate) type UriSchemeProtocolHandler = 
  Box<dyn Fn(&str, http::Request<Vec<u8>>, UriSchemeResponder) + Send + Sync>;
pub(crate) type OnPageLoad<R> = dyn Fn(Webview<R>, PageLoadPayload<'_>) + Send + Sync + 'static;
pub(crate) type OnDocumentTitleChanged<R> = dyn Fn(Webview<R>, String) + Send + 'static;
pub(crate) type DownloadHandler<R> = dyn Fn(Webview<R>, DownloadEvent<'_>) -> bool + Send + Sync;

#[derive(Clone, Serialize)]
pub(crate) struct CreatedEvent {
  pub(crate) label: String,
}

/// Download event for the [`WebviewBuilder#method.on_download`] hook.
#[non_exhaustive]
pub enum DownloadEvent<'a> {
  /// Download requested.
  Requested {
    /// The url being downloaded.
    url: Url,
    /// Represents where the file will be downloaded to.
    /// Can be used to set the download location by assigning a new path to it.
    /// The assigned path _must_ be absolute.
    destination: &'a mut PathBuf,
  },
  /// Download finished.
  Finished {
    /// The URL of the original download request.
    url: Url,
    /// Potentially representing the filesystem path the file was downloaded to.
    ///
    /// A value of `None` being passed instead of a `PathBuf` does not necessarily indicate that the download
    /// did not succeed, and may instead indicate some other failure - always check the third parameter if you need to
    /// know if the download succeeded.
    ///
    /// ## Platform-specific:
    ///
    /// - **macOS**: The second parameter indicating the path the file was saved to is always empty, due to API
    ///   limitations.
    path: Option<PathBuf>,
    /// Indicates if the download succeeded or not.
    success: bool,
  },
}

/// The payload for the [`WebviewBuilder::on_page_load`] hook.
#[derive(Debug, Clone)]
pub struct PageLoadPayload<'a> {
  pub(crate) url: &'a Url,
  pub(crate) event: PageLoadEvent,
}

impl<'a> PageLoadPayload<'a> {
  /// The page URL.
  pub fn url(&self) -> &'a Url {
    self.url
  }

  /// The page load event.
  pub fn event(&self) -> PageLoadEvent {
    self.event
  }
}

/// The IPC invoke request.
///
/// # Stability
///
/// This struct is **NOT** part of the public stable API and is only meant to be used
/// by internal code and external testing/fuzzing tools or custom invoke systems.
#[derive(Debug)]
pub struct InvokeRequest {
  /// The invoke command.
  pub cmd: String,
  /// The success callback.
  pub callback: CallbackFn,
  /// The error callback.
  pub error: CallbackFn,
  /// URL of the frame that requested this command.
  pub url: Url,
  /// The body of the request.
  pub body: InvokeBody,
  /// The request headers.

```

--------------------------------

### Create Webview Window with Label and URL (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Initializes a `WebviewWindowBuilder` with a given window label and a URL to load. This is a common starting point for creating new webview windows. It's important to note potential deadlocks on Windows when used in synchronous contexts, recommending async operations instead.

```rust
pub fn new<L: Into<String>>(manager: &'a M, label: L, url: WebviewUrl) -> Self {
  let label = label.into();
  Self {
    window_builder: WindowBuilder::new(manager, &label),
    webview_builder: WebviewBuilder::new(&label, url),
  }
}
```

--------------------------------

### Tauri Plugin Initialization and Command Invocation

Source: https://docs.rs/tauri/2.8.5/tauri/struct

Demonstrates how to define and initialize a Tauri plugin with setup logic and event handlers. It also shows how to register a command within the plugin that can be invoked from the frontend.

```rust
mod plugin {
  use tauri::{plugin::{Builder as PluginBuilder, TauriPlugin}, RunEvent, Runtime};

  // this command can be called in the frontend using `invoke('plugin:window|do_something')`.
  #[tauri::command]
  async fn do_something<R: Runtime>(app: tauri::AppHandle<R>, window: tauri::Window<R>) -> Result<(), String> {
    println!("command called");
    Ok(())
  }
  pub fn init<R: Runtime>() -> TauriPlugin<R> {
    PluginBuilder::new("window")
      .setup(|app, api| {
        // initialize the plugin here
        Ok(())
      })
      .on_event(|app, event| {
        match event {
          RunEvent::Ready => {
            println!("app is ready");
          }
          RunEvent::WindowEvent { label, event, .. } => {
            println!("window {} received an event: {:?}", label, event);
          }
          _ => (),
        }
      })
      .invoke_handler(tauri::generate_handler![do_something])
      .build()
  }
}

tauri::Builder::default()
  .plugin(plugin::init());
```

--------------------------------

### RuntimeInitArgs

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

Structure for initializing the runtime, with platform-specific options.

```APIDOC
## RuntimeInitArgs

### Description

`RuntimeInitArgs` is a struct used to configure the initialization of the webview runtime. It contains fields that are specific to certain operating systems.

### Fields

- **`app_id`** (`Option<String>`) - Required/Optional - The application ID, used on Linux and other Unix-like systems.
- **`msg_hook`** (`Option<Box<dyn FnMut(*const std::ffi::c_void) -> bool + 'static>>`) - Required/Optional - A message hook function for Windows applications.
```

--------------------------------

### Listen to Window Events (Rust Example)

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Allows listening to events on a specific window. This function takes an event name and a handler closure. It returns an `EventId` that can be used to unlisten. The example demonstrates listening for a 'component-loaded' event within a Tauri application setup.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let window = app.get_window("main").unwrap();
    window.listen("component-loaded", move |event| {
      println!("window just loaded a component");
    });

    Ok(())
  });
```

--------------------------------

### Tauri App Builder Initialization and Running

Source: https://docs.rs/tauri/2.8.5/tauri/struct

Initializes the Tauri application builder and runs the application with the specified context. This is the primary method for starting a Tauri application.

```Rust
pub struct Builder<R: Runtime> { /* private fields */ }

tauri::Builder::default()
  // on an actual app, remove the string argument
  .run(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
 .expect("error while running tauri application");
```

--------------------------------

### Create Webview in Tauri Setup Hook (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Demonstrates creating a webview within the Tauri application's setup hook. It initializes a `WebviewBuilder` with a specific label and URL, then adds it as a child to a window. This is suitable for initializing the main application webview.

```rust
tauri::Builder::default()
  .setup(|app| {
    let window = tauri::window::WindowBuilder::new(app, "label").build()?;
    let webview_builder = tauri::webview::WebviewBuilder::new("label", tauri::WebviewUrl::App("index.html".into()));
    let webview = window.add_child(webview_builder, tauri::LogicalPosition::new(0, 0), window.inner_size().unwrap());
    Ok(())
  });
```

--------------------------------

### Plugin Setup

Source: https://docs.rs/tauri/latest/tauri/plugin/struct

Define a closure that runs when the plugin is registered.

```APIDOC
## POST /plugin/setup

### Description
Define a closure that runs when the plugin is registered.

### Method
POST

### Endpoint
/plugin/setup

### Parameters
#### Request Body
- **setup** (function) - Required - A closure that runs when the plugin is registered.

### Request Example
```json
{
  "setup": "fn(&AppHandle<R>, PluginApi<R, C>) -> Result<(), Box<dyn Error>>"
}
```

### Response
#### Success Response (200)
- **message** (string) - Confirmation of successful setup.

#### Response Example
```json
{
  "message": "Plugin setup complete."
}
```
```

--------------------------------

### Rust: Tauri PathResolver Resolve Method Example

Source: https://docs.rs/tauri/latest/src/tauri/path/mod

This example demonstrates how to use the `resolve` method of Tauri's `PathResolver` to construct a full path by combining a relative path with a specified base directory. It requires a `tauri::Manager` and is typically used within the application's setup.

```rust
use tauri::{path::BaseDirectory, Manager};

tauri::Builder::default()
  .setup(|app| {
    let path = app.path().resolve("path/to/something", BaseDirectory::Config)?;
    assert_eq!(path.to_str().unwrap(), "/home/${whoami}/.config/path/to/something");
    Ok(())
  });

```

--------------------------------

### Rust: Tauri PathResolver Resolve Method Example

Source: https://docs.rs/tauri/2.8.5/src/tauri/path/mod

Demonstrates the `resolve` method of Tauri's `PathResolver` in Rust. This method takes a relative path and a `BaseDirectory` to construct an absolute path. The example shows how to use it within a Tauri application's setup.

```rust
use tauri::{path::BaseDirectory, Manager};
tauri::Builder::default()
  .setup(|app| {
    let path = app.path().resolve("path/to/something", BaseDirectory::Config)?;
    assert_eq!(path.to_str().unwrap(), "/home/${whoami}/.config/path/to/something");
    Ok(())
  });
```

--------------------------------

### Rust: Setup Plugin with Closure

Source: https://docs.rs/tauri/2.8.4/src/tauri/plugin

Defines a setup closure that is executed when the plugin is registered. This closure can manage plugin state and perform initialization tasks. It takes the application handle and plugin API as arguments.

```rust
pub fn setup<F>(mut self, setup: F) -> Self
where
  F: FnOnce(&AppHandle<R>, PluginApi<R, C>) -> Result<(), Box<dyn std::error::Error>>
    + Send
    + 'static,
{
  self.setup.replace(Box::new(setup));
  self
}
```

--------------------------------

### Rust: Event Setup and Listener Macro for Tauri

Source: https://docs.rs/tauri/2.8.4/src/tauri/manager/mod

Sets up event listeners for various Tauri application components (App, Window, Webview, WebviewWindow). It utilizes a macro `setup_listener!` to abstract the common logic for attaching both specific and any event listeners, allowing for flexible event handling in tests.

```Rust
struct EventSetup {
    app: App<MockRuntime>,
    window: Window<MockRuntime>,
    webview: Webview<MockRuntime>,
    webview_window: WebviewWindow<MockRuntime>,
    tx: Sender<(&'static str, String)>,
    rx: Receiver<(&'static str, String)>,
  }

  fn setup_events(setup_any: bool) -> EventSetup {
    let app = mock_app();

    let window = WindowBuilder::new(&app, "main-window").build().unwrap();

    let webview = window
      .add_child(
        WebviewBuilder::new("main-webview", Default::default()),
        crate::LogicalPosition::new(0, 0),
        window.inner_size().unwrap(),
      )
      .unwrap();

    let webview_window = WebviewWindowBuilder::new(&app, "main-webview-window", Default::default())
      .build()
      .unwrap();

    let (tx, rx) = channel();

    macro_rules! setup_listener {
      ($type:ident, $id:ident, $any_id:ident) => {
        let tx_ = tx.clone();
        $type.listen(TEST_EVENT_NAME, move |evt| {
          tx_
            .send(($id, serde_json::from_str::<String>(evt.payload()).unwrap()))
            .unwrap();
        });

        if setup_any {
          let tx_ = tx.clone();
          $type.listen_any(TEST_EVENT_NAME, move |evt| {
            tx_
              .send((
                $any_id,
                serde_json::from_str::<String>(evt.payload()).unwrap(),
              ))
              .unwrap();
          });
        }
      };
    }

    setup_listener!(app, APP_LISTEN_ID, APP_LISTEN_ANY_ID);
    setup_listener!(window, WINDOW_LISTEN_ID, WINDOW_LISTEN_ANY_ID);
    setup_listener!(webview, WEBVIEW_LISTEN_ID, WEBVIEW_LISTEN_ANY_ID);
    setup_listener!(
      webview_window,
      WEBVIEW_WINDOW_LISTEN_ID,
      WEBVIEW_WINDOW_LISTEN_ANY_ID
    );

    EventSetup {
      app,
      window,
      webview,
      webview_window,
      tx,
      rx,
    }
  }

  fn assert_events(kind: &str, received: &[&str], expected: &[&str]) {
    for e in expected {
      assert!(received.contains(e), "{e} did not receive `{kind}` event");
    }
    assert_eq!(
      received.len(),
      expected.len(),
      "received {received:?} `{kind}` events but expected {expected:?}"
    );
  }
```

--------------------------------

### Unlisten to Window Events (Rust Example)

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Removes a previously registered event listener using its `EventId`. This prevents the handler from being called again. The example demonstrates how to unlisten within a Tauri application setup, typically after the event has served its purpose or if it's no longer needed.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let window = app.get_window("main").unwrap();
    let window_ = window.clone();
    let handler = window.listen("component-loaded", move |event| {
      println!("window just loaded a component");
      window_.unlisten(event.id());
    });

    window.unlisten(handler);

    Ok(())
  });
```

--------------------------------

### Window Creation

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

Create new windows or webviews.

```APIDOC
## POST /window/create_window

### Description
Creates a new window.

### Method
POST

### Endpoint
/window/create_window

### Parameters
#### Request Body
- **pending** (object) - Configuration for the pending window.
  - **url** (string) - The URL to load in the new window.
  - **title** (string) - The initial title of the window.
  - **width** (number) - The initial width of the window.
  - **height** (number) - The initial height of the window.
  - **center** (boolean) - Whether to center the window on creation.
  - **resizable** (boolean) - Whether the window should be resizable.
  - **fullscreen** (boolean) - Whether the window should start in fullscreen mode.
  - **maximizable** (boolean) - Whether the window should be maximizable.
  - **minimizable** (boolean) - Whether the window should be minimizable.
  - **closable** (boolean) - Whether the window should be closable.
  - **alwaysOnTop** (boolean) - Whether the window should be always on top.
  - **decorations** (boolean) - Whether the window should have native decorations.
  - **shadow** (boolean) - Whether the window should have a shadow.
  - **transparent** (boolean) - Whether the window should be transparent.
  - **focus** (boolean) - Whether the window should take focus on creation.
  - **visible** (boolean) - Whether the window should be visible on creation.
  - **hidden** (boolean) - Whether the window should be hidden on creation.
  - **skipTaskbar** (boolean) - Whether the window should be excluded from the taskbar.
  - **titleBarStyle** (string) - The style of the title bar ('transparent', 'overlay').
  - **theme** (string) - The theme of the window ('light', 'dark').
  - **userAgent** (string) - Custom user agent string.
  - **acceptFirstMouse** (boolean) - Whether to accept the first mouse click.
  - **windowBuilder** (object) - Additional platform-specific builder options.
- **afterWindowCreation** (function | null) - A callback function to execute after the window is created.

### Response
#### Success Response (200)
- **windowId** (string) - The unique identifier of the newly created window.

#### Response Example
```json
{
  "windowId": "window-123"
}
```
```

```APIDOC
## POST /window/create_webview

### Description
Creates a new webview.

### Method
POST

### Endpoint
/window/create_webview

### Parameters
#### Request Body
- **pending** (object) - Configuration for the pending webview.
  - **url** (string) - The URL to load in the webview.
  - **title** (string) - The initial title of the webview window.
  - **width** (number) - The initial width of the webview window.
  - **height** (number) - The initial height of the webview window.
  - **center** (boolean) - Whether to center the webview window on creation.
  - **resizable** (boolean) - Whether the webview window should be resizable.
  - **fullscreen** (boolean) - Whether the webview window should start in fullscreen mode.
  - **maximizable** (boolean) - Whether the webview window should be maximizable.
  - **minimizable** (boolean) - Whether the webview window should be minimizable.
  - **closable** (boolean) - Whether the webview window should be closable.
  - **alwaysOnTop** (boolean) - Whether the webview window should be always on top.
  - **decorations** (boolean) - Whether the webview window should have native decorations.
  - **shadow** (boolean) - Whether the webview window should have a shadow.
  - **transparent** (boolean) - Whether the webview window should be transparent.
  - **focus** (boolean) - Whether the webview window should take focus on creation.
  - **visible** (boolean) - Whether the webview window should be visible on creation.
  - **hidden** (boolean) - Whether the webview window should be hidden on creation.
  - **skipTaskbar** (boolean) - Whether the webview window should be excluded from the taskbar.
  - **titleBarStyle** (string) - The style of the title bar ('transparent', 'overlay').
  - **theme** (string) - The theme of the webview window ('light', 'dark').
  - **userAgent** (string) - Custom user agent string.
  - **acceptFirstMouse** (boolean) - Whether to accept the first mouse click.
  - **windowBuilder** (object) - Additional platform-specific builder options.

### Response
#### Success Response (200)
- **webviewId** (string) - The unique identifier of the newly created webview.

#### Response Example
```json
{
  "webviewId": "webview-abc"
}
```
```

--------------------------------

### Webview Install Mode Enum

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Specifies the installation modes for the Webview2 runtime. Options include skipping installation, downloading or embedding the bootstrapper, using an offline installer, or embedding a fixed runtime.

```rust
/// Install modes for the Webview2 runtime.
/// Note that for the updater bundle [`Self::DownloadBootstrapper`] is used.
///
/// For more information see <https://tauri.app/v1/guides/building/windows>.
#[derive(Debug, PartialEq, Eq, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
pub enum WebviewInstallMode {
  /// Do not install the Webview2 as part of the Windows Installer.
  Skip,
  /// Download the bootstrapper and run it.
  /// Requires an internet connection.
  /// Results in a smaller installer size, but is not recommended on Windows 7.
  DownloadBootstrapper {
    /// Instructs the installer to run the bootstrapper in silent mode. Defaults to `true`.
    #[serde(default = "default_true")]
    silent: bool,
  },
  /// Embed the bootstrapper and run it.
  /// Requires an internet connection.
  /// Increases the installer size by around 1.8MB, but offers better support on Windows 7.
  EmbedBootstrapper {
    /// Instructs the installer to run the bootstrapper in silent mode. Defaults to `true`.
    #[serde(default = "default_true")]
    silent: bool,
  },
  /// Embed the offline installer and run it.
  /// Does not require an internet connection.
  /// Increases the installer size by around 127MB.
  OfflineInstaller {
    /// Instructs the installer to run the installer in silent mode. Defaults to `true`.
    #[serde(default = "default_true")]
    silent: bool,
  },
  /// Embed a fixed webview2 version and use it at runtime.
  /// Increases the installer size by around 180MB.
  FixedRuntime {
    /// The path to the fixed runtime to use.
    ///
    /// The fixed version can be downloaded [on the official website](https://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section).
    /// The `.cab` file must be extracted to a folder and this folder path must be defined on this field.
    path: PathBuf,
  },
}

impl Default for WebviewInstallMode {
  fn default() -> Self {
    Self::DownloadBootstrapper { silent: true }
  }
}
```

--------------------------------

### Rust: Example of Unlistening to an Event in Tauri

Source: https://docs.rs/tauri/2.8.5/src/tauri/lib

Demonstrates how to remove an event listener using `unlisten`. The example shows obtaining a listener handle within the `setup` closure and then explicitly calling `unlisten` on that handle. This is useful for cleaning up listeners when they are no longer required, preventing potential issues.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let handle = app.handle().clone();
    let handler = app.listen_any("ready", move |event| {
      println!("app is ready");

      // we no longer need to listen to the event
      // we also could have used `app.once_global` instead
      handle.unlisten(event.id());
    });

    // stop listening to the event when you do not need it anymore
    app.unlisten(handler);

  });
```

--------------------------------

### Emit Event to Specific Target Example (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/lib

Example of emitting a 'download-progress' event to different targets. It demonstrates emitting to any target, the app itself, a labeled target ('updater'), and a specific webview window.

```rust
use tauri::{Emitter, EventTarget};

#[tauri::command]
fn download(app: tauri::AppHandle) {
  for i in 1..100 {
    std::thread::sleep(std::time::Duration::from_millis(150));
    // emit a download progress event to all listeners
    app.emit_to(EventTarget::any(), "download-progress", i);
    // emit an event to listeners that used App::listen or AppHandle::listen
    app.emit_to(EventTarget::app(), "download-progress", i);
    // emit an event to any webview/window/webviewWindow matching the given label
    app.emit_to("updater", "download-progress", i); // similar to using EventTarget::labeled
    app.emit_to(EventTarget::labeled("updater"), "download-progress", i);
    // emit an event to listeners that used WebviewWindow::listen
    app.emit_to(EventTarget::webview_window("updater"), "download-progress", i);
  }
}
```

--------------------------------

### Configure WebView2 Installation for Tauri Windows Installer

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

Manage how the WebView2 runtime is installed with your Tauri Windows application. Options include skipping installation, downloading the bootstrapper, embedding the bootstrapper, embedding the offline installer, or using a fixed runtime. Each method has implications for installer size and internet connection requirements. The 'silent' option controls whether the installation occurs without user interaction.

```Rust
pub enum WebviewInstallMode {
  Skip,
  DownloadBootstrapper { silent: bool },
  EmbedBootstrapper { silent: bool },
  OfflineInstaller { silent: bool },
  FixedRuntime { path: PathBuf },
}

impl Default for WebviewInstallMode {
  fn default() -> Self {
    Self::DownloadBootstrapper { silent: true }
  }
}
```

--------------------------------

### Rust: Tauri PathResolver Parse Method Example

Source: https://docs.rs/tauri/2.8.5/src/tauri/path/mod

Illustrates the `parse` method of Tauri's `PathResolver` in Rust. This method parses a given path, automatically resolving any `BaseDirectory` variables (like `$HOME`) it contains into their absolute path equivalents. The example is shown within a Tauri app setup.

```rust
use tauri::Manager;
tauri::Builder::default()
  .setup(|app| {
    let path = app.path().parse("$HOME/.bashrc")?;
    assert_eq!(path.to_str().unwrap(), "/home/${whoami}/.bashrc");
    Ok(())
  });
```

--------------------------------

### WebviewBuilder::new Initialization (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Shows the basic initialization of a `WebviewBuilder` with a label and a `WebviewUrl`. This is the fundamental way to start creating a new webview instance.

```rust
pub fn new<L: Into<String>>(label: L, url: WebviewUrl) -> Self {
  Self {
    label: label.into(),
    webview_attributes: WebviewAttributes::new(url),
    web_resource_request_handler: None,
    navigation_handler: None,
    new_window_handler: None,
    on_page_load_handler: None,
    document_title_changed_handler: None,
    download_handler: None,
  }
}
```

--------------------------------

### Setup Plugin

Source: https://docs.rs/tauri/latest/src/tauri/plugin

Defines a closure that is executed when the plugin is registered with the Tauri application. This is typically used for initializing plugin state, registering commands, or performing other setup tasks.

```APIDOC
## POST /websites/rs-tauri/setup

### Description
Sets a closure to be executed when the plugin is registered. This is useful for initializing plugin state or resources.

### Method
POST

### Endpoint
`/websites/rs-tauri/setup`

### Parameters
#### Request Body
- **setup** (function) - Required - The closure to execute during plugin setup. It receives the `AppHandle` and `PluginApi`.

### Request Example
```json
{
  "setup": "(app, api) => { console.log('Plugin setup called'); return Ok(()); }"
}
```

### Response
#### Success Response (200)
- **Self** (object) - Returns the builder instance for chaining.

#### Response Example
```json
{
  "message": "Builder instance returned"
}
```
```

--------------------------------

### Tauri Runtime Initialization

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

This snippet details the arguments and methods for initializing the Tauri runtime. `RuntimeInitArgs` allows configuration of the runtime, including platform-specific options like `app_id` for Linux-based systems or `msg_hook` for Windows. The `new` and `new_any_thread` methods are the primary entry points for creating a new runtime instance, with `new_any_thread` providing flexibility for non-main thread initialization on supported platforms.

```rust
pub struct RuntimeInitArgs {
  #[cfg(any(
    target_os = "linux",
    target_os = "dragonfly",
    target_os = "freebsd",
    target_os = "netbsd",
    target_os = "openbsd"
  ))]
  pub app_id: Option<String>,
  #[cfg(windows)]
  pub msg_hook: Option<Box<dyn FnMut(*const std::ffi::c_void) -> bool + 'static>>,
}

/// Creates a new webview runtime. Must be used on the main thread.
fn new(args: RuntimeInitArgs) -> Result<Self>;

/// Creates a new webview runtime on any thread.
#[cfg(any(windows, target_os = "linux"))]
#[cfg_attr(docsrs, doc(cfg(any(windows, target_os = "linux"))))]
fn new_any_thread(args: RuntimeInitArgs) -> Result<Self>;
```

--------------------------------

### Setup Callback API

Source: https://docs.rs/tauri/2.8.4/src/tauri/plugin

Define a closure that runs when the plugin is registered.

```APIDOC
## POST /websites/rs-tauri/setup

### Description
Registers a closure to be executed when the plugin is initialized within the Tauri application. This is typically used for managing plugin state or performing initial setup tasks.

### Method
POST

### Endpoint
/websites/rs-tauri/setup

### Parameters
#### Request Body
- **setup** (function) - Required - A function that takes `AppHandle<R>` and `PluginApi<R, C>` as arguments and returns a `Result<(), Box<dyn std::error::Error>>`.
```

--------------------------------

### Window State and Information

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

APIs to get the current state and information about the window.

```APIDOC
## GET /window/enabled

### Description
Checks if the window is currently enabled.

### Method
GET

### Endpoint
/window/enabled

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **enabled** (boolean) - True if the window is enabled, false otherwise.

#### Response Example
```json
{
  "enabled": true
}
```

## GET /window/always_on_top

### Description
Gets the window's always on top flag state. Note: Unsupported on iOS/Android.

### Method
GET

### Endpoint
/window/always_on_top

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **always_on_top** (boolean) - The state of the always on top flag.

#### Response Example
```json
{
  "always_on_top": false
}
```

## GET /window/title

### Description
Retrieves the current title of the window.

### Method
GET

### Endpoint
/window/title

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **title** (string) - The current window title.

#### Response Example
```json
{
  "title": "My Application"
}
```

## GET /window/current_monitor

### Description
Returns the monitor on which the window currently resides. Returns None if the monitor cannot be detected.

### Method
GET

### Endpoint
/window/current_monitor

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **monitor** (object | null) - Information about the current monitor, or null if not detectable.

#### Response Example
```json
{
  "monitor": {
    "name": "Display 1",
    "scale_factor": 1.5,
    "position": {"x": 0, "y": 0},
    "size": {"width": 1920, "height": 1080},
    "current_dpi": null
  }
}
```

## GET /window/primary_monitor

### Description
Returns the primary monitor of the system. Returns None if a primary monitor cannot be identified.

### Method
GET

### Endpoint
/window/primary_monitor

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **monitor** (object | null) - Information about the primary monitor, or null if not found.

#### Response Example
```json
{
  "monitor": {
    "name": "Display 1",
    "scale_factor": 1.5,
    "position": {"x": 0, "y": 0},
    "size": {"width": 1920, "height": 1080},
    "current_dpi": null
  }
}
```

## GET /window/monitor_from_point

### Description
Returns the monitor that contains the given point.

### Method
GET

### Endpoint
/window/monitor_from_point

### Parameters
#### Query Parameters
- **x** (number) - The x-coordinate of the point.
- **y** (number) - The y-coordinate of the point.

### Request Example
None

### Response
#### Success Response (200)
- **monitor** (object | null) - Information about the monitor containing the point, or null if no monitor contains the point.

#### Response Example
```json
{
  "monitor": {
    "name": "Display 2",
    "scale_factor": 1.2,
    "position": {"x": 1920, "y": 0},
    "size": {"width": 1600, "height": 900},
    "current_dpi": null
  }
}
```

## GET /window/available_monitors

### Description
Returns a list of all available monitors on the system.

### Method
GET

### Endpoint
/window/available_monitors

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **monitors** (array) - An array of monitor objects.

#### Response Example
```json
[
  {
    "name": "Display 1",
    "scale_factor": 1.5,
    "position": {"x": 0, "y": 0},
    "size": {"width": 1920, "height": 1080},
    "current_dpi": null
  },
  {
    "name": "Display 2",
    "scale_factor": 1.2,
    "position": {"x": 1920, "y": 0},
    "size": {"width": 1600, "height": 900},
    "current_dpi": null
  }
]
```

## GET /window/handle

### Description
Retrieves the raw window handle. Use with caution as this is platform-dependent.

### Method
GET

### Endpoint
/window/handle

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **handle** (object) - The raw window handle.

#### Response Example
```json
{
  "handle": {
    "data": "0x1234567890abcdef",
    "type": "xcb_window_t"
  }
}
```

## GET /window/theme

### Description
Gets the current theme of the window.

### Method
GET

### Endpoint
/window/theme

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **theme** (string) - The current theme (e.g., "light", "dark").

#### Response Example
```json
{
  "theme": "dark"
}
```
```

--------------------------------

### Get Constant Pointer from Box in Rust

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/tauri_runtime_wry/type

Demonstrates how to get a raw constant pointer from a Box and interact with a mutable pointer, showcasing aliasing rules.  Shows that writes via a mutable pointer invalidate previously obtained constant pointers. This example requires the `box_as_ptr` feature.

```rust
#![feature(box_as_ptr)]

unsafe {
    let mut v = Box::new(0);
    let ptr1 = Box::as_ptr(&v);
    let ptr2 = Box::as_mut_ptr(&mut v);
    let _val = ptr2.read();
    // No write to this memory has happened yet, so `ptr1` is still valid.
    let _val = ptr1.read();
    // However, once we do a write...
    ptr2.write(1);
    // ... `ptr1` is no longer valid.
    // This would be UB: let _val = ptr1.read();
}
```

--------------------------------

### Create and Manage Tauri Windows

Source: https://context7.com/context7/rs-tauri/llms.txt

Demonstrates creating new windows with customizable properties like title, size, and resizability using `WebviewWindowBuilder`. It also shows how to manipulate existing windows (e.g., set title, size, get position) and list all currently open windows. This functionality is crucial for building complex user interfaces in Tauri applications.

```rust
use tauri::{Manager, Size, PhysicalSize, WindowEvent, AppHandle, Window};

#[tauri::command]
async fn create_settings_window(app: AppHandle) -> Result<(), String> {
    if app.get_webview_window("settings").is_some() {
        return Err("Settings window already exists".to_string());
    }

    let window = tauri::WebviewWindowBuilder::new(
        &app,
        "settings",
        tauri::WebviewUrl::App("settings.html".into())
    )
    .title("Settings")
    .inner_size(600.0, 400.0)
    .min_inner_size(400.0, 300.0)
    .resizable(true)
    .center()
    .build()
    .map_err(|e| e.to_string())?;

    // Listen to window events
    window.on_window_event(move |event| {
        if let WindowEvent::CloseRequested { api, .. } = event {
            println!("Settings window closing");
        }
    });

    Ok(())
}

#[tauri::command]
fn manipulate_window(window: Window) -> Result<String, String> {
    window.set_title("New Title").map_err(|e| e.to_string())?;
    window.set_size(Size::Physical(PhysicalSize {
        width: 800,
        height: 600,
    })).map_err(|e| e.to_string())?;

    let position = window.outer_position().map_err(|e| e.to_string())?;
    Ok(format!("Window at position: {:?}", position))
}

#[tauri::command]
fn list_windows(app: AppHandle) -> Vec<String> {
    app.webview_windows()
        .into_iter()
        .map(|(label, _)| label)
        .collect()
}

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            create_settings_window,
            manipulate_window,
            list_windows
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

--------------------------------

### Create Webview in Separate Thread (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Shows how to create a webview in a separate thread using `std::thread::spawn`. This approach is recommended to avoid deadlocks on Windows. It mirrors the setup hook example but executes within a new thread context.

```rust
tauri::Builder::default()
  .setup(|app| {
    let handle = app.handle().clone();
    std::thread::spawn(move || {
      let window = tauri::window::WindowBuilder::new(&handle, "label").build().unwrap();
      let webview_builder = tauri::webview::WebviewBuilder::new("label", tauri::WebviewUrl::App("index.html".into()));
      window.add_child(webview_builder, tauri::LogicalPosition::new(0, 0), window.inner_size().unwrap());
    });
    Ok(())
  });
```

--------------------------------

### Plugin Setup

Source: https://docs.rs/tauri/2.8.5/tauri/plugin/struct

Defines a closure that runs when the plugin is registered with the Tauri application.

```APIDOC
## POST /plugin/setup

### Description
Define a closure that runs when the plugin is registered.

### Method
POST

### Endpoint
/plugin/setup

### Parameters
#### Request Body
- **setup** (function) - Required - A closure that accepts `AppHandle` and `PluginApi` and returns a `Result`.

### Request Example
```json
{
  "setup": "function(app, api) { ... }"
}
```

### Response
#### Success Response (200)
- **message** (string) - Indicates successful registration.

#### Response Example
```json
{
  "message": "Plugin setup complete."
}
```
```

--------------------------------

### Tauri Application Setup and Event Handling Callback

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

The `make_run_event_loop_callback` function creates a closure that processes runtime events for the Tauri application. It manages application setup, handles ready and exit events, and calls the provided user callback for event processing. It also includes logic for restarting the application.

```rust
fn make_run_event_loop_callback<F: FnMut(&AppHandle<R>, RunEvent) + 'static>(
  mut self,
  mut callback: F,
) -> impl FnMut(RuntimeRunEvent<EventLoopMessage>) {
  let app_handle = self.handle().clone();
  let manager = self.manager.clone();

  move |event| match event {
    RuntimeRunEvent::Ready => {
      if let Err(e) = setup(&mut self) {
        panic!("Failed to setup app: {e}");
      }
      let event = on_event_loop_event(&app_handle, RuntimeRunEvent::Ready, &manager);
      callback(&app_handle, event);
    }
    RuntimeRunEvent::Exit => {
      let event = on_event_loop_event(&app_handle, RuntimeRunEvent::Exit, &manager);
      callback(&app_handle, event);
      app_handle.cleanup_before_exit();
      if self.manager.restart_on_exit.load(atomic::Ordering::Relaxed) {
        crate::process::restart(&self.env());
      }
    }
    _ => {
      let event = on_event_loop_event(&app_handle, event, &manager);
      callback(&app_handle, event);
    }
  }
}
```

--------------------------------

### WebView2 Install Modes Configuration (Rust)

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Defines different strategies for installing the WebView2 runtime during the Tauri Windows installer process. Options range from skipping installation to embedding offline installers, with configurable silent modes. The default is to download the bootstrapper silently.

```rust
/// Install modes for the Webview2 runtime.
/// Note that for the updater bundle [`Self::DownloadBootstrapper`] is used.
///
/// For more information see <https://v2.tauri.app/distribute/windows-installer/#webview2-installation-options>.
#[derive(Debug, PartialEq, Eq, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub enum WebviewInstallMode {
  /// Do not install the Webview2 as part of the Windows Installer.
  Skip,
  /// Download the bootstrapper and run it.
  /// Requires an internet connection.
  /// Results in a smaller installer size, but is not recommended on Windows 7.
  DownloadBootstrapper {
    /// Instructs the installer to run the bootstrapper in silent mode. Defaults to `true`.
    #[serde(default = "default_true")]
    silent: bool,
  },
  /// Embed the bootstrapper and run it.
  /// Requires an internet connection.
  /// Increases the installer size by around 1.8MB, but offers better support on Windows 7.
  EmbedBootstrapper {
    /// Instructs the installer to run the bootstrapper in silent mode. Defaults to `true`.
    #[serde(default = "default_true")]
    silent: bool,
  },
  /// Embed the offline installer and run it.
  /// Does not require an internet connection.
  /// Increases the installer size by around 127MB.
  OfflineInstaller {
    /// Instructs the installer to run the installer in silent mode. Defaults to `true`.
    #[serde(default = "default_true")]
    silent: bool,
  },
  /// Embed a fixed webview2 version and use it at runtime.
  /// Increases the installer size by around 180MB.
  FixedRuntime {
    /// The path to the fixed runtime to use.
    ///
    /// The fixed version can be downloaded [on the official website](https://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section).
    /// The `.cab` file must be extracted to a folder and this folder path must be defined on this field.
    path: PathBuf,
  },
}

impl Default for WebviewInstallMode {
  fn default() -> Self {
    Self::DownloadBootstrapper { silent: true }
  }
}
```

--------------------------------

### WiX Installer Configuration Options

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Configures the WiX installer for Windows applications. Supports specifying installer languages, custom WXS templates and fragments, component/feature/merge references, and custom UI assets like banners and dialog images. It also includes options to control Webview2 installation and elevated update tasks.

```rust
/// The installer languages to build. See <https://docs.microsoft.com/en-us/windows/win32/msi/localizing-the-error-and-actiontext-tables>.
#[serde(default)]
pub language: WixLanguage,
/// A custom .wxs template to use.
pub template: Option<PathBuf>,
/// A list of paths to .wxs files with WiX fragments to use.
#[serde(default, alias = "fragment-paths")]
pub fragment_paths: Vec<PathBuf>,
/// The ComponentGroup element ids you want to reference from the fragments.
#[serde(default, alias = "component-group-refs")]
pub component_group_refs: Vec<String>,
/// The Component element ids you want to reference from the fragments.
#[serde(default, alias = "component-refs")]
pub component_refs: Vec<String>,
/// The FeatureGroup element ids you want to reference from the fragments.
#[serde(default, alias = "feature-group-refs")]
pub feature_group_refs: Vec<String>,
/// The Feature element ids you want to reference from the fragments.
#[serde(default, alias = "feature-refs")]
pub feature_refs: Vec<String>,
/// The Merge element ids you want to reference from the fragments.
#[serde(default, alias = "merge-refs")]
pub merge_refs: Vec<String>,
/// Disables the Webview2 runtime installation after app install.
///
/// Will be removed in v2, prefer the [`WindowsConfig::webview_install_mode`] option.
#[serde(default, alias = "skip-webview-install")]
pub skip_webview_install: bool,
/// The path to the license file to render on the installer.
///
/// Must be an RTF file, so if a different extension is provided, we convert it to the RTF format.
pub license: Option<PathBuf>,
/// Create an elevated update task within Windows Task Scheduler.
#[serde(default, alias = "enable-elevated-update-task")]
pub enable_elevated_update_task: bool,
/// Path to a bitmap file to use as the installation user interface banner.
/// This bitmap will appear at the top of all but the first page of the installer.
///
/// The required dimensions are 493px  58px.
#[serde(alias = "banner-path")]
pub banner_path: Option<PathBuf>,
/// Path to a bitmap file to use on the installation user interface dialogs.
/// It is used on the welcome and completion dialogs.
///
/// The required dimensions are 493px  312px.
#[serde(alias = "dialog-image-path")]
pub dialog_image_path: Option<PathBuf>
```

--------------------------------

### Example: Set UI Language and Compile Resource (Rust)

Source: https://docs.rs/tauri/-winres/0.3.3/tauri_winres/struct

A practical example demonstrating how to set the language for a `WindowsResource` and then compile it, specifically for Windows targets. It uses constants from the `winapi` crate.

```Rust
fn main() {
  if cfg!(target_os = "windows") {
    let mut res = tauri_winres::WindowsResource::new();
    res.set_language(winapi::um::winnt::MAKELANGID(
        winapi::um::winnt::LANG_ENGLISH,
        winapi::um::winnt::SUBLANG_ENGLISH_US
    ));
    res.compile().unwrap();
  }
}

```

--------------------------------

### Rust: Manually Create Box from Scratch with System Allocator

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/tauri_runtime_wry/type

Shows how to manually construct a Box<T> from scratch using the system allocator. This involves allocating memory with a specific layout and then creating the Box using `Box::from_raw_in`. Requires `allocator_api` and `slice_ptr_get` features.

```rust
#![feature(allocator_api, slice_ptr_get)]

use std::alloc::{Allocator, Layout, System};

unsafe {
    let ptr = System.allocate(Layout::new::<i32>())?.as_mut_ptr() as *mut i32;
    // In general .write is required to avoid attempting to destruct
    // the (uninitialized) previous contents of `ptr`, though for this
    // simple example `*ptr = 5` would have worked as well.
    ptr.write(5);
    let x = Box::from_raw_in(ptr, System);
}
```

--------------------------------

### Rust: Set and Get Window Theme and Background Color

Source: https://docs.rs/tauri/latest/src/tauri/test/mock_runtime

Methods to set the window's theme (light/dark) and background color. `get_theme` retrieves the current theme, while `theme` and `background_color` apply settings.

```rust
fn theme(self, theme: Option<Theme>) -> Self {
    self
  }

  fn has_icon(&self) -> bool {
    false
  }

  fn get_theme(&self) -> Option<Theme> {
    None
  }

  fn background_color(self, _color: tauri_utils::config::Color) -> Self {
    self
  }
```

--------------------------------

### Tauri PluginStore: Initialize Plugins

Source: https://docs.rs/tauri/2.8.4/src/tauri/plugin

Functions to initialize individual plugins or all plugins within the store. Initialization involves passing the application handle and configuration to each plugin.

```rust
pub(crate) fn initialize(
    &self,
    plugin: &mut Box<dyn Plugin<R>>,
    app: &AppHandle<R>,
    config: &PluginConfig,
) -> crate::Result<()> {
    initialize(plugin, app, config)
}

pub(crate) fn initialize_all(
    &mut self,
    app: &AppHandle<R>,
    config: &PluginConfig,
) -> crate::Result<()> {
    self
      .store
      .iter_mut()
      .try_for_each(|plugin| initialize(plugin, app, config))
}
```

--------------------------------

### Start Window Dragging (Tauri/Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/mod

This function starts dragging the window.  It does not require any input. The function returns a `crate::Result<()>` indicating success or failure.

```Rust
pub fn start_dragging(&self) -> crate::Result<()> {
    self.window.dispatcher.start_dragging().map_err(Into::into)
  }
```

--------------------------------

### Run Tauri Application Event Loop

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Starts the Tauri application's event loop. This function is blocking and never returns. It takes a callback function that is executed on various application events, such as `ExitRequested`. Panics if the setup function fails.

```rust
pub fn run<F: FnMut(&AppHandle<R>, RunEvent) + 'static>(mut self, callback: F) {
  self.handle.event_loop.lock().unwrap().main_thread_id = std::thread::current().id();

  self
    .runtime
    .take()
    .unwrap()
    .run(self.make_run_event_loop_callback(callback));
}
```

--------------------------------

### Add Tauri Plugin

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Adds a Tauri application plugin to the builder. Plugins can extend the application's functionality, offering custom commands, event handlers, and setup logic. The example demonstrates creating and initializing a simple plugin with commands and event listeners.

```rust
/// Adds a Tauri application plugin.
///
/// A plugin is created using the [`crate::plugin::Builder`] struct.Check its documentation for more information.
///
/// # Examples
///
/// ```
/// mod plugin {
///   use tauri::{plugin::{Builder as PluginBuilder, TauriPlugin}, RunEvent, Runtime};
///
///   // this command can be called in the frontend using `invoke('plugin:window|do_something')`.
///   #[tauri::command]
///   async fn do_something<R: Runtime>(app: tauri::AppHandle<R>, window: tauri::Window<R>) -> Result<(), String> {
///     println!("command called");
///     Ok(())
///   }
///   pub fn init<R: Runtime>() -> TauriPlugin<R> {
///     PluginBuilder::new("window")
///       .setup(|app, api| {
///         // initialize the plugin here
///         Ok(())
///       })
///       .on_event(|app, event| {
///         match event {
///           RunEvent::Ready => {
///             println!("app is ready");
///           }
///           RunEvent::WindowEvent { label, event, .. } => {
///             println!("window {} received an event: {:?}", label, event);
///           }
///           _ => (),
///         }
///       })
///       .invoke_handler(tauri::generate_handler![do_something])
///       .build()
///   }
/// }
///
/// tauri::Builder::default()
///   .plugin(plugin::init());
/// ```
#[must_use]
pub fn plugin<P: Plugin<R> + 'static>(self, plugin: P) -> Self {
  self.plugin_boxed(Box::new(plugin))
}

/// Adds a Tauri application plugin.
///
/// This method is similar to [`Self::plugin`],
/// but accepts a boxed trait object instead of a generic type.
#[must_use]
pub fn plugin_boxed(mut self, plugin: Box<dyn Plugin<R>>) -> Self {
  self.plugins.register(plugin);
  self
}
```

--------------------------------

### Tauri Runtime API - Window and Monitor Management

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

Provides methods for creating and managing windows and webviews, as well as retrieving information about system monitors and cursor position. These functions are essential for setting up the application's user interface and its interaction with the display environment.

```rust
/// Returns the primary monitor of the system.
///
/// Returns None if it can't identify any monitor as a primary one.
fn primary_monitor(&self) -> Option<Monitor>;

/// Returns the monitor that contains the given point.
fn monitor_from_point(&self, x: f64, y: f64) -> Option<Monitor>;

/// Returns the list of all the monitors available on the system.
fn available_monitors(&self) -> Vec<Monitor>;

/// Get the cursor position relative to the top-left hand corner of the desktop.
fn cursor_position(&self) -> Result<PhysicalPosition<f64>>;

/// Create a new webview.
fn create_webview(
    &self,
    window_id: WindowId,
    pending: PendingWebview<T, Self>,
  ) -> Result<DetachedWebview<T, Self>>;
```

--------------------------------

### Get Cursor Position (Rust)

Source: https://docs.rs/tauri/2.8.4/x86_64-unknown-linux-gnu/tauri/app/struct

Retrieves the current position of the mouse cursor relative to the top-left corner of the virtual desktop. Handles multi-monitor setups correctly. Coordinates can be negative.

```rust
pub fn cursor_position(&self) -> Result<PhysicalPosition<f64>>
```

--------------------------------

### Get Cursor Position

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Retrieves the cursor's position relative to the top-left corner of the desktop. This accounts for multi-monitor setups. Coordinates can be negative if the window is outside the visible screen region.

```rust
pub fn cursor_position(&self) -> crate::Result<PhysicalPosition<f64>> {
  self.app_handle.cursor_position()
}
```

--------------------------------

### Initialize Tauri Plugin FS

Source: https://docs.rs/tauri/-plugin-fs/2.4.2/index

This function initializes the Tauri file system plugin. It is typically called during the Tauri application setup to enable file system operations within your application. No specific inputs or outputs are detailed here, but it's a crucial setup step.

```rust
pub fn init<R: Runtime>() -> TauriPlugin<R>
where
    R::Environment: EnvWindow,
```

--------------------------------

### WebviewBuilder::from_config

Source: https://docs.rs/tauri/latest/src/tauri/webview/mod

Initializes a webview builder from a WindowConfig, typically loaded from tauri.conf.json. It warns about potential label conflicts and provides an example for use within a command.

```APIDOC
## WebviewBuilder::from_config

### Description
Initializes a webview builder from a [`WindowConfig`] from tauri.conf.json. It ensures that unique labels are used for each webview.

### Method
`from_config`

### Endpoint
N/A (Constructor)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
None

### Request Example
```rust
let webview_builder = tauri::webview::WebviewBuilder::from_config(&app.config().app.windows.get(0).unwrap().clone());
```

### Response
#### Success Response (200)
N/A (Constructor)

#### Response Example
N/A (Constructor)
```

--------------------------------

### NSIS Installer Configuration

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Configuration for the NSIS installer, allowing for language selection, custom language files, and control over the display of the language selector dialog. It also includes options for compression algorithms and installer modes.

```rust
/// To allow the user to select the language, set `display_language_selector` to `true`.
///
/// See <https://github.com/kichik/nsis/tree/9465c08046f00ccb6eda985abbdbf52c275c6c4d/Contrib/Language%20files> for the complete list of languages.
pub languages: Option<Vec<String>>,
/// A key-value pair where the key is the language and the
/// value is the path to a custom `.nsh` file that holds the translated text for tauri's custom messages.
///
/// See <https://github.com/tauri-apps/tauri/blob/dev/tooling/bundler/src/bundle/windows/templates/nsis-languages/English.nsh> for an example `.nsh` file.
///
/// **Note**: the key must be a valid NSIS language and it must be added to [`NsisConfig`] languages array,
pub custom_language_files: Option<HashMap<String, PathBuf>>,
/// Whether to display a language selector dialog before the installer and uninstaller windows are rendered or not.
/// By default the OS language is selected, with a fallback to the first language in the `languages` array.
#[serde(default, alias = "display-language-selector")]
pub display_language_selector: bool,
/// Set the compression algorithm used to compress files in the installer.
///
/// See <https://nsis.sourceforge.net/Reference/SetCompressor>
pub compression: Option<NsisCompression>,
```

--------------------------------

### Rust: Get Scale Factor of Wry Window

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

Retrieves the current scale factor of the Wry window. This is useful for high-DPI displays or multi-monitor setups. It returns a `Result<f64>`.

```rust
fn scale_factor(&self) -> Result<f64>
{
    window_getter!(self, WindowMessage::ScaleFactor)
}
```

--------------------------------

### WiX Installer Configuration

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Configuration for the WiX installer, including language settings and overall WiX bundle configuration.

```APIDOC
## WixLanguageConfig

### Description
Configuration for a target language for the WiX build.

### Method
N/A (Configuration Structure)

### Endpoint
N/A (Configuration Structure)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **locale_path** (Option<String>) - The path to a locale (`.wxl`) file.

### Request Example
```json
{
  "locale_path": "/path/to/locale.wxl"
}
```

### Response
#### Success Response (200)
N/A (Configuration Structure)

#### Response Example
```json
{
  "locale_path": "/path/to/locale.wxl"
}
```

## WixLanguage

### Description
The languages to build using WiX.

### Method
N/A (Configuration Structure)

### Endpoint
N/A (Configuration Structure)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
This field can be one of the following types:
- **One** (String) - A single language to build, without configuration.
- **List** (Vec<String>) - A list of languages to build, without configuration.
- **Localized** (HashMap<String, WixLanguageConfig>) - A map of languages and its configuration.

### Request Example
```json
"en-US"
```
Or
```json
["en-US", "fr-FR"]
```
Or
```json
{
  "en-US": {"locale_path": "/path/to/en-US.wxl"},
  "fr-FR": {"locale_path": "/path/to/fr-FR.wxl"}
}
```

### Response
#### Success Response (200)
N/A (Configuration Structure)

#### Response Example
```json
"en-US"
```

## WixConfig

### Description
Configuration for the MSI bundle using WiX.

### Method
N/A (Configuration Structure)

### Endpoint
N/A (Configuration Structure)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
(This structure contains fields related to WiX configuration, including language settings. Specific fields would be detailed in a complete schema.)

### Request Example
```json
{
  "languages": "en-US",
  "enabled": true
}
```

### Response
#### Success Response (200)
N/A (Configuration Structure)

#### Response Example
```json
{
  "languages": "en-US",
  "enabled": true
}
```
```

--------------------------------

### Listen Once to Window Events (Rust Example)

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/mod

Listens for a specific event on a window, but only executes the handler once. After the event is received and the handler is executed, the listener is automatically removed. This is useful for one-time confirmations or setup steps. Requires the 'unstable' feature.

```rust
use tauri::{Manager, Listener);

tauri::Builder::default()
  .setup(|app| {
    let window = app.get_window("main").unwrap();
    let window_ = window.clone();
    let handler = window.listen("component-loaded", move |event| {
      println!("window just loaded a component");

      // we no longer need to listen to the event
      // we also could have used `window.once` instead
      window_.unlisten(event.id());
    });

    // stop listening to the event when you do not need it anymore
    window.unlisten(handler);

    Ok(())
  });
```

--------------------------------

### Builder Basic Initialization

Source: https://docs.rs/tauri/latest/tauri/plugin/struct

A basic example of initializing a Tauri plugin using the Builder pattern.

```APIDOC
## Builder `init` Function

### Description
This function initializes a Tauri plugin using a simple Builder configuration.

### Method
`init`

### Parameters
None

### Returns
`TauriPlugin<R>` - An initialized Tauri plugin.

### Example
```rust
use tauri::plugin::{Builder, TauriPlugin};
use tauri::Runtime;

pub fn init<R: Runtime>() -> TauriPlugin<R> {
  Builder::new("example")
    .build()
}
```
```

--------------------------------

### Example: Reading and Parsing JSON with anyhow::Result

Source: https://docs.rs/tauri/-build/2.4.1/tauri_build/type

Provides a practical example of using `anyhow::Result` in a `main` function to read a JSON configuration file, parse it into a `ClusterMap`, and print the result. The `?` operator is used for concise error propagation.

```rust
use anyhow::Result;

fn main() -> Result<()> {
    let config = std::fs::read_to_string("cluster.json")?;
    let map: ClusterMap = serde_json::from_str(&config)?;
    println!("cluster info: {:#?}", map);
    Ok(())
}
```

--------------------------------

### Example: Listening and Unlistening to Webview Events (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Demonstrates how to set up an event listener on a webview, perform an action, and then unlisten to the event using `unlisten` or by utilizing `once`.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let webview = app.get_webview("main").unwrap();
    let webview_ = webview.clone();
    let handler = webview.listen("component-loaded", move |event| {
      println!("webview just loaded a component");

      // we no longer need to listen to the event
      // we also could have used `webview.once` instead
      webview_.unlisten(event.id());
    });

    // stop listening to the event when you do not need it anymore
    webview.unlisten(handler);

    Ok(())
  });
```

--------------------------------

### Plugin Setup Callback

Source: https://docs.rs/tauri/2.8.5/src/tauri/plugin

Defines a closure that runs when the plugin is registered with the application.

```APIDOC
## POST /websites/rs-tauri/setup

### Description
Defines a closure that executes when the plugin is registered.

### Method
POST

### Endpoint
/websites/rs-tauri/setup

### Parameters
#### Request Body
- **setup** (function) - Required - The function to execute upon plugin registration. It receives the `AppHandle` and `PluginApi` and should return a `Result`.

### Request Example
```json
{
  "setup": "(app, api) => { app.manage(DefaultState::default()); Ok(()); }"
}
```

### Response
#### Success Response (200)
- **Self** (object) - Returns the updated builder instance.

#### Response Example
```json
{
  "message": "Setup callback configured successfully"
}
```
```

--------------------------------

### Get Default Parse Options

Source: https://docs.rs/tauri/latest/tauri/struct

Retrieves a default set of `ParseOptions` which can be used to configure the URL parser. These options can then be modified, for example, to set a base URL for subsequent parsing operations.

```rust
use url::Url;
let options = Url::options();
let api = Url::parse("https://api.example.com")?;
let base_url = options.base_url(Some(&api));
let version_url = base_url.parse("version.json")?;
assert_eq!(version_url.as_str(), "https://api.example.com/version.json");
```

--------------------------------

### Get URL Path

Source: https://docs.rs/tauri/latest/tauri/struct

Retrieves the path component of a URL. The path is returned as a percent-encoded ASCII string. For base URLs, it starts with '/'. Handles various URL formats, including those with special characters.

```rust
use url::{Url, ParseError};

let url = Url::parse("https://example.com/api/versions?page=2")?;
assert_eq!(url.path(), "/api/versions");

let url = Url::parse("https://example.com")?;
assert_eq!(url.path(), "/");

let url = Url::parse("https://example.com/countries/vit nam")?;
assert_eq!(url.path(), "/countries/vi%E1%BB%87t%20nam");
```

--------------------------------

### Get Mutable Pointer from Box in Rust

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/tauri_runtime_wry/type

Illustrates how to obtain a raw mutable pointer from a Box and safely write to the memory it points to.  Demonstrates the aliasing guarantees of `as_mut_ptr`. This example requires the `box_as_ptr` feature.

```rust
#![feature(box_as_ptr)]

unsafe {
    let mut b = Box::new(0);
    let ptr1 = Box::as_mut_ptr(&mut b);
    ptr1.write(1);
    let ptr2 = Box::as_mut_ptr(&mut b);
    ptr2.write(2);
    // Notably, the write to `ptr2` did *not* invalidate `ptr1`:
    ptr1.write(3);
}
```

--------------------------------

### Platform-Specific Webview Code Example (Linux, Windows, macOS, Android)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Demonstrates how to execute platform-specific code within a Tauri webview using the `with_webview` function. This example shows how to set zoom levels, manipulate user scripts, and set background colors based on the target operating system.

```rust
```rust,no_run
use tauri::Manager;

tauri::Builder::default()
  .setup(|app| {
    let main_webview = app.get_webview("main").unwrap();
    main_webview.with_webview(|webview| {
      #[cfg(target_os = "linux")]
      {
        // see <https://docs.rs/webkit2gtk/2.0.0/webkit2gtk/struct.WebView.html>
        // and <https://docs.rs/webkit2gtk/2.0.0/webkit2gtk/trait.WebViewExt.html>
        use webkit2gtk::WebViewExt;
        webview.inner().set_zoom_level(4.);
      }

      #[cfg(windows)]
      unsafe {
        // see https://docs.rs/webview2-com/0.19.1/webview2_com/Microsoft/Web/WebView2/Win32/struct.ICoreWebView2Controller.html
        webview.controller().SetZoomFactor(4.).unwrap();
      }

      #[cfg(target_os = "macos")]
      unsafe {
        let view: &objc2_web_kit::WKWebView = &*webview.inner().cast();
        let controller: &objc2_web_kit::WKUserContentController = &*webview.controller().cast();
        let window: &objc2_app_kit::NSWindow = &*webview.ns_window().cast();

        view.setPageZoom(4.);
        controller.removeAllUserScripts();
        let bg_color = objc2_app_kit::NSColor::colorWithDeviceRed_green_blue_alpha(0.5, 0.2, 0.4, 1.);
        window.setBackgroundColor(Some(&bg_color));
      }

      #[cfg(target_os = "android")]
      {
        use jni::objects::JValue;
        webview.jni_handle().exec(|env, _, webview| {
          env.call_method(webview, "zoomBy", "(F)V", &[JValue::Float(4.)]).unwrap();
        })
      }
    });
    Ok(())
});
```
```

--------------------------------

### Get Primary Monitor Information

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

Returns the primary monitor of the system. If a primary monitor cannot be identified, it returns `None`. This is useful for multi-monitor setups where one display is designated as the main one.

```rust
fn primary_monitor(&self) -> Option<Monitor>;
```

--------------------------------

### Get Available Monitors (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Retrieves a list of all available monitors connected to the system. It handles both the direct runtime and runtime handle interfaces, returning a vector of Monitor objects. This function is essential for multi-monitor setups.

```rust
pub fn available_monitors(&self) -> crate::Result<Vec<Monitor>> {
        Ok(match self.runtime() {
          RuntimeOrDispatch::Runtime(h) => {
            h.available_monitors().into_iter().map(Into::into).collect()
          }
          RuntimeOrDispatch::RuntimeHandle(h) => {
            h.available_monitors().into_iter().map(Into::into).collect()
          }
          _ => unreachable!(),
        })
      }
```

--------------------------------

### RuntimeInitArgs Structure

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

Arguments used for initializing the webview runtime, with platform-specific options.

```APIDOC
## RuntimeInitArgs Structure

### Description
`RuntimeInitArgs` holds configuration options for initializing the webview runtime. It includes platform-specific fields.

### Fields

*   **`app_id: Option<String>`**: The application ID. (Platform-specific: Linux and BSD variants)
*   **`msg_hook: Option<Box<dyn FnMut(*const std::ffi::c_void) -> bool + 'static>>`**: A message hook function that can intercept and process window messages. (Platform-specific: Windows)
```

--------------------------------

### Adding a Plugin to Tauri Application

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Adds a Tauri application plugin using a generic type that implements the `Plugin` trait. Plugins extend application functionality. The example shows how to initialize a plugin with setup, event handlers, and an invoke handler. Dependencies include `tauri::plugin::Builder`, `tauri::TauriPlugin`, and `tauri::Runtime`. The plugin is built and then added to the Tauri builder.

```rust
/// Adds a Tauri application plugin.
///
/// A plugin is created using the [`crate::plugin::Builder`] struct.Check its documentation for more information.
///
/// # Examples
///
/// ```
/// mod plugin {
///   use tauri::{plugin::{Builder as PluginBuilder, TauriPlugin}, RunEvent, Runtime};
///
///   // this command can be called in the frontend using `invoke('plugin:window|do_something')`.
///   #[tauri::command]
///   async fn do_something<R: Runtime>(app: tauri::AppHandle<R>, window: tauri::Window<R>) -> Result<(), String> {
///     println!("command called");
///     Ok(())
///   }
///   pub fn init<R: Runtime>() -> TauriPlugin<R> {
///     PluginBuilder::new("window")
///       .setup(|app, api| {
///         // initialize the plugin here
///         Ok(())
///       })
///       .on_event(|app, event| {
///         match event {
///           RunEvent::Ready => {
///             println!("app is ready");
///           }
///           RunEvent::WindowEvent { label, event, .. } => {
///             println!("window {} received an event: {:?}", label, event);
///           }
///           _ => (),
///         }
///       })
///       .invoke_handler(tauri::generate_handler![do_something])
///       .build()
///   }
/// }
///
/// tauri::Builder::default()
///   .plugin(plugin::init());
/// ```
#[must_use]
pub fn plugin<P: Plugin<R> + 'static>(self, plugin: P) -> Self {
  self.plugin_boxed(Box::new(plugin))
}
```

--------------------------------

### Rust Tauri AppManager Constructor

Source: https://docs.rs/tauri/2.8.5/src/tauri/manager/mod

The `with_handlers` function constructs and initializes an `AppManager` instance. It takes various context, plugin stores, handlers, event listeners, and configuration parameters to set up the application's core components, including window and webview management, with conditional setup for tray and menu on desktop.

```rust
impl<R: Runtime> AppManager<R> {
  #[allow(clippy::too_many_arguments, clippy::type_complexity)]
  pub(crate) fn with_handlers(
    #[allow(unused_mut)] mut context: Context<R>,
    plugins: PluginStore<R>,
    invoke_handler: Box<InvokeHandler<R>>,
    on_page_load: Option<Arc<OnPageLoad<R>> >,
    uri_scheme_protocols: HashMap<String, Arc<webview::UriSchemeProtocol<R>> >,
    state: StateManager,
    #[cfg(desktop)] menu_event_listener: Vec<crate::app::GlobalMenuEventListener<AppHandle<R>> >,
    #[cfg(all(desktop, feature = "tray-icon"))] tray_icon_event_listeners: Vec<
      crate::app::GlobalTrayIconEventListener<AppHandle<R>>,
    >,
    window_event_listeners: Vec<GlobalWindowEventListener<R>>,
    webiew_event_listeners: Vec<GlobalWebviewEventListener<R>>,
    #[cfg(desktop)] window_menu_event_listeners: HashMap<
      String,
      crate::app::GlobalMenuEventListener<Window<R>>,
    >,
    invoke_initialization_script: String,
    channel_interceptor: Option<ChannelInterceptor<R>>,
    invoke_key: String,
  ) -> Self {
    // generate a random isolation key at runtime
    #[cfg(feature = "isolation")]
    if let Pattern::Isolation { key, .. } = &mut context.pattern {
      *key = uuid::Uuid::new_v4().to_string();
    }

    Self {
      runtime_authority: Mutex::new(context.runtime_authority),
      window: window::WindowManager {
        windows: Mutex::default(),
        default_icon: context.default_window_icon,
        event_listeners: Arc::new(window_event_listeners),
      },
      webview: webview::WebviewManager {
        webviews: Mutex::default(),
        invoke_handler,
        on_page_load,
        uri_scheme_protocols: Mutex::new(uri_scheme_protocols),
        event_listeners: Arc::new(webiew_event_listeners),
        invoke_initialization_script,
        invoke_key: invoke_key.clone(),
      },
      #[cfg(all(desktop, feature = "tray-icon"))]
      tray: tray::TrayManager {
        icon: context.tray_icon,
        icons: Default::default(),
        global_event_listeners: Mutex::new(tray_icon_event_listeners),
        event_listeners: Default::default(),
      },
      #[cfg(desktop)]
      menu: menu::MenuManager {
        menus: Default::default(),
        menu: Default::default(),
        global_event_listeners: Mutex::new(menu_event_listener),
        event_listeners: Mutex::new(window_menu_event_listeners),
      },
    }
  }
}
```

--------------------------------

### Initialize Tauri Build Attributes

Source: https://docs.rs/tauri/-build/2.4.1/src/tauri_build/lib

Demonstrates how to create a new instance of `tauri_build::Attributes` to configure various aspects of the Tauri build process. This includes setting Windows-specific attributes, defining a glob pattern for capabilities, managing inlined plugins, and setting the application manifest. The `new()` function provides a default configuration.

```rust
let attrs = tauri_build::Attributes::new();
```

--------------------------------

### Get Cursor Position (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Fetches the current cursor position relative to the desktop's top-left corner. It accounts for multi-monitor setups and potential negative coordinates if the window is outside the visible screen.

```rust
pub fn cursor_position(&self) -> crate::Result<PhysicalPosition<f64>> {
836        Ok(match self.runtime() {
837          RuntimeOrDispatch::Runtime(h) => h.cursor_position()?,
838          RuntimeOrDispatch::RuntimeHandle(h) => h.cursor_position()?,
839          _ => unreachable!(),
840        })
841      }
```

--------------------------------

### Tauri Windows Build Configuration

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

Configures Windows-specific aspects of the Tauri build process. It includes settings for code signing (digest algorithm, certificate thumbprint, timestamp URL), installer generation (Wix, NSIS), and WebView2 runtime installation.

```rust
/// Windows bundler configuration.
///
/// See more: <https://v2.tauri.app/reference/config/#windowsconfig>
#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct WindowsConfig {
  /// Specifies the file digest algorithm to use for creating file signatures.
  /// Required for code signing. SHA-256 is recommended.
  #[serde(alias = "digest-algorithm")]
  pub digest_algorithm: Option<String>,
  /// Specifies the SHA1 hash of the signing certificate.
  #[serde(alias = "certificate-thumbprint")]
  pub certificate_thumbprint: Option<String>,
  /// Server to use during timestamping.
  #[serde(alias = "timestamp-url")]
  pub timestamp_url: Option<String>,
  /// Whether to use Time-Stamp Protocol (TSP, a.k.a. RFC 3161) for the timestamp server. Your code signing provider may
  /// use a TSP timestamp server, like e.g. SSL.com does. If so, enable TSP by setting to true.
  #[serde(default)]
  pub tsp: bool,
  /// The installation mode for the Webview2 runtime.
  #[serde(default, alias = "webview-install-mode")]
  pub webview_install_mode: WebviewInstallMode,
  /// Validates a second app installation, blocking the user from installing an older version if set to `false`.
  ///
  /// For instance, if `1.2.1` is installed, the user won't be able to install app version `1.2.0` or `1.1.5`.
  ///
  /// The default value of this flag is `true`.
  #[serde(default = "default_true", alias = "allow-downgrades")]
  pub allow_downgrades: bool,
  /// Configuration for the MSI generated with WiX.
  pub wix: Option<WixConfig>,
  /// Configuration for the installer generated with NSIS.
  pub nsis: Option<NsisConfig>,
  /// Specify a custom command to sign the binaries.
  /// This command needs to have a `%1` in args which is just a placeholder for the binary path,
  /// which we will detect and replace before calling the command.
  ///
  /// By Default we use `signtool.exe` which can be found only on Windows so
  /// if you are on another platform and want to cross-compile and sign you will
  /// need to use another tool like `osslsigncode`.
  #[serde(alias = "sign-command")]
  pub sign_command: Option<CustomSignCommandConfig>
}
```

--------------------------------

### NSIS Installer Mode Enum

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Defines the installation modes for the NSIS installer, including options for current user, per machine, or both. Each mode specifies where installer metadata is saved.

```rust
/// Install Modes for the NSIS installer.
#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
pub enum NSISInstallerMode {
  /// Default mode for the installer.
  ///
  /// Install the app by default in a directory that doesn't require Administrator access.
  ///
  /// Installer metadata will be saved under the `HKCU` registry path.
  CurrentUser,
  /// Install the app by default in the `Program Files` folder directory requires Administrator
  /// access for the installation.
  ///
  /// Installer metadata will be saved under the `HKLM` registry path.
  PerMachine,
  /// Combines both modes and allows the user to choose at install time
  /// whether to install for the current user or per machine. Note that this mode
  /// will require Administrator access even if the user wants to install it for the current user only.
  ///
  /// Installer metadata will be saved under the `HKLM` or `HKCU` registry path based on the user's choice.
  Both,
}

impl Default for NSISInstallerMode {
  fn default() -> Self {
    Self::CurrentUser
  }
}
```

--------------------------------

### Get Available Monitors - Rust Tauri

Source: https://docs.rs/tauri/latest/src/tauri/app

Retrieves a list of all available monitors connected to the system. This function handles both the runtime and runtime handle scenarios, returning a vector of Monitor objects. It's a core utility for multi-monitor setups.

```rust
pub fn available_monitors(&self) -> crate::Result<Vec<Monitor>> {
    Ok(match self.runtime() {
      RuntimeOrDispatch::Runtime(h) => {
        h.available_monitors().into_iter().map(Into::into).collect()
      }
      RuntimeOrDispatch::RuntimeHandle(h) => {
        h.available_monitors().into_iter().map(Into::into).collect()
      }
      _ => unreachable!(),
    })
  }
```

--------------------------------

### Example Initialization Script for All Frames - Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Demonstrates how to use `initialization_script_for_all_frames` in a Tauri application. This example defines a constant string `INIT_SCRIPT` containing JavaScript that checks the window's origin and logs a message, then proceeds to add a custom property to the window object.

```rust
use tauri::{WindowBuilder, Runtime};

const INIT_SCRIPT: &str = r#" 
  if (window.location.origin === 'https://tauri.app') {
    console.log("hello world from js init script");

    window.__MY_CUSTOM_PROPERTY__ = { foo: 'bar' };
  }
"#;

fn main() {
  tauri::Builder::default()
    .setup(|app| {
      let window = tauri::window::WindowBuilder::new(app, "label").build()?;
      let webview_builder = tauri::webview::WebviewBuilder::new("label", tauri::WebviewUrl::App("index.html".into()))
        .initialization_script_for_all_frames(INIT_SCRIPT);
      let webview = window.add_child(webview_builder, tauri::LogicalPosition::new(0, 0), window.inner_size().unwrap())?;
      Ok(())
    });
}
```

--------------------------------

### Scope Enum and ScopeObjectMatch Implementation in Rust

Source: https://docs.rs/tauri/2.8.4/tauri/ipc/trait

Provides an example implementation of the ScopeObjectMatch trait for a Scope enum. This enum supports matching by domain or by a starting string, demonstrating how to implement the `matches` method.

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum Scope {
  Domain(Url),
  StartsWith(String),
}

impl ScopeObjectMatch for Scope {
  type Input = str;

  fn matches(&self, input: &str) -> bool {
    match self {
      Scope::Domain(url) => {
        let parsed: Url = match input.parse() {
          Ok(parsed) => parsed,
          Err(_) => return false,
        };

        let domain = parsed.domain();

        domain.is_some() && domain == url.domain()
      }
      Scope::StartsWith(start) => input.starts_with(start),
    }
  }
}
```

--------------------------------

### NSIS Installer Compression Algorithms

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Defines the compression algorithms that can be used with the NSIS installer. Options include ZLIB, BZIP2, and LZMA, each offering different trade-offs between compression ratio, speed, and memory usage.

```rust
/// Compression algorithms used in the NSIS installer.
///
/// See <https://nsis.sourceforge.io/Reference/SetCompressor>
#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub enum NsisCompression {
  /// ZLIB uses the deflate algorithm, it is a quick and simple method. With the default compression level it uses about 300 KB of memory.
  Zlib,
  /// BZIP2 usually gives better compression ratios than ZLIB, but it is a bit slower and uses more memory. With the default compression level it uses about 4 MB of memory.
  Bzip2,
  /// LZMA (default) is a new compression method that gives very good compression ratios. The decompression speed is high (10-20 MB/s on a 2 GHz CPU), the compression speed is lower. The memory size that will be used for decompression is the dictionary size plus a few KBs, the default is 8 MB.
  Lzma,
}
```

--------------------------------

### Rust: Handling File Metadata Errors with `and_then`

Source: https://docs.rs/tauri/-build/2.4.1/tauri_build/type

Illustrates using `and_then` with `Result` to handle potential errors when accessing file metadata. This example shows how to chain operations that might fail, like getting metadata and then its modified time.

```rust
use std::{io::ErrorKind, path::Path};

// Note: on Windows "/" maps to "C:\\"
let root_modified_time = Path::new("/").metadata().and_then(|md| md.modified());
assert!(root_modified_time.is_ok());

let should_fail = Path::new("/bad/path").metadata().and_then(|md| md.modified());
assert!(should_fail.is_err());
assert_eq!(should_fail.unwrap_err().kind(), ErrorKind::NotFound);
```

--------------------------------

### NSIS Installer Configuration Options

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Configures the NSIS installer for Windows applications. Allows specifying a custom NSI template, license file, and various image assets for installer pages (header, sidebar). It also supports setting the installer icon and defining the installation scope (all users vs. current user).

```rust
/// Configuration for the Installer bundle using NSIS.
#[derive(Debug, Default, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct NsisConfig {
  /// A custom .nsi template to use.
  pub template: Option<PathBuf>,
  /// The path to the license file to render on the installer.
  pub license: Option<PathBuf>,
  /// The path to a bitmap file to display on the header of installers pages.
  ///
  /// The recommended dimensions are 150px x 57px.
  #[serde(alias = "header-image")]
  pub header_image: Option<PathBuf>,
  /// The path to a bitmap file for the Welcome page and the Finish page.
  ///
  /// The recommended dimensions are 164px x 314px.
  #[serde(alias = "sidebar-image")]
  pub sidebar_image: Option<PathBuf>,
  /// The path to an icon file used as the installer icon.
  #[serde(alias = "install-icon")]
  pub installer_icon: Option<PathBuf>,
  /// Whether the installation will be for all users or just the current user.
  #[serde(default, alias = "install-mode")]
  pub install_mode: NSISInstallerMode,
  /// A list of installer languages.
  /// By default the OS language is used. If the OS language is not in the list of languages, the first language will be used.
}
```

--------------------------------

### Rust Tauri MockWindowDispatcher UI State and Platform Specifics

Source: https://docs.rs/tauri/2.8.4/src/tauri/test/mock_runtime

Methods for retrieving the UI theme and platform-specific window handles. The `theme` method returns a default theme, and the `gtk_window` method is unimplemented, indicating it's a placeholder for Linux-specific functionality.

```rust
fn theme(&self) -> Result<Theme> {
    Ok(Theme::Light)
  }

  #[cfg(any(
    target_os = "linux",
    target_os = "dragonfly",
    target_os = "freebsd",
    target_os = "netbsd",
    target_os = "openbsd"
  ))]
  fn gtk_window(&self) -> Result<gtk::ApplicationWindow> {
    unimplemented!()
  }
```

--------------------------------

### Rust: Unregistering an Event Listener with unlisten

Source: https://docs.rs/tauri/2.8.5/src/tauri/lib

Removes an event listener using its `EventId`. This is crucial for managing resources and preventing memory leaks by ensuring that listeners are cleaned up when no longer needed. The example shows how to unlisten within a setup closure.

```rust
fn unlisten(&self, id: EventId);

```

--------------------------------

### Rust (macOS): Initialize Application Menu

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Initializes the application menu specifically for macOS. This function sets up the window and help submenus, applying them as the main window and help menus for the NSApp. Requires the `target_os = "macos"` configuration. It depends on the `Menu` struct and its associated methods for menu manipulation.

```rust
#[cfg(target_os = "macos")]
fn init_app_menu<R: Runtime>(menu: &Menu<R>) -> crate::Result<()>
{
  menu.inner().init_for_nsapp();

  if let Some(window_menu) = menu.get(crate::menu::WINDOW_SUBMENU_ID) {
    if let Some(m) = window_menu.as_submenu() {
      m.set_as_windows_menu_for_nsapp()?;
    }
  }
  if let Some(help_menu) = menu.get(crate::menu::HELP_SUBMENU_ID) {
    if let Some(m) = help_menu.as_submenu() {
      m.set_as_help_menu_for_nsapp()?;
    }
  }

  Ok(())
}
```

--------------------------------

### NSIS Installer Mode Enum (Rust)

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

Specifies the installation scope for NSIS installers. It supports installing for the current user only, for all users (per machine), or allowing the user to choose. Each mode details the default installation directory and registry path for metadata.

```rust
/// Install Modes for the NSIS installer.
#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub enum NSISInstallerMode {
  /// Default mode for the installer.
  ///
  /// Install the app by default in a directory that doesn't require Administrator access.
  ///
  /// Installer metadata will be saved under the `HKCU` registry path.
  CurrentUser,
  /// Install the app by default in the `Program Files` folder directory requires Administrator
  /// access for the installation.
  ///
  /// Installer metadata will be saved under the `HKLM` registry path.
  PerMachine,
  /// Combines both modes and allows the user to choose at install time
  /// whether to install for the current user or per machine. Note that this mode
  /// will require Administrator access even if the user wants to install it for the current user only.
  ///
  /// Installer metadata will be saved under the `HKLM` or `HKCU` registry path based on the user's choice.
  Both,
}

impl Default for NSISInstallerMode {
  fn default() -> Self {
    Self::CurrentUser
  }
}
```

--------------------------------

### Rust: Creating a New Application Context

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Constructs a new application context (`Context`) using essential components such as configuration, assets, icons, package information, pattern, and runtime authority. It supports optional plugin global API scripts.

```rust
/// Create a new [`Context`] from the minimal required items.
  #[inline(always)]
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    config: Config,
    assets: Box<dyn Assets<R>>,
    default_window_icon: Option<image::Image<'static>>,
    app_icon: Option<Vec<u8>>,
    package_info: PackageInfo,
    pattern: Pattern,
    runtime_authority: RuntimeAuthority,
    plugin_global_api_scripts: Option<&'static [&'static str]>,
  ) -> Self {
    Self {
      config,
      #[cfg(dev)]
      config_parent: None,
      assets,
      default_window_icon,
      app_icon,
      #[cfg(all(desktop, feature = "tray-icon"))]
      tray_icon: None,
      package_info,
      pattern,
      runtime_authority,
      plugin_global_api_scripts,
    }
  }
```

--------------------------------

### Rust: WindowsConfig Struct for Tauri Bundler

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Defines the configuration options for Windows installers in Tauri. It includes settings for code signing (digest algorithm, certificate thumbprint, timestamp URL), Webview2 runtime installation, downgrade prevention, and specific configurations for Wix and NSIS installers. This struct is used to customize the Windows build process.

```rust
#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct WindowsConfig {
  /// Specifies the file digest algorithm to use for creating file signatures.
  /// Required for code signing. SHA-256 is recommended.
  #[serde(alias = "digest-algorithm")]
  pub digest_algorithm: Option<String>,
  /// Specifies the SHA1 hash of the signing certificate.
  #[serde(alias = "certificate-thumbprint")]
  pub certificate_thumbprint: Option<String>,
  /// Server to use during timestamping.
  #[serde(alias = "timestamp-url")]
  pub timestamp_url: Option<String>,
  /// Whether to use Time-Stamp Protocol (TSP, a.k.a. RFC 3161) for the timestamp server.
  #[serde(default)]
  pub tsp: bool,
  /// The installation mode for the Webview2 runtime.
  #[serde(default, alias = "webview-install-mode")]
  pub webview_install_mode: WebviewInstallMode,
  /// Path to the webview fixed runtime to use. Overwrites [`Self::webview_install_mode`] if set.
  #[serde(alias = "webview-fixed-runtime-path")]
  pub webview_fixed_runtime_path: Option<PathBuf>,
  /// Validates a second app installation, blocking the user from installing an older version if set to `false`.
  /// The default value of this flag is `true`.
  #[serde(default = "default_true", alias = "allow-downgrades")]
  pub allow_downgrades: bool,
  /// Configuration for the MSI generated with WiX.
  pub wix: Option<WixConfig>,
  /// Configuration for the installer generated with NSIS.
  pub nsis: Option<NsisConfig>,
}
```

--------------------------------

### Initialize Tauri Plugin in Rust

Source: https://docs.rs/tauri/latest/src/tauri/plugin

Initializes the Tauri plugin with the application handle and configuration. It sets up the plugin's state, runs the setup hook if provided, and registers any custom URI schemes with the application's webview manager. Errors during setup hook execution are propagated.

```rust
impl<R: Runtime, C: DeserializeOwned> Plugin<R> for TauriPlugin<R, C> {
  fn name(&self) -> &'static str {
    self.name
  }

  fn initialize(
    &mut self,
    app: &AppHandle<R>,
    config: JsonValue,
  ) -> Result<(), Box<dyn std::error::Error>> {
    self.app.replace(app.clone());
    if let Some(s) = self.setup.take() {
      (s)(
        app,
        PluginApi {
          name: self.name,
          handle: app.clone(),
          raw_config: Arc::new(config.clone()),
          config: serde_json::from_value(config).map_err(|err| {
            format!(
              "Error deserializing 'plugins.{}' within your Tauri configuration: {err}",
              self.name
            )
          })?,
        },
      )?;
    }

    for (uri_scheme, protocol) in &self.uri_scheme_protocols {
      app
        .manager
        .webview
        .register_uri_scheme_protocol(uri_scheme, protocol.clone());
    }
    Ok(())
  }

  fn initialization_script(&self) -> Option<String> {
    self
      .js_init_script
      .clone()
      .map(|initialization_script| initialization_script.script)
  }

  fn initialization_script_2(&self) -> Option<InitializationScript> {
    self.js_init_script.clone()
  }
}
```

--------------------------------

### Initialize Tauri Image Plugin

Source: https://docs.rs/tauri/latest/src/tauri/image/plugin

Initializes the Tauri Image plugin by creating a `TauriPlugin` instance. It sets up the invoke handler to manage all the image-related commands, making them available to the webview.

```rust
81/// Initializes the plugin.
82pub fn init<R: Runtime>() -> TauriPlugin<R> {
83  Builder::new("image")
84    .invoke_handler(crate::generate_handler![
85      #![plugin(image)]
86      new, from_bytes, from_path, rgba, size
87    ])
88    .build()
89}

```

--------------------------------

### Get Cursor Position - Rust Tauri

Source: https://docs.rs/tauri/latest/src/tauri/app

Fetches the current cursor position relative to the desktop's top-left corner. It accounts for multi-monitor setups, defining the desktop origin based on OS conventions. Coordinates can be negative if the window is off-screen.

```rust
pub fn cursor_position(&self) -> crate::Result<PhysicalPosition<f64>> {
    Ok(match self.runtime() {
      RuntimeOrDispatch::Runtime(h) => h.cursor_position()?,
      RuntimeOrDispatch::RuntimeHandle(h) => h.cursor_position()?,
      _ => unreachable!(),
    })
  }
```

--------------------------------

### Get All Webview Windows

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Retrieves a map of all currently managed webview windows.

```APIDOC
## GET /webview_windows

### Description
Fetches all managed webview windows.

### Method
GET

### Endpoint
/webview_windows

### Parameters
None

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **HashMap<String, WebviewWindow<R>>** (object) - A map where keys are webview window labels and values are WebviewWindow objects.

#### Response Example
```json
{
  "main-webview": {
    "label": "main-webview",
    "window_label": "main"
  }
}
```
```

--------------------------------

### Get All Windows

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Retrieves a map of all currently managed windows.

```APIDOC
## GET /windows

### Description
Fetches all managed windows.

*   **Stability**: Requires the `unstable` feature.

### Method
GET

### Endpoint
/windows

### Parameters
None

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **HashMap<String, Window<R>>** (object) - A map where keys are window labels and values are Window objects.

#### Response Example
```json
{
  "main": {
    "label": "main",
    "title": "My App"
  },
  "settings": {
    "label": "settings",
    "title": "Settings"
  }
}
```
```

--------------------------------

### Rust Result Product Example

Source: https://docs.rs/tauri/-build/latest/tauri_build/type

An example demonstrating the use of the `Product` trait implementation for `Result`. It parses strings into `usize` and calculates their product, returning an `Err` if any parsing fails.

```rust
let nums = vec!["5", "10", "1", "2"];
let total: Result<usize, _> = nums.iter().map(|w| w.parse::<usize>()).product();
assert_eq!(total, Ok(100));
let nums = vec!["5", "10", "one", "2"];
let total: Result<usize, _> = nums.iter().map(|w| w.parse::<usize>()).product();
assert!(total.is_err())
```

--------------------------------

### Example Platform Targeting JSON

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/acl/capability

Demonstrates how to specify target platforms for a capability using a JSON array. This limits the capability's activation to the listed operating systems.

```json
["macOS","windows"]
```

--------------------------------

### Getting Raw Cookie Path in Rust

Source: https://docs.rs/tauri/latest/tauri/webview/struct

Provides an example of retrieving the raw `Path` attribute of a cookie as a string slice, allowing for a lifetime independent of the `Cookie` object. This method is part of the `cookie` crate and is invoked via `path_raw` after parsing the cookie string.

```rust
use cookie::Cookie;

let cookie_string = format!("{}={}; Path=/", "foo", "bar");

// `c` will be dropped at the end of the scope, but `path` will live on
let path = {
    let c = Cookie::parse(cookie_string.as_str()).unwrap();
    c.path_raw()
};

assert_eq!(path, Some("/"));
```

--------------------------------

### Runtime Initialization API

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

Methods for initializing the Tauri runtime with custom configurations and event loop builders.

```APIDOC
## Runtime Initialization API

### Description
Methods for initializing the Tauri runtime with custom configurations and event loop builders.

### Methods

#### `init_with_builder(event_loop_builder: EventLoopBuilder<Message<T>>, args: RuntimeInitArgs)`

- **Description**: Initializes the Wry runtime with a custom event loop builder and initialization arguments.
- **Method**: POST
- **Endpoint**: Not applicable (internal runtime method)
- **Parameters**:
  - `event_loop_builder` (EventLoopBuilder<Message<T>>) - The builder for the event loop.
  - `args` (RuntimeInitArgs) - Initialization arguments for the runtime.
- **Returns**: `Result<Self>`

#### `init(event_loop: EventLoop<Message<T>>)`

- **Description**: Initializes the Wry runtime with a pre-built event loop.
- **Method**: POST
- **Endpoint**: Not applicable (internal runtime method)
- **Parameters**:
  - `event_loop` (EventLoop<Message<T>>) - The configured event loop.
- **Returns**: `Result<Self>`

#### `new(args: RuntimeInitArgs)`

- **Description**: Creates a new Wry runtime instance with default configurations.
- **Method**: POST
- **Endpoint**: Not applicable (internal runtime method)
- **Parameters**:
  - `args` (RuntimeInitArgs) - Initialization arguments for the runtime.
- **Returns**: `Result<Self>`
```

--------------------------------

### NSIS Installer Mode Enum

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Specifies the installation modes for NSIS installers. Options are CurrentUser (no admin rights needed, HKCU registry), PerMachine (requires admin rights, HKLM registry), and Both (user choice, requires admin rights).

```rust
/// Default mode for the installer.
///
/// Install the app by default in a directory that doesn't require Administrator access.
///
/// Installer metadata will be saved under the `HKCU` registry path.
  CurrentUser,
  /// Install the app by default in the `Program Files` folder directory requires Administrator
  /// access for the installation.
  ///
  /// Installer metadata will be saved under the `HKLM` registry path.
  PerMachine,
  /// Combines both modes and allows the user to choose at install time
  /// whether to install for the current user or per machine. Note that this mode
  /// will require Administrator access even if the user wants to install it for the current user only.
  ///
  /// Installer metadata will be saved under the `HKLM` or `HKCU` registry path based on the user's choice.
  Both,

```

--------------------------------

### Set Window Effects Configuration (Tauri Example)

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

An example demonstrating how to use `EffectsBuilder` to configure and apply visual effects to a Tauri window, including setting effect type, state, radius, and color.

```rust
use tauri::{Manager, window::{Color, Effect, EffectState, EffectsBuilder}};
tauri::Builder::default()
  .setup(|app| {
    let window = app.get_window("main").unwrap();
    window.set_effects(
      EffectsBuilder::new()
        .effect(Effect::Popover)
        .state(EffectState::Active)
        .radius(5.)
        .color(Color(0, 0, 0, 255))
        .build(),
    )?;
    Ok(())
  });
```

--------------------------------

### Window Fullscreen

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/window

Configures whether the window should initially start in fullscreen mode.

```APIDOC
## Fullscreen

### Description
Determines whether the window should begin in fullscreen mode.

### Method
`fullscreen(fullscreen: bool) -> Self`
```

--------------------------------

### Windows Updater Configuration in Rust

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Defines the configuration structure for Windows updates within Tauri, including installer arguments and the installation mode. It supports deserialization from various formats and defaults to passive installation.

```rust
/// The updater configuration for Windows.
///
/// See more: https://tauri.app/v1/api/config#updaterwindowsconfig
#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Eq, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct UpdaterWindowsConfig {
  /// Additional arguments given to the NSIS or WiX installer.
  #[serde(default, alias = "installer-args")]
  pub installer_args: Vec<String>,
  /// The installation mode for the update on Windows. Defaults to `passive`.
  #[serde(default, alias = "install-mode")]
  pub install_mode: WindowsUpdateInstallMode,
}
```

--------------------------------

### Build Application

Source: https://docs.rs/tauri/latest/src/tauri/app

Builds the Tauri application with the configured settings and context.

```APIDOC
## POST /build

### Description
Builds the Tauri application with the configured settings and context.

### Method
POST

### Endpoint
`/build`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **context** (Context<R>) - Required - The application context, including configuration and platform-specific details.

### Request Example
```json
{
  "context": { /* Application Context Object */ }
}
```

### Response
#### Success Response (200)
- **app** (App<R>) - The built Tauri application instance.

#### Response Example
```json
{
  "app": { /* App Instance Object */ }
}
```
```

--------------------------------

### POST /create_window_from_config

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Initializes a window builder from a WindowConfig, typically from tauri.conf.json.

```APIDOC
## POST /create_window_from_config

### Description
Initializes a window builder from a `WindowConfig`.

### Method
POST

### Endpoint
/create_window_from_config

### Parameters
#### Request Body
- **config** (object) - Required - The window configuration object.
  - **label** (string) - Required - The unique label for the window.
  - **window_effects** (object) - Optional - Configuration for window effects.
  - **parent** (string) - Optional - The label of the parent window.

### Request Example
```json
{
  "config": {
    "label": "config_window",
    "window_effects": {
      "transparent": true
    },
    "parent": "main_window"
  }
}
```

### Response
#### Success Response (200)
- **message** (string) - Indicates the window was created from configuration.

#### Response Example
```json
{
  "message": "Window created successfully from configuration."
}
```
```

--------------------------------

### NSIS Configuration Struct (Rust)

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

Defines the comprehensive configuration structure for NSIS installers in Tauri. It includes options for custom templates, various image assets (header, sidebar, installer icon), installation mode, language management, and compression settings.

```rust
use std::collections::HashMap;
use std::path::PathBuf;

/// Configuration for the Installer bundle using NSIS.
#[derive(Debug, Default, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct NsisConfig {
  /// A custom .nsi template to use.
  pub template: Option<PathBuf>,
  /// The path to a bitmap file to display on the header of installers pages.
  ///
  /// The recommended dimensions are 150px x 57px.
  #[serde(alias = "header-image")]
  pub header_image: Option<PathBuf>,
  /// The path to a bitmap file for the Welcome page and the Finish page.
  ///
  /// The recommended dimensions are 164px x 314px.
  #[serde(alias = "sidebar-image")]
  pub sidebar_image: Option<PathBuf>,
  /// The path to an icon file used as the installer icon.
  #[serde(alias = "install-icon")]
  pub installer_icon: Option<PathBuf>,
  /// Whether the installation will be for all users or just the current user.
  #[serde(default, alias = "install-mode")]
  pub install_mode: NSISInstallerMode,
  /// A list of installer languages.
  /// By default the OS language is used. If the OS language is not in the list of languages, the first language will be used.
  /// To allow the user to select the language, set `display_language_selector` to `true`.
  ///
  /// See <https://github.com/kichik/nsis/tree/9465c08046f00ccb6eda985abbdbf52c275c6c4d/Contrib/Language%20files> for the complete list of languages.
  pub languages: Option<Vec<String>>,
  /// A key-value pair where the key is the language and the
  /// value is the path to a custom `.nsh` file that holds the translated text for tauri's custom messages.
  ///
  /// See <https://github.com/tauri-apps/tauri/blob/dev/crates/tauri-bundler/src/bundle/windows/nsis/languages/English.nsh> for an example `.nsh` file.
  ///
  /// **Note**: the key must be a valid NSIS language and it must be added to [`NsisConfig`] languages array,
  pub custom_language_files: Option<HashMap<String, PathBuf>>,
  /// Whether to display a language selector dialog before the installer and uninstaller windows are rendered or not.
  /// By default the OS language is selected, with a fallback to the first language in the `languages` array.
  #[serde(default, alias = "display-language-selector")]
  pub display_language_selector: bool,
  /// Set the compression algorithm used to compress files in the installer.
  ///
  /// See <https://nsis.sourceforge.io/Reference/SetCompressor>
  #[serde(default)]
  pub compression: NsisCompression,
}
```

--------------------------------

### Get App Configuration API

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Gets the app's configuration, defined on the `tauri.conf.json` file.

```APIDOC
## GET /config

### Description
Gets the app's configuration, defined on the `tauri.conf.json` file.

### Method
GET

### Endpoint
/config

### Response
#### Success Response (200)
- **config** (object) - The application configuration object.

#### Response Example
```json
{
  "config": { ... }
}
```
```

--------------------------------

### Example: Setting Zoom Level on Linux Webview in Tauri

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

An example demonstrating how to use `with_webview` to interact with the webkit2gtk WebView on Linux, specifically to set the zoom level. This showcases platform-specific adjustments within the webview.

```rust
use tauri::Manager;

fn main() {
  tauri::Builder::default()
    .setup(|app| {
      let main_webview = app.get_webview_window("main").unwrap();
      main_webview.with_webview(|webview| {
        #[cfg(target_os = "linux")]
        {
          use webkit2gtk::WebViewExt;
          webview.inner().set_zoom_level(4.);
        }
        // ... other platform specific code
      });
      Ok(())
    })
    .run(tauri::generate_context!())
    .expect("error while running tauri application");
}
```

--------------------------------

### Create New Context

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Constructs a new application context with essential configuration and assets.

```APIDOC
## POST /new

### Description
Creates a new application context from the minimal required items.

### Method
POST

### Endpoint
/new

### Parameters
#### Request Body
- **config** (Config) - Required - The application configuration object.
- **assets** (Box<dyn Assets<R>>) - Required - Boxed assets for the application.
- **default_window_icon** (Option<image::Image<'static>>) - Optional - The default icon for windows.
- **app_icon** (Option<Vec<u8>>) - Optional - The application's main icon.
- **package_info** (PackageInfo) - Required - Information about the application package.
- **pattern** (Pattern) - Required - The application's execution pattern.
- **runtime_authority** (RuntimeAuthority) - Required - The application's runtime authority.
- **plugin_global_api_scripts** (Option<&'static [&'static str]>) - Optional - Global API scripts for plugins.

### Request Example
```json
{
  "config": {
    "tauri": {
      "bundle": {
        "active": true,
        "targets": null,
        "identifier": "com.example.myapp"
      },
      "security": {
        "csp": null
      }
    }
  },
  "assets": "<boxed_assets_representation>",
  "default_window_icon": null,
  "app_icon": null,
  "package_info": {
    "name": "my-app",
    "version": "1.0.0",
    "edition": "community"
  },
  "pattern": "<pattern_representation>",
  "runtime_authority": {
    "authority_level": "user"
  },
  "plugin_global_api_scripts": null
}
```

### Response
#### Success Response (200)
- **Self** (Context) - The newly created application context.

#### Response Example
```json
{
  "message": "Context created successfully"
}
```
```

--------------------------------

### Get Package Information API

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Gets the app's package information.

```APIDOC
## GET /package_info

### Description
Gets the app's package information.

### Method
GET

### Endpoint
/package_info

### Response
#### Success Response (200)
- **packageInfo** (object) - The application package information object.

#### Response Example
```json
{
  "packageInfo": { ... }
}
```
```

--------------------------------

### Integrate NSIS Installer Hooks in Tauri

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

Hook into the NSIS installer script using a provided `.nsh` file. This allows execution of custom macros at specific stages of the installation or uninstallation process: NSIS_HOOK_PREINSTALL, NSIS_HOOK_POSTINSTALL, NSIS_HOOK_PREUNINSTALL, and NSIS_HOOK_POSTUNINSTALL. These hooks can be used to perform custom actions before or after file copying, registry key manipulation, or shortcut creation.

```Rust
pub installer_hooks: Option<PathBuf>
```

```nsh
!macro NSIS_HOOK_PREINSTALL
  MessageBox MB_OK "PreInstall"
!macroend

!macro NSIS_HOOK_POSTINSTALL
  MessageBox MB_OK "PostInstall"
!macroend

!macro NSIS_HOOK_PREUNINSTALL
  MessageBox MB_OK "PreUnInstall"
!macroend

!macro NSIS_HOOK_POSTUNINSTALL
  MessageBox MB_OK "PostUninstall"
!macroend
```

--------------------------------

### Setup Menu and Tray Event Handlers (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Sets up event handlers for menu and tray icons in a Tauri application. It uses `muda::MenuEvent` and `tray_icon::TrayIconEvent` to capture user interactions. Proxies are used to send these events to the main runtime, enabling responsiveness to menu selections and tray icon clicks. This functionality is conditionally compiled for desktop targets.

```rust
#[cfg(desktop)]
    {
      // setup menu event handler
      let proxy = runtime.create_proxy();
      muda::MenuEvent::set_event_handler(Some(move |e: muda::MenuEvent| {
        let _ = proxy.send_event(EventLoopMessage::MenuEvent(e.into()));
      }));

      // setup tray event handler
      #[cfg(feature = "tray-icon")]
      {
        let proxy = runtime.create_proxy();
        tray_icon::TrayIconEvent::set_event_handler(Some(move |e: tray_icon::TrayIconEvent| {
          let _ = proxy.send_event(EventLoopMessage::TrayIconEvent(e.into()));
        }));
      }
    }
```

--------------------------------

### Icon Loading Example (C/C++ with winapi)

Source: https://docs.rs/tauri/-winres/0.3.3/tauri_winres/struct

Illustrates how icons can be loaded at runtime in Windows applications using `LoadIconW` and `MAKEINTRESOURCEW` from the `winapi` library, depending on whether the name ID is numeric or a string.

```C
LoadIconW(h_instance, MAKEINTRESOURCEW(name_id_as_integer))

```

```C
LoadIconW(h_instance, name_id_as_wide_c_str_as_ptr)

```

--------------------------------

### Tauri Windows Configuration for Signing and Installation

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Configures Windows-specific settings for Tauri applications, including code signing parameters like digest algorithm, certificate thumbprint, and timestamp URL. It also controls the Webview2 runtime installation mode, downgrade prevention, and configurations for MSI (WiX) and NSIS installers. A custom sign command can be specified for cross-platform signing needs.

```rust
/// Windows bundler configuration.
///
/// See more: <https://v2.tauri.app/reference/config/#windowsconfig>
#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct WindowsConfig {
  /// Specifies the file digest algorithm to use for creating file signatures.
  /// Required for code signing. SHA-256 is recommended.
  #[serde(alias = "digest-algorithm")]
  pub digest_algorithm: Option<String>,
  /// Specifies the SHA1 hash of the signing certificate.
  #[serde(alias = "certificate-thumbprint")]
  pub certificate_thumbprint: Option<String>,
  /// Server to use during timestamping.
  #[serde(alias = "timestamp-url")]
  pub timestamp_url: Option<String>,
  /// Whether to use Time-Stamp Protocol (TSP, a.k.a. RFC 3161) for the timestamp server. Your code signing provider may
  /// use a TSP timestamp server, like e.g. SSL.com does. If so, enable TSP by setting to true.
  #[serde(default)]
  pub tsp: bool,
  /// The installation mode for the Webview2 runtime.
  #[serde(default, alias = "webview-install-mode")]
  pub webview_install_mode: WebviewInstallMode,
  /// Validates a second app installation, blocking the user from installing an older version if set to `false`.
  ///
  /// For instance, if `1.2.1` is installed, the user won't be able to install app version `1.2.0` or `1.1.5`.
  ///
  /// The default value of this flag is `true`.
  #[serde(default = "default_true", alias = "allow-downgrades")]
  pub allow_downgrades: bool,
  /// Configuration for the MSI generated with WiX.
  pub wix: Option<WixConfig>,
  /// Configuration for the installer generated with NSIS.
  pub nsis: Option<NsisConfig>,
  /// Specify a custom command to sign the binaries.
  /// This command needs to have a `%1` in args which is just a placeholder for the binary path,
  /// which we will detect and replace before calling the command.
  ///
  /// By Default we use `signtool.exe` which can be found only on Windows so
  /// if you are on another platform and want to cross-compile and sign you will
  /// need to use another tool like `osslsigncode`.
  #[serde(alias = "sign-command")]
  pub sign_command: Option<CustomSignCommandConfig>,
}

impl Default for WindowsConfig {
  fn default() -> Self {
    Self {
      digest_algorithm: None,
      certificate_thumbprint: None,
      timestamp_url: None,
      tsp: false,
      webview_install_mode: Default::default(),
      allow_downgrades: true,
      wix: None,
      nsis: None,
      sign_command: None,
    }
  }
}
```

--------------------------------

### Rust: PluginStore Initialization

Source: https://docs.rs/tauri/2.8.5/src/tauri/plugin

Methods for initializing individual plugins or all plugins within the PluginStore. This involves calling the plugin's initialization logic, potentially with application context and configuration.

```rust
pub(crate) fn initialize(
    &self,
    plugin: &mut Box<dyn Plugin<R>>,
    app: &AppHandle<R>,
    config: &PluginConfig,
  ) -> crate::Result<()> {
    initialize(plugin, app, config)
  }

  /// Initializes all plugins in the store.
  pub(crate) fn initialize_all(
    &mut self,
    app: &AppHandle<R>,
    config: &PluginConfig,
  ) -> crate::Result<()> {
    self
      .store
      .iter_mut()
      .try_for_each(|plugin| initialize(plugin, app, config))
  }
```

--------------------------------

### Cursor and Theme Management

Source: https://docs.rs/tauri/2.8.4/x86_64-unknown-linux-gnu/tauri/app/struct

APIs for getting cursor position and setting the application theme.

```APIDOC
## GET /cursor_position

### Description
Get the cursor position relative to the top-left hand corner of the desktop. The coordinates can be negative if the top-left hand corner of the window is outside of the visible screen region.

### Method
GET

### Endpoint
/cursor_position

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **position** (PhysicalPosition<f64>) - The current cursor position.

#### Response Example
```json
{
  "position": {"x": 100, "y": 200}
}
```

## POST /set_theme

### Description
Sets the app theme. This is unsupported on iOS and Android.

### Method
POST

### Endpoint
/set_theme

### Parameters
#### Request Body
- **theme** (Option<Theme>) - The theme to set (e.g., 'light', 'dark', null for system default).

### Request Example
```json
{
  "theme": "dark"
}
```

### Response
#### Success Response (200)
None

#### Response Example
None
```

--------------------------------

### Start Window Resize Dragging (Rust)

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

Initiates a resize-dragging operation for the window, allowing the user to resize it by dragging from the edges or corners. Requires a `ResizeDirection` to specify which edge/corner is being dragged.

```rust
fn start_resize_dragging(&self, direction: ResizeDirection) -> Result<()>;

```

--------------------------------

### NSIS Configuration Structure

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Defines the configuration options for NSIS installers, including template paths, image assets, icons, installation mode, language settings, and compression.

```rust
/// Configuration for the Installer bundle using NSIS.
#[derive(Debug, Default, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct NsisConfig {
  /// A custom .nsi template to use.
  pub template: Option<PathBuf>,
  /// The path to a bitmap file to display on the header of installers pages.
  ///
  /// The recommended dimensions are 150px x 57px.
  #[serde(alias = "header-image")]
  pub header_image: Option<PathBuf>,
  /// The path to a bitmap file for the Welcome page and the Finish page.
  ///
  /// The recommended dimensions are 164px x 314px.
  #[serde(alias = "sidebar-image")]
  pub sidebar_image: Option<PathBuf>,
  /// The path to an icon file used as the installer icon.
  #[serde(alias = "install-icon")]
  pub installer_icon: Option<PathBuf>,
  /// Whether the installation will be for all users or just the current user.
  #[serde(default, alias = "install-mode")]
  pub install_mode: NSISInstallerMode,
  /// A list of installer languages.
  /// By default the OS language is used. If the OS language is not in the list of languages, the first language will be used.
  /// To allow the user to select the language, set `display_language_selector` to `true`.
  ///
  /// See <https://github.com/kichik/nsis/tree/9465c08046f00ccb6eda985abbdbf52c275c6c4d/Contrib/Language%20files> for the complete list of languages.
  pub languages: Option<Vec<String>>,
  /// A key-value pair where the key is the language and the
  /// value is the path to a custom `.nsh` file that holds the translated text for tauri's custom messages.
  ///
  /// See <https://github.com/tauri-apps/tauri/blob/dev/crates/tauri-bundler/src/bundle/windows/nsis/languages/English.nsh> for an example `.nsh` file.
  ///
  /// **Note**: the key must be a valid NSIS language and it must be added to [`NsisConfig`] languages array,
  pub custom_language_files: Option<HashMap<String, PathBuf>>,
  /// Whether to display a language selector dialog before the installer and uninstaller windows are rendered or not.
  /// By default the OS language is selected, with a fallback to the first language in the `languages` array.
  #[serde(default, alias = "display-language-selector")]
  pub display_language_selector: bool,
  /// Set the compression algorithm used to compress files in the installer.
  ///
  /// See <https://nsis.sourceforge.io/Reference/SetCompressor>
  #[serde(default)]

```

--------------------------------

### iOS Plugin Binding Macro

Source: https://docs.rs/tauri/latest/src/tauri/lib

Defines a macro to set up bindings for initializing an iOS plugin. It requires the `target_os = "ios"` configuration and uses `tauri::swift_rs::swift` to create the binding.

```rust
#![cfg(target_os = "ios")]
#[macro_export]
macro_rules! ios_plugin_binding {
  ($fn_name: ident) => {
    tauri::swift_rs::swift!(fn $fn_name() -> *const ::std::ffi::c_void);
  }
}
```

--------------------------------

### Emit Event Example (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/lib

Example of emitting a 'synchronized' event with an empty payload from a Tauri command. This event can be caught by listeners set up in the application.

```rust
use tauri::Emitter;

#[tauri::command]
fn synchronize(app: tauri::AppHandle) {
  // emits the synchronized event to all webviews
  app.emit("synchronized", ());
}
```

--------------------------------

### Window Builder API

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/mod

APIs for building and configuring windows, including initializing a window builder and adding child webviews.

```APIDOC
## Window Builder API

### Description
Provides methods for creating and configuring windows, including initializing a window builder and adding child webviews.

### Initialization

#### `builder`

- **Method**: `POST` (conceptual, as it's a function call)
- **Endpoint**: N/A (function within a struct)
- **Description**: Initializes a window builder with the given window label. Data URLs are only supported with the `webview-data-url` feature flag.
- **Parameters**: None directly, takes `manager` and `label` as arguments.

### Child Webviews

#### `add_child`

- **Method**: `POST` (conceptual, as it's a function call)
- **Endpoint**: N/A (method on a `Window` object)
- **Description**: Adds a new webview as a child of this window. Requires feature flags `desktop` and `unstable`.
- **Parameters**:
  - `webview_builder` (WebviewBuilder): The builder for the webview to add.
  - `position` (P: Into<Position>): The position of the child webview.
  - `size` (S: Into<Size>): The size of the child webview.

### Request Example (add_child)
```json
{
  "webview_builder": "...",
  "position": {"x": 0, "y": 0},
  "size": {"width": 500, "height": 300}
}
```

### Response Example (add_child)
```json
{
  "webview": "..."
}
```
```

--------------------------------

### Windows Configuration

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Configures settings specific to Windows application bundling, such as code signing and WebView runtime installation.

```APIDOC
## Windows Configuration Object

### Description
Configuration for the MSI generated with WiX or the installer generated with NSIS.

### Fields

- **digestAlgorithm** (string, optional) - Specifies the file digest algorithm for creating file signatures. SHA-256 is recommended. Required for code signing.
- **certificateThumbprint** (string, optional) - Specifies the SHA1 hash of the signing certificate.
- **timestampUrl** (string, optional) - Server to use during timestamping.
- **tsp** (boolean, optional, default: `false`) - Whether to use Time-Stamp Protocol (TSP) for the timestamp server.
- **webviewInstallMode** (WebviewInstallMode, optional) - The installation mode for the Webview2 runtime. Defaults to the system's default.
- **webviewFixedRuntimePath** (string, optional) - Path to the webview fixed runtime to use. Overwrites `webviewInstallMode` if set. Prefer `webviewInstallMode` for future versions.
- **allowDowngrades** (boolean, optional, default: `true`) - Validates a second app installation, blocking the user from installing an older version if set to `false`.
- **wix** (WixConfig, optional) - Configuration for the MSI generated with WiX.
- **nsis** (NsisConfig, optional) - Configuration for the installer generated with NSIS.

### Example
```json
{
  "digestAlgorithm": "sha256",
  "certificateThumbprint": "YOUR_CERTIFICATE_THUMBPRINT",
  "timestampUrl": "http://timestamp.example.com",
  "tsp": true,
  "webviewInstallMode": "install",
  "allowDowngrades": false,
  "wix": { ... },
  "nsis": { ... }
}
```
```

--------------------------------

### Create Window and Webview in Tauri

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/x86_64-unknown-linux-gnu/src/tauri_runtime_wry/lib

Functions for creating new windows and webviews. `create_window` is used for standard windows, while `create_webview` is for integrated web content. Both require pending configurations and return a detached handle to the created element. Note that `create_webview` must be called from a separate thread to prevent deadlocks.

```rust
fn create_window(
    &mut self,
    pending: PendingWindow<T, Self::Runtime>,
    after_window_creation: Option<F>,
  ) -> Result<DetachedWindow<T, Self::Runtime>> {
    self.context.create_window(pending, after_window_creation)
  }

  // Creates a webview by dispatching a message to the event loop.
  // Note that this must be called from a separate thread, otherwise the channel will introduce a deadlock.
  fn create_webview(
    &mut self,
    pending: PendingWebview<T, Self::Runtime>,
  ) -> Result<DetachedWebview<T, Self::Runtime>> {
    self.context.create_webview(self.window_id, pending)
  }
```

--------------------------------

### Set Minimum WebView2 Version in Tauri Installer

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

Specify a minimum required version for the WebView2 runtime. If the user's installed version is older than the specified version, the installer will attempt to trigger a WebView2 update. This ensures compatibility and access to the latest features and security patches.

```Rust
pub minimum_webview2_version: Option<String>
```

--------------------------------

### Manage State

Source: https://docs.rs/tauri/latest/src/tauri/lib

Adds a state managed by the application. This is typically used in the `setup` hook.

```APIDOC
## POST /manage

### Description
Manages a piece of global state within the Tauri application.

### Method
`POST` (conceptually, as it's called via a builder method)

### Endpoint
N/A (Builder Method)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
None (type `T` is generic and passed directly)

### Request Example
```rust
// Assuming `app` is a Tauri App instance
app.manage(MyState { data: "some data" });
```

### Response
#### Success Response (200)
Returns `true` if the state was successfully managed, `false` if a state of the same type was already managed.

#### Response Example
```json
{
  "success": true
}
```
```

--------------------------------

### JSON: Example Tauri Configuration File (tauri.config.json)

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

This JSON object demonstrates a typical `tauri.config.json` file, outlining the structure for build, package, and tauri settings. It includes configurations for build commands, package name and version, and various tauri-specific options like allowlist, bundle, security, updater, and window settings. This file is used to customize Tauri application behavior.

```json
{
  "build": {
    "beforeBuildCommand": "",
    "beforeDevCommand": "",
    "devPath": "../dist",
    "distDir": "../dist"
  },
  "package": {
    "productName": "tauri-app",
    "version": "0.1.0"
  },
  "tauri": {
    "allowlist": {
      "all": true
    },
    "bundle": {},
    "security": {
      "csp": null
    },
    "updater": {
      "active": false
    },
    "windows": [
      {
        "fullscreen": false,
        "height": 600,
        "resizable": true,
        "title": "Tauri App",
        "width": 800
      }
    ]
  }
}
```

--------------------------------

### Tauri Webview Window Builder

Source: https://docs.rs/tauri/latest/src/tauri/webview/mod

Provides a builder pattern for creating and configuring `WebviewWindow` instances. This allows for declarative setup of window properties such as size, position, title, and URL before the window is shown.

```rust
pub use webview_window::WebviewWindowBuilder;
```

--------------------------------

### Set Initialization Script for Tauri Webview

Source: https://docs.rs/tauri/latest/src/tauri/webview/mod

This Rust code example shows how to add a JavaScript initialization script to a Tauri webview. The script is executed after the global object is created but before the HTML document is parsed. The example demonstrates how to configure the webview builder with an initialization script and add it as a child to a window.

```rust
use tauri::{WindowBuilder, Runtime};

const INIT_SCRIPT: &str = r#"#
  if (window.location.origin === 'https://tauri.app') {
    console.log("hello world from js init script");

    window.__MY_CUSTOM_PROPERTY__ = { foo: 'bar' };
  }
"#;

fn main() {
  tauri::Builder::default()
    .setup(|app| {
      let window = tauri::window::WindowBuilder::new(app, "label").build()?;
      let webview_builder = tauri::webview::WebviewBuilder::new("label", tauri::WebviewUrl::App("index.html".into()))
        .initialization_script(INIT_SCRIPT);
      let webview = window.add_child(webview_builder, tauri::LogicalPosition::new(0, 0), window.inner_size().unwrap())?;
      Ok(())
    });
}
```

--------------------------------

### Build Tauri Webview Window from Configuration

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Constructs a Tauri WebviewWindowBuilder from a given configuration. This is useful for initializing windows with predefined settings. It relies on underlying WindowBuilder and WebviewBuilder configurations.

```rust
pub fn from_config<'a, M>(manager: &'a M, config: &WindowConfig) -> crate::Result<Self> {
    Ok(Self {
      window_builder: WindowBuilder::from_config(manager, config)?,
      webview_builder: WebviewBuilder::from_config(config),
    })
  }
```

--------------------------------

### Example: Set Device Event Filter (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/app

Demonstrates setting the device event filter to `Always` for a Tauri application. This example shows how to build the application and then configure it to capture device events regardless of window focus state.

```rust
let mut app = tauri::Builder::default()
  .build(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
  .expect("error while building tauri application");
app.set_device_event_filter(tauri::DeviceEventFilter::Always);
app.run(|_app_handle, _event| {});
```

--------------------------------

### GET /cursor-position

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/mod

Gets the cursor's position relative to the desktop's top-left corner. Coordinates can be negative.

```APIDOC
## GET /cursor-position

### Description
Get the cursor position relative to the top-left hand corner of the desktop. The coordinates can be negative if the window is outside the visible screen region. On multi-monitor setups, the desktop origin is the top-left of the primary monitor (Windows/macOS) or the leftmost monitor (X11).

### Method
GET

### Endpoint
/cursor-position

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **position** (PhysicalPosition<f64>) - An object containing the x and y coordinates of the cursor.

#### Response Example
```json
{
  "position": {
    "x": 100.5,
    "y": 200.0
  }
}
```
```

--------------------------------

### Build with Windows Attributes

Source: https://docs.rs/tauri/-build/2.4.1/tauri_build/struct

Demonstrates how to combine `WindowsAttributes` with general `Attributes` and initiate the Tauri build process. This is the final step in configuring Windows-specific build settings.

```rust
let windows_attrs = tauri_build::WindowsAttributes::new().window_icon_path("path/to/icon.ico");
let attrs = tauri_build::Attributes::new().windows_attributes(windows_attrs);
tauri_build::try_build(attrs).expect("failed to run build script");
```

--------------------------------

### Create Webview Window with Configuration in Tauri

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/plugin

Creates a new webview window using a provided `WindowConfig` object. This command allows for detailed configuration of the new window, such as its initial size, position, and other properties. It returns a `Result` indicating success or failure.

```rust
use crate::command;
use crate::plugin::{Builder, TauriPlugin};
use crate::Runtime;
use tauri_utils::config::WindowConfig;

#[command(root = "crate")]
pub async fn create_webview_window<R: Runtime>(
  app: AppHandle<R>,
  options: WindowConfig,
) -> crate::Result<()> {
  WebviewWindowBuilder::from_config(&app, &options)?.build()?;
  Ok(())
}
```

--------------------------------

### Rust: Get Available Monitors with WryHandle

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

The `available_monitors` method returns a vector of all connected `Monitor`s. It accesses the window target to get a list of available displays.

```rust
fn available_monitors(&self) -> Vec<Monitor> {
    self
      .context
      .main_thread
      .window_target

```

--------------------------------

### Setup Menu and Tray Event Handlers (Desktop)

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Configures event handlers for menu and tray icon interactions on desktop platforms. It uses proxies to send events from the menu and tray to the application's event loop, enabling dynamic updates and responses to user interactions.

```rust
#[cfg(desktop)]
{
  // setup menu event handler
  let proxy = runtime.create_proxy();
  muda::MenuEvent::set_event_handler(Some(move |e: muda::MenuEvent| {
    let _ = proxy.send_event(EventLoopMessage::MenuEvent(e.into()));
  }));

  // setup tray event handler
  #[cfg(feature = "tray-icon")]
  {
    let proxy = runtime.create_proxy();
    tray_icon::TrayIconEvent::set_event_handler(Some(move |e: tray_icon::TrayIconEvent| {
      let _ = proxy.send_event(EventLoopMessage::TrayIconEvent(e.into()));
    }));
  }
}
```

--------------------------------

### Build Tauri Webview Instance

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

This Rust code snippet illustrates the process of building a new Tauri webview instance. It takes a `Window` and dimensions, prepares the pending webview attributes, and then uses the runtime dispatcher to create the webview. Finally, it attaches the webview to the application manager, returning a `Webview` object.

```rust
pub(crate) fn build(
    self,
    window: Window<R>,
    position: Position,
    size: Size,
  ) -> crate::Result<Webview<R>> {
    let app_manager = window.manager();

    let mut pending = self.into_pending_webview(&window, window.label())?;

    pending.webview_attributes.bounds = Some(tauri_runtime::dpi::Rect { size, position });

    let use_https_scheme = pending.webview_attributes.use_https_scheme;

    let webview = match &mut window.runtime() {
      RuntimeOrDispatch::Dispatch(dispatcher) => dispatcher.create_webview(pending),
      _ => unimplemented!(),
    }
    .map(|webview| {
      app_manager
        .webview
        .attach_webview(window.clone(), webview, use_https_scheme)
    })?;

    Ok(webview)
  }
```

--------------------------------

### Get Runtime Directory Path

Source: https://docs.rs/tauri/2.8.5/src/tauri/path/desktop

Gets the path to the user's runtime directory, which is typically `$XDG_RUNTIME_DIR` on Linux. This functionality is not supported on macOS or Windows.

```rust
pub fn runtime_dir(&self) -> Result<PathBuf> {
    dirs::runtime_dir().ok_or(Error::UnknownPath)
  }
```

--------------------------------

### Window Fullscreen Configuration

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/window

Configures whether the window should start in fullscreen mode.

```APIDOC
## POST /window/fullscreen

### Description
Sets whether the window should start in fullscreen mode upon creation.

### Method
POST

### Endpoint
/window/fullscreen

### Parameters
#### Query Parameters
- **fullscreen** (boolean) - Required - Whether the window should be in fullscreen mode.

### Request Example
```json
{
  "fullscreen": true
}
```

### Response
#### Success Response (200)
- **status** (string) - Indicates success.

#### Response Example
```json
{
  "status": "success"
}
```
```

--------------------------------

### Tauri Runtime: Window and Webview Management

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

This snippet outlines methods for creating and managing windows and webviews within the Tauri runtime. It includes functions for creating new windows with optional post-creation callbacks, creating detached windows, and creating detached webviews. These methods are essential for building the UI and interactivity of a Tauri application.

```rust
/// Create a new window.
fn create_window<F: Fn(RawWindow) + Send + 'static>(
  &self,
  pending: PendingWindow<T, Self>,
  after_window_creation: Option<F>,
) -> Result<DetachedWindow<T, Self::Runtime>>;

/// Create a new webview.
fn create_webview(
  &self,
  window_id: WindowId,
  pending: PendingWebview<T, Self::Runtime>,
) -> Result<DetachedWebview<T, Self::Runtime>>;
```

--------------------------------

### Create New Windows Resource (Rust)

Source: https://docs.rs/tauri/-winres/0.3.3/tauri_winres/struct

Initializes a new `WindowsResource` instance. It automatically populates version info using values from `Cargo.toml` (package.version, package.name, package.description).

```Rust
pub fn new() -> Self
```

--------------------------------

### Create Webview from Configuration (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Demonstrates initializing a `WebviewBuilder` using a `WindowConfig` loaded from `tauri.conf.json`. This is useful for creating webviews with predefined settings. Note that labels must be unique.

```rust
#[tauri::command]
async fn create_window(app: tauri::AppHandle) {
  let window = tauri::window::WindowBuilder::new(&app, "label").build().unwrap();
  let webview_builder = tauri::webview::WebviewBuilder::from_config(&app.config().app.windows.get(0).unwrap().clone());
  window.add_child(webview_builder, tauri::LogicalPosition::new(0, 0), window.inner_size().unwrap());
}
```

--------------------------------

### Build Tauri Application - Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Constructs the Tauri application instance. This function initializes the application manager, sets up event listeners, and prepares the runtime arguments. It includes platform-specific configurations for macOS menus and Windows message hooks, as well as handling fixed runtime configurations for Windows webviews.

```rust
pub fn build(mut self, context: Context<R>) -> crate::Result<App<R>> {
  #[cfg(target_os = "macos"]
  if self.menu.is_none() && self.enable_macos_default_menu {
    self.menu = Some(Box::new(|app_handle| {
      crate::menu::Menu::default(app_handle)
    }));
  }

  let manager = Arc::new(AppManager::with_handlers(
    context,
    self.plugins,
    self.invoke_handler,
    self.on_page_load,
    self.uri_scheme_protocols,
    self.state,
    #[cfg(desktop)]
    self.menu_event_listeners,
    #[cfg(all(desktop, feature = "tray-icon"))]
    self.tray_icon_event_listeners,
    self.window_event_listeners,
    self.webview_event_listeners,
    #[cfg(desktop)]
    HashMap::new(),
    self.invoke_initialization_script,
    self.channel_interceptor,
    self.invoke_key,
  ));

  #[cfg(any(
    target_os = "linux",
    target_os = "dragonfly",
    target_os = "freebsd",
    target_os = "netbsd",
    target_os = "openbsd"
  ))]
  let app_id = if manager.config.app.enable_gtk_app_id {
    Some(manager.config.identifier.clone())
  } else {
    None
  };

  let runtime_args = RuntimeInitArgs {
    #[cfg(any(
      target_os = "linux",
      target_os = "dragonfly",
      target_os = "freebsd",
      target_os = "netbsd",
      target_os = "openbsd"
    ))]
    app_id,

    #[cfg(windows)]
    msg_hook: {
      let menus = manager.menu.menus.clone();
      Some(Box::new(move |msg| {
        use windows::Win32::UI::WindowsAndMessaging::{TranslateAcceleratorW, HACCEL, MSG};
        unsafe {
          let msg = msg as *const MSG;
          for menu in menus.lock().unwrap().values() {
            let translated =
              TranslateAcceleratorW((*msg).hwnd, HACCEL(menu.inner().haccel() as _), msg);
            if translated == 1 {
              return true;
            }
          }

          false
        }
      }))
    },
  };

  // The env var must be set before the Runtime is created so that GetAvailableBrowserVersionString picks it up.
  #[cfg(windows)]
  {
    if let crate::utils::config::WebviewInstallMode::FixedRuntime { path } =
      &manager.config.bundle.windows.webview_install_mode
    {
      if let Some(exe_dir) = crate::utils::platform::current_exe()
        .ok()
        .and_then(|p| p.parent().map(|p| p.to_path_buf()))

```

--------------------------------

### Initialize Application and Manage State (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Initializes the Tauri application structure, including the runtime, setup function, and manager. It also manages application state by injecting `Env` and `Scopes` (including asset protocol scope if enabled) and an `ChannelDataIpcQueue`. This sets up the core components for the application's lifecycle and communication.

```rust
let mut app = App {
      runtime: Some(runtime),
      setup: Some(self.setup),
      manager: manager.clone(),
      handle: AppHandle {
        runtime_handle,
        manager,
        event_loop: Arc::new(Mutex::new(EventLoop {
          main_thread_id: std::thread::current().id(),
        })),
      },
      ran_setup: false,
    };

    app.register_core_plugins()?;

    let env = Env::default();
    app.manage(env);

    app.manage(Scopes {
      #[cfg(feature = "protocol-asset")]
      asset_protocol: crate::scope::fs::Scope::new(
        &app,
        &app.config().app.security.asset_protocol.scope,
      )?,
    });

    app.manage(ChannelDataIpcQueue::default());
    app.handle.plugin(crate::ipc::channel::plugin())?;
```

--------------------------------

### Rust: Window Manipulation Methods

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

Provides methods for setting window properties such as position, focus, visibility, and size. It also includes functions for evaluating JavaScript, reparenting the webview, and managing cookies and background colors.

```rust
fn set_position(&self, position: Position) -> Result<()>;
fn set_focus(&self) -> Result<()>;
fn hide(&self) -> Result<()>;
fn show(&self) -> Result<()>;
fn eval_script<S: Into<String>>(&self, script: S) -> Result<()>;
fn reparent(&self, window_id: WindowId) -> Result<()>;
fn cookies_for_url(&self, url: Url) -> Result<Vec<Cookie<'static>>>;
fn cookies(&self) -> Result<Vec<Cookie<'static>>>;
fn set_cookie(&self, cookie: cookie::Cookie<'_>) -> Result<()>;
fn delete_cookie(&self, cookie: cookie::Cookie<'_>) -> Result<()>;
fn set_auto_resize(&self, auto_resize: bool) -> Result<()>;
fn set_zoom(&self, scale_factor: f64) -> Result<()>;
fn set_background_color(&self, color: Option<Color>) -> Result<()>;
fn clear_all_browsing_data(&self) -> Result<()>;

```

--------------------------------

### Rust: WiX Language Configuration (WixLanguageConfig)

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Defines the configuration for a specific language within a WiX installer build. It primarily includes the path to a locale (`.wxl`) file, which is used for localizing the installer.

```rust
/// Configuration for a target language for the WiX build.
///
/// See more: https://tauri.app/v1/api/config#wixlanguageconfig
#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct WixLanguageConfig {
  /// The path to a locale (`.wxl`) file. See <https://wixtoolset.org/documentation/manual/v3/howtos/ui_and_localization/build_a_localized_version.html>.
  #[serde(alias = "locale-path")]
  pub locale_path: Option<String>,
}
```

--------------------------------

### Get Tray Icon API

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Gets a tray icon using the provided id. This feature requires the 'tray-icon' feature and is only available on desktop platforms.

```APIDOC
## GET /tray_by_id/{id}

### Description
Gets a tray icon using the provided id.

### Method
GET

### Endpoint
/tray_by_id/{id}

### Parameters
#### Path Parameters
- **id** (string) - Required - The ID of the tray icon to retrieve.

### Response
#### Success Response (200)
- **trayIcon** (object) - The tray icon object.

#### Response Example
```json
{
  "trayIcon": { ... }
}
```
```

--------------------------------

### Window Icon and Menu Management

Source: https://docs.rs/tauri/2.8.4/x86_64-unknown-linux-gnu/tauri/app/struct

APIs for managing the default window icon and the application-wide menu.

```APIDOC
## GET /default_window_icon

### Description
Returns the default window icon.

### Method
GET

### Endpoint
/default_window_icon

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **icon** (Option<Image<'_>>) - The default window icon.

#### Response Example
```json
{
  "icon": "base64_encoded_icon_data"
}
```

## GET /menu

### Description
Returns the app-wide menu.

### Method
GET

### Endpoint
/menu

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **menu** (Option<Menu<R>>) - The app-wide menu or None.

#### Response Example
```json
{
  "menu": {
    "items": [
      {
        "title": "File",
        "submenu": [
          {"title": "New", "action": "new-file"}
        ]
      }
    ]
  }
}
```

## POST /set_menu

### Description
Sets the app-wide menu and returns the previous one. If a window was not created with an explicit menu or had one set explicitly, this menu will be assigned to it.

### Method
POST

### Endpoint
/set_menu

### Parameters
#### Request Body
- **menu** (Menu<R>) - The menu to set.

### Request Example
```json
{
  "menu": {
    "items": [
      {
        "title": "Edit",
        "submenu": [
          {"title": "Cut", "action": "edit-cut"},
          {"title": "Copy", "action": "edit-copy"},
          {"title": "Paste", "action": "edit-paste"}
        ]
      }
    ]
  }
}
```

### Response
#### Success Response (200)
- **previous_menu** (Option<Menu<R>>) - The previous app-wide menu or None.

#### Response Example
```json
{
  "previous_menu": {
    "items": [
      {
        "title": "File",
        "submenu": [
          {"title": "New", "action": "new-file"}
        ]
      }
    ]
  }
}
```

## DELETE /remove_menu

### Description
Removes the app-wide menu and returns it. If a window was not created with an explicit menu or had one set explicitly, this will remove the menu from it.

### Method
DELETE

### Endpoint
/remove_menu

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **removed_menu** (Option<Menu<R>>) - The removed app-wide menu or None.

#### Response Example
```json
{
  "removed_menu": {
    "items": [
      {
        "title": "Edit",
        "submenu": [
          {"title": "Cut", "action": "edit-cut"},
          {"title": "Copy", "action": "edit-copy"},
          {"title": "Paste", "action": "edit-paste"}
        ]
      }
    ]
  }
}
```

## POST /hide_menu

### Description
Hides the app-wide menu from windows that have it. If a window was not created with an explicit menu or had one set explicitly, this will hide the menu from it.

### Method
POST

### Endpoint
/hide_menu

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
None

#### Response Example
None

## POST /show_menu

### Description
Shows the app-wide menu for windows that have it. If a window was not created with an explicit menu or had one set explicitly, this will show the menu for it.

### Method
POST

### Endpoint
/show_menu

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
None

#### Response Example
None
```

--------------------------------

### OpenOptions Configuration

Source: https://docs.rs/tauri/-plugin-fs/latest/tauri_plugin_fs/struct

Demonstrates how to use the `OpenOptions` struct to configure file opening operations with various settings.

```APIDOC
## `OpenOptions` Struct

### Description

The `OpenOptions` struct provides a way to configure how a file is opened, allowing you to specify read, write, append, truncate, and create behaviors.

### Methods

#### `new()`

*   **Description**: Creates a blank new set of options ready for configuration. All options are initially set to `false`.
*   **Example**: 
    ```rust
    use tauri_plugin_fs::OpenOptions;

    let mut options = OpenOptions::new();
    let file = options.read(true).open("foo.txt");
    ```

#### `read(read: bool)`

*   **Description**: Sets the option for read access. If `true`, the file will be readable.
*   **Example**: 
    ```rust
    use tauri_plugin_fs::OpenOptions;

    let file = OpenOptions::new().read(true).open("foo.txt");
    ```

#### `write(write: bool)`

*   **Description**: Sets the option for write access. If `true`, the file will be writable. If the file exists, writes will overwrite its contents without truncating.
*   **Example**: 
    ```rust
    use tauri_plugin_fs::OpenOptions;

    let file = OpenOptions::new().write(true).open("foo.txt");
    ```

#### `append(append: bool)`

*   **Description**: Sets the option for append mode. If `true`, writes will append to the file instead of overwriting. This guarantees writes are positioned at the end of the file.
*   **Example**: 
    ```rust
    use tauri_plugin_fs::OpenOptions;

    let file = OpenOptions::new().append(true).open("foo.txt");
    ```

#### `truncate(truncate: bool)`

*   **Description**: Sets the option for truncating a file. If `true` and the file exists, it will be truncated to 0 length. Requires write access.
*   **Example**: 
    ```rust
    use tauri_plugin_fs::OpenOptions;

    let file = OpenOptions::new().write(true).truncate(true).open("foo.txt");
    ```

#### `create(create: bool)`

*   **Description**: Sets the option to create a new file or open it if it exists. Requires write or append access.
*   **Example**: 
    ```rust
    use tauri_plugin_fs::OpenOptions;

    let file = OpenOptions::new().write(true).create(true).open("foo.txt");
    ```

#### `create_new(create_new: bool)`

*   **Description**: Sets the option to create a new file, failing if it already exists. This operation is atomic. Requires write or append access. Ignores `create` and `truncate` options.
*   **Example**: 
    ```rust
    use tauri_plugin_fs::OpenOptions;

    let file = OpenOptions::new()
                         .write(true)
                         .create_new(true)
                         .open("foo.txt");
    ```

#### `open(path: &str)`

*   **Description**: Opens a file with the configured options. Returns a `Result` containing a file handle or an error.
*   **Parameters**: 
    *   `path` (string) - Required - The path to the file.
*   **Example**: 
    ```rust
    use tauri_plugin_fs::OpenOptions;

    match OpenOptions::new().read(true).open("my_file.txt") {
        Ok(file) => println!("File opened successfully"),
        Err(e) => eprintln!("Error opening file: {:?}", e),
    }
    ```
```

--------------------------------

### Run Tauri Application with Builder

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Demonstrates how to use the Tauri Builder to create and run a Tauri application. It initializes the builder with default settings and specifies the path to the Tauri configuration file.

```rust
tauri::Builder::default()
  // on an actual app, remove the string argument
  .run(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
 .expect("error while running tauri application");
```

--------------------------------

### Rust: Tauri Window Configuration Settings

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Defines the main configuration for Tauri windows. This includes settings for the window label, whether it should be created at startup, the webview URL, user agent, drag and drop behavior, centering, position, dimensions, and overflow prevention.

```rust
/// The window configuration object.
///
/// See more: <https://v2.tauri.app/reference/config/#windowconfig>
#[skip_serializing_none]
#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct WindowConfig {
  /// The window identifier. It must be alphanumeric.
  #[serde(default = "default_window_label")]
  pub label: String,
  /// Whether Tauri should create this window at app startup or not.
  ///
  /// When this is set to `false` you must manually grab the config object via `app.config().app.windows`
  /// and create it with [`WebviewWindowBuilder::from_config`](https://docs.rs/tauri/2/tauri/webview/struct.WebviewWindowBuilder.html#method.from_config).
  #[serde(default = "default_true")]
  pub create: bool,
  /// The window webview URL.
  #[serde(default)]
  pub url: WebviewUrl,
  /// The user agent for the webview
  #[serde(alias = "user-agent")]
  pub user_agent: Option<String>,
  /// Whether the drag and drop is enabled or not on the webview. By default it is enabled.
  ///
  /// Disabling it is required to use HTML5 drag and drop on the frontend on Windows.
  #[serde(default = "default_true", alias = "drag-drop-enabled")]
  pub drag_drop_enabled: bool,
  /// Whether or not the window starts centered or not.
  #[serde(default)]
  pub center: bool,
  /// The horizontal position of the window's top left corner
  pub x: Option<f64>,
  /// The vertical position of the window's top left corner
  pub y: Option<f64>,
  /// The window width.
  #[serde(default = "default_width")]
  pub width: f64,
  /// The window height.
  #[serde(default = "default_height")]
  pub height: f64,
  /// The min window width.
  #[serde(alias = "min-width")]
  pub min_width: Option<f64>,
  /// The min window height.
  #[serde(alias = "min-height")]
  pub min_height: Option<f64>,
  /// The max window width.
  #[serde(alias = "max-width")]
  pub max_width: Option<f64>,
  /// The max window height.
  #[serde(alias = "max-height")]
  pub max_height: Option<f64>,
  /// Whether or not to prevent the window from overflowing the workarea
  ///
  /// ## Platform-specific
  ///
  /// - **iOS / Android:** Unsupported.
  #[serde(alias = "prevent-overflow")]
  pub prevent_overflow: Option<PreventOverflowConfig>,
}
```

--------------------------------

### Run Tauri Application

Source: https://docs.rs/tauri/2.8.5/tauri/struct

Builds the configured application and runs it. This is a shorthand for calling `Self::build` followed by `App::run`, offering a simpler way to start the application.

```rust
pub fn run(self, context: Context<R>) -> Result<()>
```

--------------------------------

### Rust: Create Default WindowsAttributes

Source: https://docs.rs/tauri/-build/latest/tauri_build/struct

Creates a default set of attributes for Windows builds. This is the starting point for configuring Windows-specific settings.

```rust
let mut windows = tauri_build::WindowsAttributes::new();
```

--------------------------------

### OpenOptions

Source: https://docs.rs/tauri/-plugin-fs/2.4.2/src/tauri_plugin_fs/lib

Configuration options for opening files. Allows specifying read, write, append, create, and other flags.

```APIDOC
## OpenOptions

### Description

Configuration options for opening files. Allows specifying read, write, append, create, and other flags.

### Method

N/A (Struct)

### Endpoint

N/A

### Parameters

#### Path Parameters

None

#### Query Parameters

None

#### Request Body

- **read** (boolean) - Optional, defaults to true. Whether the file should be readable.
- **write** (boolean) - Optional, defaults to false. Whether the file should be writable.
- **append** (boolean) - Optional, defaults to false. Whether writes should append to the file.
- **truncate** (boolean) - Optional, defaults to false. Whether to truncate the file if it exists.
- **create** (boolean) - Optional, defaults to false. Whether to create the file if it does not exist.
- **createNew** (boolean) - Optional, defaults to false. Whether to create the file only if it does not exist.
- **mode** (integer) - Optional. Unix-specific file mode for newly created files.
- **customFlags** (integer) - Optional. Unix-specific custom flags for opening the file.

### Request Example

```json
{
  "read": true,
  "write": false,
  "append": false,
  "truncate": false,
  "create": false,
  "createNew": false,
  "mode": null,
  "customFlags": null
}
```

### Response

#### Success Response (200)

N/A (This is a configuration struct, not an endpoint)

#### Response Example

N/A
```

--------------------------------

### Start Resize Dragging (Tauri/Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/mod

This function initiates resize-dragging of the window in a specified direction. It takes a `tauri_runtime::ResizeDirection` as input. The function returns a `crate::Result<()>` indicating success or failure.

```Rust
pub fn start_resize_dragging(
    &self,
    direction: tauri_runtime::ResizeDirection,
  ) -> crate::Result<()> {
    self
      .window
      .dispatcher
      .start_resize_dragging(direction)
      .map_err(Into::into)
  }
```

--------------------------------

### Get Parsed Host from URL (Rust)

Source: https://docs.rs/tauri/latest/tauri/struct

Illustrates how to get the parsed host of a URL, which can be an IP address or a domain name. Returns None for URLs without a host.

```rust
use url::Url;

let url = Url::parse("https://127.0.0.1/index.html")?;
assert!(url.host().is_some());

let url = Url::parse("ftp://rms@example.com")?;
assert!(url.host().is_some());

let url = Url::parse("unix:/run/foo.socket")?;
assert!(url.host().is_none());

let url = Url::parse("data:text/plain,Stuff")?;
assert!(url.host().is_none());
```

--------------------------------

### Asynchronous RwLock Example in Rust

Source: https://docs.rs/tauri/latest/tauri/async_runtime/struct

Demonstrates the basic usage of an asynchronous RwLock in Rust. It shows how to acquire read and write locks, modify the protected data, and handle concurrent access. This example utilizes the tokio runtime.

```rust
use tokio::sync::RwLock;

#[tokio::main]
async fn main() {
    let lock = RwLock::new(5);

    // many reader locks can be held at once
    {
        let r1 = lock.read().await;
        let r2 = lock.read().await;
        assert_eq!(*r1, 5);
        assert_eq!(*r2, 5);
    } // read locks are dropped at this point

    // only one write lock may be held, however
    {
        let mut w = lock.write().await;
        *w += 1;
        assert_eq!(*w, 6);
    } // write lock is dropped here
}
```

--------------------------------

### Get Cookie Name and Value Tuple in Rust

Source: https://docs.rs/tauri/latest/tauri/webview/struct

Shows how to get both the name and the raw value of a `Cookie` as a tuple of string slices (`(&str, &str)`) using the `name_value()` method.

```rust
use cookie::Cookie;

let c = Cookie::new("name", "value");
assert_eq!(c.name_value(), ("name", "value"));
```

--------------------------------

### Test: Get State Panics - Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/state

Unit test to verify that calling `get` for a type that has not been set results in a panic. This test uses `#[should_panic]` to assert the expected behavior.

```rust
#[test]
#[should_panic(expected = "state not found for type core::option::Option<alloc::string::String>")]
fn get_panics() {
  let state = StateManager::new();
  state.get::<Option<String>>();
}
```

--------------------------------

### AppHandle - Window Management

Source: https://docs.rs/tauri/2.8.4/x86_64-unknown-linux-gnu/tauri/app/struct

APIs for creating and managing Tao windows within the Tauri application.

```APIDOC
## POST /window/create

### Description
Creates a new Tao window using a callback function. The event loop must be running.

### Method
POST

### Endpoint
`/window/create`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **f** (function) - Required - A closure that returns a tuple of (String, TaoWindowBuilder) to configure the new window.

### Request Example
```json
{
  "f": "() -> (\"My Window\", TaoWindowBuilder)"
}
```

### Response
#### Success Response (200)
- **window** (Window) - A weak reference to the newly created window.

#### Response Example
```json
{
  "window": "<window_reference>"
}
```

## POST /window/send_tao_event

### Description
Sends a window message to the event loop for a specific Tao window.

### Method
POST

### Endpoint
`/window/send_tao_event`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **window_id** (TaoWindowId) - Required - The ID of the target window.
- **message** (WindowMessage) - Required - The message to send to the window's event loop.

### Request Example
```json
{
  "window_id": "<window_id>",
  "message": "<window_message>"
}
```

### Response
#### Success Response (200)
- **result** (Result) - Indicates success or failure of sending the message.

#### Response Example
```json
{
  "result": "Ok(())"
}
```
```

--------------------------------

### Webview Management

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

Provides methods for creating and managing webview instances.

```APIDOC
## POST /webview/create

### Description
Creates a new webview associated with a given window.

### Method
POST

### Endpoint
`/webview/create`

### Parameters
#### Request Body
- **window_id** (WindowId) - Required - The ID of the window to associate the webview with.
- **pending** (PendingWebview<T, Self>) - Required - The pending webview configuration.

### Request Example
```json
{
  "window_id": "some-window-id",
  "pending": { ... } 
}
```

### Response
#### Success Response (200)
- **DetachedWebview<T, Self>** - The newly created detached webview.

#### Response Example
```json
{
  "webview": { ... } 
}
```
```

--------------------------------

### ChunkState Start Flag Determination in Rust

Source: https://docs.rs/tauri/-codegen/2.4.0/src/tauri_codegen/vendor/blake3_reference

Determines the appropriate flag to apply for the start of a chunk. If no blocks have been compressed yet (`blocks_compressed == 0`), it returns `CHUNK_START`; otherwise, it returns `0`.

```rust
impl ChunkState {
  fn start_flag(&self) -> u32 {
    if self.blocks_compressed == 0 {
      CHUNK_START
    } else {
      0
    }
  }
}
```

--------------------------------

### Create Default Windows Attributes

Source: https://docs.rs/tauri/-build/2.4.1/tauri_build/struct

Creates a new `WindowsAttributes` instance with default settings for Windows. This is the starting point for customizing Windows-specific build attributes.

```rust
let windows_attrs = tauri_build::WindowsAttributes::new();
```

--------------------------------

### Build Application

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Builds the application with the configured settings and context. This is typically the final step before running the application.

```APIDOC
## POST /build

### Description
Builds the application with the configured settings and context. This is typically the final step before running the application.

### Method
POST

### Endpoint
`/build`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **context** (Context) - Required - The application context, including configuration and setup details.

### Request Example
```json
{
  "context": { /* ... application context details ... */ }
}
```

### Response
#### Success Response (200)
- **app** (App) - The built application instance.

#### Response Example
```json
{
  "app": { /* ... application instance details ... */ }
}
```
```

--------------------------------

### Get Resource Name (Rust)

Source: https://docs.rs/tauri/2.8.5/tauri/image/struct

Implements the `Resource` trait for `Image`, providing a method to get a string representation of the resource. The default implementation returns the Rust type name.

```rust
fn name(&self) -> Cow<'_, str>
```

--------------------------------

### Rust Result::copied Implementation Example

Source: https://docs.rs/tauri/-build/latest/tauri_build/type

Example demonstrating the `copied` method on a `Result<&T, E>` where `T` implements `Copy`. This method maps the `Result` by copying the value inside `Ok` if it exists, transforming `Result<&T, E>` to `Result<T, E>`.

```rust
let val = 12;
let x: Result<&i32, i32> = Ok(&val);
assert_eq!(x, Ok(&12));
let copied = x.copied();
assert_eq!(copied, Ok(12));

```

--------------------------------

### Get Cursor Position

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Gets the cursor position relative to the top-left corner of the desktop. The coordinates can be negative if the window is outside the visible screen. This function is part of the desktop window API.

```rust
/// Get the cursor position relative to the top-left hand corner of the desktop.
///
/// Note that the top-left hand corner of the desktop is not necessarily the same as the screen.
/// If the user uses a desktop with multiple monitors,
/// the top-left hand corner of the desktop is the top-left hand corner of the main monitor on Windows and macOS
/// or the top-left of the leftmost monitor on X11.
///
/// The coordinates can be negative if the top-left hand corner of the window is outside of the visible screen region.
pub fn cursor_position(&self) -> crate::Result<PhysicalPosition<f64>> {
  self.webview.cursor_position()
}
```

--------------------------------

### Rust Result::cloned Implementation Example

Source: https://docs.rs/tauri/-build/latest/tauri_build/type

Example showcasing the `cloned` method on a `Result<&T, E>` where `T` implements `Clone`. This method maps the `Result` by cloning the value inside `Ok` if it exists, converting `Result<&T, E>` to `Result<T, E>`.

```rust
let val = 12;
let x: Result<&i32, i32> = Ok(&val);
assert_eq!(x, Ok(&12));
let cloned = x.cloned();
assert_eq!(cloned, Ok(12));

```

--------------------------------

### Example: Modifying Webview Zoom and Styles Cross-Platform

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Demonstrates how to use `with_webview` to execute platform-specific code for modifying webview behavior. Examples include setting zoom levels, clearing user scripts, and changing background colors on Linux, Windows, macOS, and Android.

```rust
tauri::Builder::default()
  .setup(|app| {
    let main_webview = app.get_webview("main").unwrap();
    main_webview.with_webview(|webview| {
      #[cfg(target_os = "linux")]
      {
        use webkit2gtk::WebViewExt;
        webview.inner().set_zoom_level(4.);
      }

      #[cfg(windows)]
      unsafe {
        webview.controller().SetZoomFactor(4.).unwrap();
      }

      #[cfg(target_os = "macos")]
      unsafe {
        let view: &objc2_web_kit::WKWebView = &*webview.inner().cast();
        let controller: &objc2_web_kit::WKUserContentController = &*webview.controller().cast();
        let window: &objc2_app_kit::NSWindow = &*webview.ns_window().cast();

        view.setPageZoom(4.);
        controller.removeAllUserScripts();
        let bg_color = objc2_app_kit::NSColor::colorWithDeviceRed_green_blue_alpha(0.5, 0.2, 0.4, 1.);
        window.setBackgroundColor(Some(&bg_color));
      }

      #[cfg(target_os = "android")]
      {
        use jni::objects::JValue;
        webview.jni_handle().exec(|env, _, webview| {
          env.call_method(webview, "zoomBy", "(F)V", &[JValue::Float(4.)]).unwrap();
        })
      }
    });
    Ok(())
});

```

--------------------------------

### Define Wix Installer Configuration

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Defines the main WixConfig structure for Tauri's MSI installer generation. It includes fields for version, upgrade code, language settings, custom templates, WiX fragments, component/feature references, elevated update tasks, and UI image paths. It also supports FIPS compliance.

```rust
/// Configuration for the MSI bundle using WiX.
///
/// See more: <https://v2.tauri.app/reference/config/#wixconfig>
#[derive(Debug, Default, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct WixConfig {
  /// MSI installer version in the format `major.minor.patch.build` (build is optional).
  ///
  /// Because a valid version is required for MSI installer, it will be derived from [`Config::version`] if this field is not set.
  ///
  /// The first field is the major version and has a maximum value of 255. The second field is the minor version and has a maximum value of 255.
  /// The third and foruth fields have a maximum value of 65,535.
  ///
  /// See <https://learn.microsoft.com/en-us/windows/win32/msi/productversion> for more info.
  pub version: Option<String>,
  /// A GUID upgrade code for MSI installer. This code **_must stay the same across all of your updates_**,
  /// otherwise, Windows will treat your update as a different app and your users will have duplicate versions of your app.
  ///
  /// By default, tauri generates this code by generating a Uuid v5 using the string `<productName>.exe.app.x64` in the DNS namespace.
  /// You can use Tauri's CLI to generate and print this code for you, run `tauri inspect wix-upgrade-code`.
  ///
  /// It is recommended that you set this value in your tauri config file to avoid accidental changes in your upgrade code
  /// whenever you want to change your product name.
  #[serde(alias = "upgrade-code")]
  pub upgrade_code: Option<uuid::Uuid>,
  /// The installer languages to build. See <https://docs.microsoft.com/en-us/windows/win32/msi/localizing-the-error-and-actiontext-tables>.
  #[serde(default)]
  pub language: WixLanguage,
  /// A custom .wxs template to use.
  pub template: Option<PathBuf>,
  /// A list of paths to .wxs files with WiX fragments to use.
  #[serde(default, alias = "fragment-paths")]
  pub fragment_paths: Vec<PathBuf>,
  /// The ComponentGroup element ids you want to reference from the fragments.
  #[serde(default, alias = "component-group-refs")]
  pub component_group_refs: Vec<String>,
  /// The Component element ids you want to reference from the fragments.
  #[serde(default, alias = "component-refs")]
  pub component_refs: Vec<String>,
  /// The FeatureGroup element ids you want to reference from the fragments.
  #[serde(default, alias = "feature-group-refs")]
  pub feature_group_refs: Vec<String>,
  /// The Feature element ids you want to reference from the fragments.
  #[serde(default, alias = "feature-refs")]
  pub feature_refs: Vec<String>,
  /// The Merge element ids you want to reference from the fragments.
  #[serde(default, alias = "merge-refs")]
  pub merge_refs: Vec<String>,
  /// Create an elevated update task within Windows Task Scheduler.
  #[serde(default, alias = "enable-elevated-update-task")]
  pub enable_elevated_update_task: bool,
  /// Path to a bitmap file to use as the installation user interface banner.
  /// This bitmap will appear at the top of all but the first page of the installer.
  ///
  /// The required dimensions are 493px  58px.
  #[serde(alias = "banner-path")]
  pub banner_path: Option<PathBuf>,
  /// Path to a bitmap file to use on the installation user interface dialogs.
  /// It is used on the welcome and completion dialogs.
  ///
  /// The required dimensions are 493px  312px.
  #[serde(alias = "dialog-image-path")]
  pub dialog_image_path: Option<PathBuf>,
  /// Enables FIPS compliant algorithms.
  /// Can also be enabled via the `TAURI_BUNDLER_WIX_FIPS_COMPLIANT` env var.
  #[serde(default, alias = "fips-compliant")]
  pub fips_compliant: bool,
}
```

--------------------------------

### Create Multi-Instance Window from Config - Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

This example shows how to create multiple instances of a window based on a configuration from `tauri.conf.json`. It involves cloning a window configuration, modifying its label to ensure uniqueness, and then using `WebviewWindowBuilder::from_config` to build the new window. This is essential for scenarios requiring multiple identical windows with distinct identities.

```rust
#[tauri::command]
async fn open_window_multiple(app: tauri::AppHandle) {
  let mut conf = app.config().app.windows.iter().find(|c| c.label == "template-for-multiwindow").unwrap().clone();
  // This should be a unique label for all windows. For example, we can use a random suffix:

```

--------------------------------

### Create Webview Window from Config (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Initializes a `WebviewWindowBuilder` from a `WindowConfig` structure, typically loaded from `tauri.conf.json`. This allows for pre-defined window configurations. A key consideration is ensuring unique labels if multiple windows are created from the same base configuration.

```rust
pub fn from_config<R: Runtime, M: Manager<R>>(
  manager: &'a M,
  config: &'a WindowConfig,
) -> Result<Self, Box<dyn Error>> {
  let mut window_builder = WindowBuilder::new(manager, &config.label);
  let mut webview_builder = WebviewBuilder::new(&config.label, config.url.clone().into());

  #[cfg(desktop)]
  {
    window_builder
      .set_title(&config.title)
      .set_url(config.url.clone())
      .set_width(config.width)
      .set_height(config.height)
      .set_resizable(config.resizable)
      .set_fullscreen(config.fullscreen)
      .set_decorations(config.decorations)
      .set_always_on_top(config.always_on_top)
      .set_transparent(config.transparent)
      .set_background_color(config.background_color.clone())
      .set_user_ _type(config.user_ _type)
      .set_closable(config.closable)
      .set_title_bar_style(config.title_bar_style)
      .set_accept_first_mouse(config.accept_first_mouse)
      .set_center(config.center)
      .set_min_width(config.min_width)
      .set_min_height(config.min_height)
      .set_max_width(config.max_width)
      .set_max_height(config.max_height)
      .set_theme(config.theme)
      .set_focus_on_creation(config.focus);
    webview_builder
      .set_user_agent(config.user_agent.clone())
      .set_accept_first_mouse(config.accept_first_mouse)
      .set_background_color(config.background_color.clone());
  }

  Ok(Self { window_builder, webview_builder })
}
```

--------------------------------

### Open DevTools in Tauri Application (Rust Example)

Source: https://docs.rs/tauri/latest/src/tauri/webview/mod

Provides an example of how to open the developer tools for a specific webview within a Tauri application. This functionality is typically enabled only in debug builds or when the `devtools` feature flag is active. Note platform-specific limitations and deprecation warnings.

```rust
use tauri::Manager;
tauri::Builder::default()
  .setup(|app| {
    #[cfg(debug_assertions)]
    app.get_webview("main").unwrap().open_devtools();
    Ok(())
  });
```
```

--------------------------------

### Tauri Example: Device Event Filter Configuration (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

An example demonstrating how to set the device event filter for a Tauri application using the `device_event_filter` method. This snippet shows the typical builder pattern usage in Rust for configuring application-wide settings.

```rust
tauri::Builder::default()
  .device_event_filter(tauri::DeviceEventFilter::Always);
```

--------------------------------

### Tauri App Setup Hook Definition

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Defines a type alias for `SetupHook`, a closure that runs once when the Tauri application is initializing. It takes a mutable reference to the `App` and returns a `Result` indicating success or failure.

```rust
/// A closure that is run when the Tauri application is setting up.
pub type SetupHook<R> = 
  Box<dyn FnOnce(&mut App<R>) -> std::result::Result<(), Box<dyn std::error::Error>> + Send>;

```

--------------------------------

### Get All Webviews

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Retrieves a map of all currently managed webviews.

```APIDOC
## GET /webviews

### Description
Fetches all managed webviews.

*   **Stability**: Requires the `unstable` feature.

### Method
GET

### Endpoint
/webviews

### Parameters
None

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **HashMap<String, Webview<R>>** (object) - A map where keys are webview labels and values are Webview objects.

#### Response Example
```json
{
  "main-webview": {
    "label": "main-webview",
    "url": "https://example.com"
  }
}
```
```

--------------------------------

### Get URL as String Reference (Rust)

Source: https://docs.rs/tauri/latest/tauri/struct

Implements the `AsRef<str>` trait for `Url`, allowing it to be treated as a string slice. This provides a way to get the serialized string representation of the URL.

```Rust
use url::Url;

// Assuming `url` is an instance of Url
// let url_str: &str = url.as_ref();
```

--------------------------------

### Create Webview Runtime (Any Thread)

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

Allows creating a webview runtime on any thread, useful for non-main thread initializations. It takes `RuntimeInitArgs` which may contain platform-specific configurations like `msg_hook` on Windows. Returns a Result with the runtime instance or an error.

```rust
#[cfg(any(windows, target_os = "linux"))]
#[cfg_attr(docsrs, doc(cfg(any(windows, target_os = "linux"))))]
fn new_any_thread(args: RuntimeInitArgs) -> Result<Self>;
```

--------------------------------

### Tauri Plugin Builder Initialization and Configuration

Source: https://docs.rs/tauri/-plugin/2.4.0/tauri_plugin/struct

Demonstrates how to initialize and configure a Tauri plugin using the `Builder` struct in Rust. This includes setting commands, global scope schema, API script paths, and platform-specific paths. The `build` and `try_build` methods are used to finalize the plugin setup.

```rust
pub struct Builder<'a> { /* private fields */ }

impl<'a> Builder<'a> {
    pub fn new(commands: &'a [&'static str]) -> Self
    pub fn global_scope_schema(self, schema: RootSchema) -> Self
    pub fn global_api_script_path<P: Into<PathBuf>>(self, path: P) -> Self
    pub fn android_path<P: Into<PathBuf>>(self, android_path: P) -> Self
    pub fn ios_path<P: Into<PathBuf>>(self, ios_path: P) -> Self
    pub fn build(self)
    pub fn try_build(self) -> Result<()>
}
```

--------------------------------

### Build Tauri Application with Context (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Initiates the building process for a Tauri application, taking a `Context` object. This function handles platform-specific configurations, such as setting up the default menu on macOS and configuring runtime arguments for different operating systems. It returns a `Result<App<R>>`.

```rust
pub fn build(mut self, context: Context<R>) -> crate::Result<App<R>> {
  #[cfg(target_os = "macos")]
  if self.menu.is_none() && self.enable_macos_default_menu {
    self.menu = Some(Box::new(|app_handle| {
      crate::menu::Menu::default(app_handle)
    }));
  }

  let manager = Arc::new(AppManager::with_handlers(
    context,
    self.plugins,
    self.invoke_handler,
    self.on_page_load,
    self.uri_scheme_protocols,
    self.state,
    #[cfg(desktop)]
    self.menu_event_listeners,
    #[cfg(all(desktop, feature = "tray-icon"))]
    self.tray_icon_event_listeners,
    self.window_event_listeners,
    self.webview_event_listeners,
    #[cfg(desktop)]
    HashMap::new(),
    self.invoke_initialization_script,
    self.channel_interceptor,
    self.invoke_key,
  ));

  #[cfg(any(
    target_os = "linux",
    target_os = "dragonfly",
    target_os = "freebsd",
    target_os = "netbsd",
    target_os = "openbsd"
  ))]
  let app_id = if manager.config.app.enable_gtk_app_id {
    Some(manager.config.identifier.clone())
  } else {
    None
  };

  let runtime_args = RuntimeInitArgs {
    #[cfg(any(
      target_os = "linux",
      target_os = "dragonfly",
      target_os = "freebsd",
      target_os = "netbsd",
      target_os = "openbsd"
    ))]
    app_id,

    #[cfg(windows)]
    msg_hook: {
      let menus = manager.menu.menus.clone();
      Some(Box::new(move |msg| {
        use windows::Win32::UI::WindowsAndMessaging::{TranslateAcceleratorW, HACCEL, MSG};
        unsafe {
          let msg = msg as *const MSG;
          for menu in menus.lock().unwrap().values() {
            let translated =
              TranslateAcceleratorW((*msg).hwnd, HACCEL(menu.inner().haccel() as _), msg);
            if translated == 1 {
              return true;
            }
          }

          false
        }
      }))
    },
  };

  // The env var must be set before the Runtime is created so that GetAvailableBrowserVersionString picks it up.
  #[cfg(windows)]
  {
    if let crate::utils::config::WebviewInstallMode::FixedRuntime { path } =
      &manager.config.bundle.windows.webview_install_mode
    {
      if let Some(exe_dir) = crate::utils::platform::current_exe()
        .ok()
        .and_then(|p| p.parent().map(|p| p.to_path_buf()))

```

--------------------------------

### Tauri Plugin Library Setup (Rust)

Source: https://docs.rs/tauri/-plugin/2.4.0/src/tauri_plugin/lib

This Rust code snippet sets up the basic structure for a Tauri plugin. It includes copyright information, license identifiers, and conditional compilation features like 'build' and 'runtime'. It also configures documentation settings for the Rust documentation generator.

```Rust
1// Copyright 2019-2024 Tauri Programme within The Commons Conservancy
2// SPDX-License-Identifier: Apache-2.0
3// SPDX-License-Identifier: MIT
4
5//! Interface for building Tauri plugins.
6
7#![doc(
8  html_logo_url = "https://github.com/tauri-apps/tauri/raw/dev/.github/icon.png",
9  html_favicon_url = "https://github.com/tauri-apps/tauri/raw/dev/.github/icon.png"
10)]
11#![cfg_attr(docsrs, feature(doc_cfg))]
12
13#[cfg(feature = "build")]
14mod build;
15#[cfg(feature = "runtime")]
16mod runtime;
17
18#[cfg(feature = "build")]
19#[cfg_attr(docsrs, doc(feature = "build"))]
20pub use build::*;
21#[cfg(feature = "runtime")]
22#[cfg_attr(docsrs, doc(feature = "runtime"))]
23#[allow(unused)]
24pub use runtime::*;
```

--------------------------------

### Rust Result Sum Example

Source: https://docs.rs/tauri/-build/latest/tauri_build/type

An example illustrating the `Sum` trait implementation for `Result`. It sums integers from a vector, returning an `Err` if a negative element is encountered, demonstrating error short-circuiting during aggregation.

```rust
let f = |&x: &i32| if x < 0 { Err("Negative element found") } else { Ok(x) };
let v = vec![1, 2];
let res: Result<i32, _> = v.iter().map(f).sum();
assert_eq!(res, Ok(3));
let v = vec![1, -2];
let res: Result<i32, _> = v.iter().map(f).sum();
assert_eq!(res, Err("Negative element found"))
```

--------------------------------

### Rust: Example ScopeObjectMatch Implementation

Source: https://docs.rs/tauri/2.8.5/src/tauri/ipc/authority

Demonstrates how to implement the `ScopeObjectMatch` trait for a custom `Scope` enum. This example shows matching against `Url` domains and string prefixes, providing a concrete illustration of defining validation logic for scopes.

```rust
# use serde::{Deserialize, Serialize};
# use tauri::{ipc::ScopeObjectMatch, Url};
#
# #[derive(Debug, Clone, Serialize, Deserialize)]
# #[serde(rename_all = "camelCase")]
# pub enum Scope {
#   Domain(Url),
#   StartsWith(String),
# }
#
# impl ScopeObjectMatch for Scope {
#   type Input = str;
#
#   fn matches(&self, input: &str) -> bool {
#     match self {
#       Scope::Domain(url) => {
#         let parsed: Url = match input.parse() {
#           Ok(parsed) => parsed,
#           Err(_) => return false,
#         };
#
#         let domain = parsed.domain();
#
#         domain.is_some() && domain == url.domain()
#       }
#       Scope::StartsWith(start) => input.starts_with(start),
#     }
#   }
# }

```

--------------------------------

### Unlisten from Webview Event (Rust Example)

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Removes a previously registered event listener from a webview. This example shows how to unlisten using the event ID returned by `listen` or `once`, ensuring that the handler is no longer called.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let webview = app.get_webview("main").unwrap();
    let webview_ = webview.clone();
    let handler = webview.listen("component-loaded", move |event| {
      println!("webview just loaded a component");

      // we no longer need to listen to the event
      // we also could have used `webview.once` instead
      webview_.unlisten(event.id());
    });

    // stop listening to the event when you do not need it anymore
    webview.unlisten(handler);

    Ok(())
  });

```

--------------------------------

### Window Fullscreen Configuration

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Sets whether the window should start in fullscreen mode.

```APIDOC
## POST /window/config/fullscreen

### Description
Sets whether the window should start in fullscreen mode.

### Method
POST

### Endpoint
/window/config/fullscreen

### Parameters
#### Query Parameters
- **fullscreen** (boolean) - Required - Whether the window should be in fullscreen mode.

### Request Body
```json
{
  "fullscreen": true
}
```

### Response
#### Success Response (200)
- **success** (boolean) - Indicates if the operation was successful.

#### Response Example
```json
{
  "success": true
}
```
```

--------------------------------

### Get Expiration Datetime of a Cookie (Rust)

Source: https://docs.rs/tauri/latest/tauri/webview/struct

Retrieves the specific expiration datetime of a cookie, if set. This is a more precise way to get the expiration compared to the `expires()` method. Returns None if no specific datetime is set.

```rust
use cookie::Cookie;

let c = Cookie::parse("name=value").unwrap();
assert_eq!(c.expires_datetime(), None);

// Here, `cookie.expires()` returns `Some`.
let c = Cookie::build(("name", "value")).expires(None).build();
assert_eq!(c.expires_datetime(), None);

let expire_time = "Wed, 21 Oct 2017 07:28:00 GMT";
let cookie_str = format!("name=value; Expires={}", expire_time);
let c = Cookie::parse(cookie_str).unwrap();
assert_eq!(c.expires_datetime().map(|t| t.year()), Some(2017));
```

--------------------------------

### Get Application Configuration (Rust)

Source: https://docs.rs/tauri/2.8.4/x86_64-unknown-linux-gnu/tauri/app/struct

Retrieves a reference to the application's configuration, which is defined in the `tauri.conf.json` file. This provides access to settings like the app name, version, and other metadata.

```rust
pub fn config(&self) -> &Config
```

--------------------------------

### Test: Simple Set and Get State - Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/state

Unit test for the basic functionality of setting and then getting a primitive type (u32) from the state manager. Asserts that the retrieved value matches the set value.

```rust
#[test]
fn simple_set_get() {
  let state = StateManager::new();
  assert!(state.set(1u32));
  assert_eq!(*state.get::<u32>(), 1);
}
```

--------------------------------

### Prepare Webview Configuration in Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/manager/webview

Prepares a `PendingWebview` configuration, checking for label conflicts and setting up necessary handlers and protocols. It determines the initial URL, potentially using a proxy development server for local network URLs.

```rust
pub fn prepare_webview<M: Manager<R>>(
    &self,
    manager: &M,
    mut pending: PendingWebview<EventLoopMessage, R>,
    window_label: &str,
  ) -> crate::Result<PendingWebview<EventLoopMessage, R>> {
    if self.webviews_lock().contains_key(&pending.label) {
      return Err(crate::Error::WebviewLabelAlreadyExists(pending.label));
    }

    let app_manager = manager.manager();

    #[allow(unused_mut)] // mut url only for the data-url parsing
    let mut url = match &pending.webview_attributes.url {
      WebviewUrl::App(path) => {
        let app_url = app_manager.get_url(pending.webview_attributes.use_https_scheme);
        let url = if PROXY_DEV_SERVER && is_local_network_url(&app_url) {
          Cow::Owned(Url::parse("tauri://localhost").unwrap())
        } else {
          app_url
        };
        // ignore "index.html" just to simplify the url
        if path.to_str() != Some("index.html") {
          url
        }
      }
      // ... other url match arms
    };
    // ... rest of the function
    Ok(pending)
  }
```

--------------------------------

### Define Tauri Commands with State

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

This example demonstrates how to define tauri commands that utilize managed state. `MyInt` and `MyString` are examples of stateful data that can be passed to commands using `tauri::State`. The `invoke_handler` registers these commands.

```rust
use tauri::State;

struct MyInt(isize);
struct MyString(String);

#[tauri::command]
fn int_command(state: State<MyInt>) -> String {
    format!("The stateful int is: {}", state.0)
}

#[tauri::command]
fn string_command<'r>(state: State<'r, MyString>) {
    println!("state: {}", state.inner().0);
}

tauri::Builder::default()
  .manage(MyInt(10))
  .manage(MyString("Hello, managed state!".to_string()))
  .invoke_handler(tauri::generate_handler![int_command, string_command])
  // on an actual app, remove the string argument
  .run(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
  .expect("error while running tauri application");
```

--------------------------------

### Window Ready Handling

Source: https://docs.rs/tauri/2.8.5/tauri/plugin/struct

Sets a callback to be executed once the application window has been created and is ready.

```APIDOC
## POST /plugin/on_window_ready

### Description
Callback invoked when the window is created.

### Method
POST

### Endpoint
/plugin/on_window_ready

### Parameters
#### Request Body
- **on_window_ready** (function) - Required - A callback function that receives the created `Window` object.

### Request Example
```json
{
  "on_window_ready": "function(window) { console.log(`Window created: ${window.label()}`); }"
}
```

### Response
#### Success Response (200)
- **message** (string) - Indicates the window ready handler has been set.

#### Response Example
```json
{
  "message": "Window ready handler set."
}
```
```

--------------------------------

### Window Builder

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Initializes a window builder with the given window label. Data URLs are only supported with the `webview-data-url` feature flag.

```APIDOC
## Window Builder

### Description
Initializes a window builder with the given window label. Data URLs are only supported with the `webview-data-url` feature flag.

### Method
`POST` (or similar, depending on framework)

### Endpoint
`/websites/rs-tauri/builder`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **label** (string) - Required - The label for the new window.

### Request Example
```json
{
  "label": "my-window"
}
```

### Response
#### Success Response (200)
- **WindowBuilder** - A builder object for creating a new window.

#### Response Example
(Output depends on the WindowBuilder object structure)
```

--------------------------------

### Define Wix Language Configuration

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Defines the structure for Wix language configuration, allowing localization paths for installer languages. It supports mapping language identifiers to their respective locale file paths. This structure is crucial for building multi-language installers.

```rust
#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct WixLanguageConfig {
  /// The path to a locale (`.wxl`) file. See <https://wixtoolset.org/documentation/manual/v3/howtos/ui_and_localization/build_a_localized_version.html>.
  #[serde(alias = "locale-path")]
  pub locale_path: Option<String>,
}
```

--------------------------------

### Setup Build Configuration (Rust)

Source: https://docs.rs/tauri/-plugin/2.4.0/src/tauri_plugin/build/mobile

Configures build aliases for 'mobile' and 'desktop' based on the target operating system. It also handles copying necessary Tauri library files for Android and iOS plugins, setting environment variables for the build process. Requires specific environment variables like `CARGO_CFG_TARGET_OS` and dependency paths.

```Rust
pub(crate) fn setup(
  android_path: Option<PathBuf>,
  #[allow(unused_variables)] ios_path: Option<PathBuf>,
) -> Result<()> {
  let target_os = build_var("CARGO_CFG_TARGET_OS")?;
  let mobile = target_os == "android" || target_os == "ios";
  cfg_alias("mobile", mobile);
  cfg_alias("desktop", !mobile);

  match target_os.as_str() {
    "android" => {
      if let Some(path) = android_path {
        let manifest_dir = build_var("CARGO_MANIFEST_DIR").map(PathBuf::from)?;
        let source = manifest_dir.join(path);

        let tauri_library_path = std::env::var("DEP_TAURI_ANDROID_LIBRARY_PATH")
            .expect("missing `DEP_TAURI_ANDROID_LIBRARY_PATH` environment variable. Make sure `tauri` is a dependency of the plugin.");
        println!("cargo:rerun-if-env-changed=DEP_TAURI_ANDROID_LIBRARY_PATH");

        create_dir_all(source.join(".tauri")).context("failed to create .tauri directory")?;
        copy_folder(
          Path::new(&tauri_library_path),
          &source.join(".tauri").join("tauri-api"),
          &[],
        )
        .context("failed to copy tauri-api to the plugin project")?;

        println!("cargo:android_library_path={}", source.display());
      }
    }
    #[cfg(target_os = "macos")]
    "ios" => {
      if let Some(path) = ios_path {
        let manifest_dir = std::env::var("CARGO_MANIFEST_DIR")
          .map(PathBuf::from)
          .unwrap();
        let tauri_library_path = std::env::var("DEP_TAURI_IOS_LIBRARY_PATH")
            .expect("missing `DEP_TAURI_IOS_LIBRARY_PATH` environment variable. Make sure `tauri` is a dependency of the plugin.");

        let tauri_dep_path = path.parent().unwrap().join(".tauri");
        create_dir_all(&tauri_dep_path).context("failed to create .tauri directory")?;
        copy_folder(
          Path::new(&tauri_library_path),
          &tauri_dep_path.join("tauri-api"),
          &[".build", "Package.resolved", "Tests"],
        )
        .context("failed to copy tauri-api to the plugin project")?;
        tauri_utils::build::link_apple_library(
          &std::env::var("CARGO_PKG_NAME").unwrap(),
          manifest_dir.join(path),
        );
      }
    }
    _ => (),
  }

  Ok(())
}
```

--------------------------------

### Example: Set Windows Resource Language

Source: https://docs.rs/tauri/-winres/0.3.3/src/tauri_winres/lib

Demonstrates how to set the language for Windows resources using `tauri_winres`. It specifically sets the language to US English by combining `LANG_ENGLISH` and `SUBLANG_ENGLISH_US`. This example is conditional on the target OS being Windows.

```rust
fn main() {
    if cfg!(target_os = "windows") {
      let mut res = tauri_winres::WindowsResource::new();
    res.set_output_directory(".");
      res.set_language(winapi::um::winnt::MAKELANGID(
          winapi::um::winnt::LANG_ENGLISH,
          winapi::um::winnt::SUBLANG_ENGLISH_US
      ));
      res.compile().unwrap();
    }
  }
```

--------------------------------

### Rust: Try Build with Platform Configuration and Resource Copying

Source: https://docs.rs/tauri/-build/2.4.1/src/tauri_build/lib

This function attempts to build the Tauri application without panicking, returning a `Result`. It reads environment variables to determine the target OS and triple, configures platform-specific aliases, parses the `tauri.conf.json` file, and handles merging configurations from the `TAURI_CONFIG` environment variable. It also manages the copying of external binaries and resources based on the parsed configuration and target platform.

```rust
pub fn try_build(attributes: Attributes) -> Result<()> {
  use anyhow::anyhow;

  println!("cargo:rerun-if-env-changed=TAURI_CONFIG");

  let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap();
  let mobile = target_os == "ios" || target_os == "android";
  cfg_alias("desktop", !mobile);
  cfg_alias("mobile", mobile);

  let target_triple = env::var("TARGET").unwrap();
  let target = tauri_utils::platform::Target::from_triple(&target_triple);

  let (mut config, config_paths) = 
    tauri_utils::config::parse::read_from(target, &env::current_dir().unwrap())?;
  for config_file_path in config_paths {
    println!("cargo:rerun-if-changed={}", config_file_path.display());
  }
  if let Ok(env) = env::var("TAURI_CONFIG") {
    let merge_config: serde_json::Value = serde_json::from_str(&env)?;
    json_patch::merge(&mut config, &merge_config);
  }
  let config: Config = serde_json::from_value(config)?;

  let s = config.identifier.split('.');
  let last = s.clone().count() - 1;
  let mut android_package_prefix = String::new();
  for (i, w) in s.enumerate() {
    if i == last {
      println!(
        "cargo:rustc-env=TAURI_ANDROID_PACKAGE_NAME_APP_NAME={}",
        w.replace('-', "_")
      );
    } else {
      android_package_prefix.push_str(&w.replace(['_', '-'], "_1"));
      android_package_prefix.push('_');
    }
  }
  android_package_prefix.pop();
  println!("cargo:rustc-env=TAURI_ANDROID_PACKAGE_NAME_PREFIX={android_package_prefix}");

  if let Some(project_dir) = env::var_os("TAURI_ANDROID_PROJECT_PATH").map(PathBuf::from) {
    mobile::generate_gradle_files(project_dir, &config)?;
  }

  cfg_alias("dev", is_dev());

  let cargo_toml_path = Path::new("Cargo.toml").canonicalize()?;
  let mut manifest = Manifest::<cargo_toml::Value>::from_path_with_metadata(cargo_toml_path)?;

  let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

  manifest::check(&config, &mut manifest)?;

  acl::build(&out_dir, target, &attributes)?;

  tauri_utils::plugin::save_global_api_scripts_paths(&out_dir, None);

  println!("cargo:rustc-env=TAURI_ENV_TARGET_TRIPLE={target_triple}");
  env::set_var("TAURI_ENV_TARGET_TRIPLE", &target_triple);

  let target_dir = out_dir
    .parent()
    .unwrap()
    .parent()
    .unwrap()
    .parent()
    .unwrap();

  if let Some(paths) = &config.bundle.external_bin {
    copy_binaries(
      ResourcePaths::new(&external_binaries(paths, &target_triple, &target), true),
      &target_triple,
      target_dir,
      manifest.package.as_ref().map(|p| &p.name),
    )?;
  }

  #[allow(unused_mut, clippy::redundant_clone)]
  let mut resources = config
    .bundle
    .resources
    .clone()
    .unwrap_or_else(|| BundleResources::List(Vec::new()));
  if target_triple.contains("windows") {
    if let Some(fixed_webview2_runtime_path) = match &config.bundle.windows.webview_install_mode {
      WebviewInstallMode::FixedRuntime { path } => Some(path),
      _ => None,
    } {
      resources.push(fixed_webview2_runtime_path.display().to_string());
    }
  }
  match resources {
    BundleResources::List(res) => {
      copy_resources(ResourcePaths::new(res.as_slice(), true), target_dir)?
    }
    BundleResources::Map(map) => copy_resources(ResourcePaths::from_map(&map, true), target_dir)?,
  }

  if target_triple.contains("darwin") {
    if let Some(frameworks) = &config.bundle.macos.frameworks {
      if !frameworks.is_empty() {

```

--------------------------------

### BLAKE3 Initialization Example in Rust

Source: https://docs.rs/tauri/-codegen/2.4.0/src/tauri_codegen/vendor/blake3_reference

Demonstrates how to initialize and use the BLAKE3 hasher to compute a hash of input data. It shows updating the hasher with data and finalizing the hash.

```rust
let mut hasher = tauri_codegen::vendor::blake3_reference::Hasher::new();
hasher.update(b"abc");
hasher.update(b"def");
let mut hash = [0; 32];
hasher.finalize(&mut hash);
let mut extended_hash = [0; 500];
hasher.finalize(&mut extended_hash);
assert_eq!(hash, extended_hash[..32]);

```

--------------------------------

### Async Iterator API (Rust)

Source: https://docs.rs/tauri/-runtime/2.8.0/tauri_runtime/webview/type

Provides the core interface for asynchronous iteration. Includes methods to get item type, poll for the next item, and get size hints. This is a nightly-only experimental API.

```rust
type Item = <S as AsyncIterator>::Item

fn poll_next(
    self: Pin<&mut Box<S>>,
    cx: &mut Context<'_>,
) -> Poll<Option<<Box<S> as AsyncIterator>::Item>>

fn size_hint(&self) -> (usize, Option<usize>)
```

--------------------------------

### Tauri Window Creation and Configuration (Rust)

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

Handles the creation of a Tauri window, applying size constraints based on the monitor's work area and user-defined margins. It also manages window centering and integrates webview components.

```rust
if result.is_ok() {
          shadow_width = (rect.right - rect.left) as u32;
          // rect.bottom is made out of shadow, and we don't care about it
          window_size.height += -rect.top as u32;
        }
      }

      if let Some(margin) = window_builder.prevent_overflow {
        let work_area = monitor.work_area();
        let margin = margin.to_physical::<u32>(scale_factor);
        let constraint = PhysicalSize::new(
          work_area.size.width - margin.width,
          work_area.size.height - margin.height,
        );
        if window_size.width > constraint.width || window_size.height > constraint.height {
          if window_size.width > constraint.width {
            inner_size.width = inner_size
              .width
              .saturating_sub(window_size.width - constraint.width);
            window_size.width = constraint.width;
          }
          if window_size.height > constraint.height {
            inner_size.height = inner_size
              .height
              .saturating_sub(window_size.height - constraint.height);
            window_size.height = constraint.height;
          }
          window_builder.inner.window.inner_size = Some(inner_size.into());
        }
      }

      if window_builder.center {
        window_size.width += shadow_width;
        let position = window::calculate_window_center_position(window_size, monitor);
        let logical_position = position.to_logical::<f64>(scale_factor);
        window_builder = window_builder.position(logical_position.x, logical_position.y);
      }
    }
  };

  let window = window_builder
    .inner
    .build(event_loop)
    .map_err(|_| Error::CreateWindow)?;

  #[cfg(feature = "tracing")]
  {
    drop(window_create_span);

    context
      .main_thread
      .active_tracing_spans
      .0
      .borrow_mut()
      .push(ActiveTracingSpan::WindowDraw {
        id: window.id(),
        span: window_draw_span,
      });
  }

  context.window_id_map.insert(window.id(), window_id);

  if let Some(handler) = after_window_creation {
    let raw = RawWindow {
      #[cfg(windows)]
      hwnd: window.hwnd(),
      #[cfg(any(
        target_os = "linux",
        target_os = "dragonfly",
        target_os = "freebsd",
        target_os = "netbsd",
        target_os = "openbsd"
      ))]
      gtk_window: window.gtk_window(),
      #[cfg(any(
        target_os = "linux",
        target_os = "dragonfly",
        target_os = "freebsd",
        target_os = "netbsd",
        target_os = "openbsd"
      ))]
      default_vbox: window.default_vbox(),
      _marker: &std::marker::PhantomData,
    };
    handler(raw);
  }

  let mut webviews = Vec::new();

  let focused_webview = Arc::new(Mutex::new(None));

  if let Some(webview) = webview {
    webviews.push(create_webview(
      #[cfg(feature = "unstable")]
      WebviewKind::WindowChild,
      #[cfg(not(feature = "unstable"))]
      WebviewKind::WindowContent,
      &window,
      Arc::new(Mutex::new(window_id)),
      webview_id,
      context,
      webview,
      focused_webview.clone(),
    )?);
  }

  let window = Arc::new(window);

  #[cfg(windows)]
  let surface = if is_window_transparent {
    if let Ok(context) = softbuffer::Context::new(window.clone()) {
      if let Ok(mut surface) = softbuffer::Surface::new(&context, window.clone()) {
        window.draw_surface(&mut surface, background_color);
        Some(surface)
      } else {
        None
      }
    } else {
      None
    }
  } else {
    None
  };

  Ok(WindowWrapper {
    label,
    has_children: AtomicBool::new(false),
    inner: Some(window),
    webviews,
    window_event_listeners,
    #[cfg(windows)]
    background_color,
    #[cfg(windows)]
    is_window_transparent,
    #[cfg(windows)]
    surface,
    focused_webview,
  })
}

```

--------------------------------

### Tauri: Example of Unlistening from Events

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Provides a practical example of how to unregister an event listener. It shows obtaining an event handle from `listen_any` and then explicitly calling `unlisten` to stop receiving further event notifications. This is important for resource management.

```rust
use tauri::{Manager, Listener};

tauri::Builder::default()
  .setup(|app| {
    let handle = app.handle().clone();
    let handler = app.listen_any("ready", move |event| {
      println!("app is ready");

      // we no longer need to listen to the event
      // we also could have used `app.once_global` instead
      handle.unlisten(event.id());
    });

    // stop listening to the event when you do not need it anymore
    app.unlisten(handler);
    Ok(())
  });
```

--------------------------------

### Rust Tauri: Create Show All Windows Menu Item

Source: https://docs.rs/tauri/latest/tauri/menu/struct

Creates a show all windows menu item. This item reveals all hidden application windows. An optional text string can be provided. Platform-specific: Unsupported on Windows and Linux.

```rust
pub fn show_all<M: Manager<R>>(manager: &M, text: Option<&str>) -> Result<Self>
```

--------------------------------

### Get Cursor Position (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Gets the cursor position relative to the top-left corner of the desktop. The coordinates can be negative if the window is outside the visible screen. This function is available on desktop platforms (`#[cfg(desktop)]`).

```rust
pub fn cursor_position(&self) -> crate::Result<PhysicalPosition<f64>> {
    self.webview.cursor_position()
  }
```

--------------------------------

### Get Webview Window

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Fetches a specific webview window from the manager using its label.

```APIDOC
## GET /webview_windows/{label}

### Description
Fetches a single webview window from the manager by its label.

### Method
GET

### Endpoint
/webview_windows/{label}

### Parameters
#### Path Parameters
- **label** (string) - Required - The unique label of the webview window to retrieve.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **Option<WebviewWindow<R>>** (WebviewWindow | null) - The WebviewWindow object if found, otherwise null.

#### Response Example
```json
{
  "label": "main-webview",
  "window_label": "main"
}
```
```

--------------------------------

### Get File Extension in Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/path/plugin

Extracts the file extension from a given path. It first obtains the file name using `app.path().file_name()` and then attempts to get the extension. Returns an error if the path has no extension.

```rust
pub fn extname<R: Runtime>(app: AppHandle<R>, path: String) -> Result<String> {
  let file_name = app.path().file_name(&path).ok_or(Error::NoExtension)?;
  match Path::new(&file_name)
    .extension()
    .and_then(std::ffi::OsStr::to_str)
  {
    Some(p) => Ok(p.to_string()),
    None => Err(Error::NoExtension),
  }
}
```

--------------------------------

### Rust: Initialize AppManager for Testing

Source: https://docs.rs/tauri/latest/src/tauri/manager/mod

Demonstrates the initialization of an `AppManager` with mock components for testing purposes. It sets up necessary context, plugins, and state managers required for running tests.

```rust
#[cfg(test)]
mod test {
  use std::{
    sync::mpsc::{channel, Receiver, Sender},
    time::Duration,
  };

  use crate::{
    event::EventTarget,
    generate_context,
    plugin::PluginStore,
    test::{mock_app, MockRuntime},
    webview::WebviewBuilder,
    window::WindowBuilder,
    App, Emitter, Listener, Manager, StateManager, Webview, WebviewWindow, WebviewWindowBuilder,
    Window,
    Wry,
  };

  use super::AppManager;

  const APP_LISTEN_ID: &str = "App::listen";
  const APP_LISTEN_ANY_ID: &str = "App::listen_any";
  const WINDOW_LISTEN_ID: &str = "Window::listen";
  const WINDOW_LISTEN_ANY_ID: &str = "Window::listen_any";
  const WEBVIEW_LISTEN_ID: &str = "Webview::listen";
  const WEBVIEW_LISTEN_ANY_ID: "Webview::listen_any";
  const WEBVIEW_WINDOW_LISTEN_ID: "WebviewWindow::listen";
  const WEBVIEW_WINDOW_LISTEN_ANY_ID: "WebviewWindow::listen_any";
  const TEST_EVENT_NAME: "event";

  #[test]
  fn check_get_url() {
    let context = generate_context!("test/fixture/src-tauri/tauri.conf.json", crate, test = true);
    let manager: AppManager<Wry> = AppManager::with_handlers(
      context,
      PluginStore::default(),
      Box::new(|_| false),
      None,
      Default::default(),
      StateManager::new(),
      Default::default(),
      #[cfg(all(desktop, feature = "tray-icon"))]
      Default::default(),
      Default::default(),
      Default::default(),
      Default::default(),
    );
  }
}
```

--------------------------------

### Rust Struct for Wix Language Configuration

Source: https://docs.rs/tauri/-utils/2.7.0/x86_64-unknown-linux-gnu/src/tauri_utils/config

Defines the structure for configuring language settings in a WiX installer. It specifies the path to a locale (.wxl) file, allowing for localized installer experiences. This struct is intended for use within the Tauri configuration system.

```rust
#[cfg_attr(feature = "schema", derive(JsonSchema))]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct WixLanguageConfig {
  /// The path to a locale (`.wxl`) file. See <https://wixtoolset.org/documentation/manual/v3/howtos/ui_and_localization/build_a_localized_version.html>.
  #[serde(alias = "locale-path")]
  pub locale_path: Option<String>,
}
```

--------------------------------

### Get Public Directory Path - Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/path/desktop

Gets the path for the user's public directory. Supports Linux via xdg-user-dirs, macOS via `$HOME/Public`, and Windows via `{FOLDERID_Public}`.

```rust
pub fn public_dir(&self) -> Result<PathBuf> {
  dirs::public_dir().ok_or(Error::UnknownPath)
}
```

--------------------------------

### Define Generic Setup Error in Rust

Source: https://docs.rs/tauri/2.8.5/src/tauri/error

This code defines a generic, boxed error type for setup failures in a Tauri application. It implements `From`, `Send`, `Sync`, `Display`, and `std::error::Error` traits for robust error handling and interoperability.

```rust
use std::fmt;

/// A generic boxed error.
#[derive(Debug)]
pub struct SetupError(Box<dyn std::error::Error>);

impl From<Box<dyn std::error::Error>> for SetupError {
  fn from(error: Box<dyn std::error::Error>) -> Self {
    Self(error)
  }
}

// safety: the setup error is only used on the main thread
// and we exit the process immediately.
unsafe impl Send for SetupError {}
unsafe impl Sync for SetupError {}

impl fmt::Display for SetupError {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    self.0.fmt(f)
  }
}

impl std::error::Error for SetupError {}
```

--------------------------------

### Cursor and Theme Settings

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

APIs for getting cursor position and setting the application theme.

```APIDOC
## GET /cursor/position

### Description
Gets the current cursor position relative to the desktop's top-left corner.

### Method
GET

### Endpoint
`/cursor/position`

### Parameters
None

### Response
#### Success Response (200)
- **PhysicalPosition<f64>** - The cursor's position.

#### Response Example
```json
{
  "position": {"x": 100.5, "y": 200.75} 
}
```
```

```APIDOC
## POST /theme/set

### Description
Sets the application's theme.

### Method
POST

### Endpoint
`/theme/set`

### Parameters
#### Request Body
- **theme** (Option<Theme>) - Optional - The theme to set (e.g., 'Light', 'Dark', or None for system default).

### Request Example
```json
{
  "theme": "Dark"
}
```

### Response
#### Success Response (200)
Success

#### Response Example
```json
{}
```
```

--------------------------------

### Rust Tauri MockWindowDispatcher Monitor Information

Source: https://docs.rs/tauri/2.8.4/src/tauri/test/mock_runtime

Methods for querying information about available monitors connected to the system within a mocked Tauri environment. This includes getting the current monitor, primary monitor, finding a monitor by point, and listing all available monitors. These return `None` or empty vectors as they are mock implementations.

```rust
fn current_monitor(&self) -> Result<Option<Monitor>> {
    Ok(None)
  }

  fn primary_monitor(&self) -> Result<Option<Monitor>> {
    Ok(None)
  }

  fn monitor_from_point(&self, x: f64, y: f64) -> Result<Option<Monitor>> {
    Ok(None)
  }

  fn available_monitors(&self) -> Result<Vec<Monitor>> {
    Ok(Vec::new())
  }
```

--------------------------------

### Initialize WebviewWindowBuilder

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Provides a method within the `WebviewWindow` implementation block to initialize a `WebviewWindowBuilder`. This method takes the window label and the initial webview URL as arguments, setting up the builder for creating a new webview window.

```rust
/// Base webview window functions.
impl<R: Runtime> WebviewWindow<R> {
  /// Initializes a [`WebviewWindowBuilder`] with the given window label and webview URL.
  
```

--------------------------------

### Get Cookie Value in Rust

Source: https://docs.rs/tauri/latest/tauri/webview/struct

Shows how to get the raw value of a `Cookie` using the `value()` method. This method returns a string slice (`&str`) and does not automatically strip surrounding quotes. For a trimmed value, use `value_trimmed()`.

```rust
use cookie::Cookie;

let c = Cookie::new("name", "value");
assert_eq!(c.value(), "value");

let c = Cookie::new("name", "\"value\"");
assert_eq!(c.value(), "\"value\"");
```

--------------------------------

### Window Builder API

Source: https://docs.rs/tauri/latest/src/tauri/window/mod

Provides methods for creating and configuring new windows.

```APIDOC
## POST /api/windows/builder

### Description
Initializes a window builder with the given window label. Data URLs are only supported with the `webview-data-url` feature flag.

### Method
POST

### Endpoint
/api/windows/builder

### Parameters
#### Path Parameters
- **label** (string) - Required - The label for the new window.

#### Query Parameters
- **manager** (Manager<R>) - Required - The manager instance.

#### Request Body
- **None**

### Request Example
```json
{
  "message": "No request body needed for builder initialization."
}
```

### Response
#### Success Response (200)
- **WindowBuilder** (object) - A new window builder instance.

#### Response Example
```json
{
  "builder_id": "unique_builder_identifier"
}
```
```

--------------------------------

### Get Webview URL - Rust

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

Retrieves the current URL of the webview. The URL is parsed into a `Url` type, and any errors during parsing or sending the message are handled. This function is typically used to get the current navigation state.

```rust
tx.send(
  webview
    .url()
    .map(|u| u.parse().expect("invalid webview URL"))
    .map_err(|_| Error::FailedToSendMessage),
)
.unwrap();
```

--------------------------------

### Rust: Create Tauri Webview Window from Config

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Creates a Tauri WebviewWindow using a predefined configuration. This method is useful for initializing windows with specific settings defined in a configuration object. It requires a manager and a WindowConfig as input.

```rust
///   let mut buf = [0u8; 1];
///   assert_eq!(getrandom::fill(&mut buf), Ok(()));
///   conf.label = format!("my-multiwindow-{}", buf[0]);
///   let webview_window = tauri::WebviewWindowBuilder::from_config(&app, &conf)
///     .unwrap()
///     .build()
///     .unwrap();
/// }
/// ```
///
/// [the Webview2 issue]: https://github.com/tauri-apps/wry/issues/583
pub fn from_config<'a, M>(manager: &'a M, config: &WindowConfig) -> crate::Result<Self> {
  Ok(Self {
    window_builder: WindowBuilder::from_config(manager, config)?,
    webview_builder: WebviewBuilder::from_config(config),
  })
}
```

--------------------------------

### WebviewBuilder::from_config Initialization (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Illustrates initializing a `WebviewBuilder` from a `WindowConfig` struct. This method populates the builder with settings defined in the application's configuration, such as window dimensions and title.

```rust
pub fn from_config(config: &WindowConfig) -> Self {
  Self {
    label: config.label.clone(),
    webview_attributes: WebviewAttributes::from(config),
    web_resource_request_handler: None,
    navigation_handler: None,
    new_window_handler: None,
    on_page_load_handler: None,
    document_title_changed_handler: None,
    download_handler: None,
  }
}
```

--------------------------------

### Create Webview Window Builder (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Constructs a builder for a new webview window. It takes a manager, a label for the window, and a URL to load. The `webview-data-url` feature flag is required for data URLs.

```rust
pub fn builder<M: Manager<R>, L: Into<String>>(
    manager: &M,
    label: L,
    url: WebviewUrl,
  ) -> WebviewWindowBuilder<'_, R, M> {
    WebviewWindowBuilder::new(manager, label, url)
  }
```

--------------------------------

### Prepare Pending Webview Attributes

Source: https://docs.rs/tauri/2.8.4/src/tauri/manager/webview

Prepares a `PendingWebview` by injecting necessary initialization scripts, including plugin initialization scripts, pattern-specific JavaScript, and IPC initialization scripts. It determines whether to use HTTPS based on webview attributes.

```rust
fn prepare_pending_webview<M: Manager<R>>(
    &self,
    mut pending: PendingWebview<EventLoopMessage, R>,
    label: &str,
    window_label: &str,
    manager: &M,
  ) -> crate::Result<PendingWebview<EventLoopMessage, R>> {
    let app_manager = manager.manager();

    let plugin_init_scripts = app_manager
      .plugins
      .lock()
      .expect("poisoned plugin store")
      .initialization_script();

    let pattern_init = PatternJavascript {
      pattern: (&*app_manager.pattern).into(),
    }
    .render_default(&Default::default())?;

    let mut webview_attributes = pending.webview_attributes;

    let use_https_scheme = webview_attributes.use_https_scheme;

    let ipc_init = IpcJavascript {
      isolation_origin: &match &*app_manager.pattern {
        #[cfg(feature = "isolation")]
        crate::Pattern::Isolation { schema, .. } => {

```

--------------------------------

### Webview Access and Execution

Source: https://docs.rs/tauri/latest/src/tauri/webview/mod

Provides methods to get the hosting window and execute platform-specific code within the webview.

```APIDOC
## GET /webview/window

### Description
Returns the window that is hosting this webview.

### Method
GET

### Endpoint
`/webview/window`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **window** (Window<R>) - The window object hosting the webview.

#### Response Example
```json
{
  "window_data": "..."
}
```
```

```APIDOC
## GET /webview/window_ref

### Description
Returns a mutable reference to the window that is hosting this webview.

### Method
GET

### Endpoint
`/webview/window_ref`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **window_ref** (MutexGuard<'_, Window<R>>) - A mutable guard to the window object hosting the webview.

#### Response Example
```json
{
  "window_data": "..."
}
```
```

```APIDOC
## POST /webview/with_webview

### Description
Executes a closure, providing it with the webview handle that is specific to the current platform. The closure is executed on the main thread.

Note that crates like `webview2-com`, `webkit2gtk`, `objc2_web_kit` may be updated in minor releases of Tauri. It's recommended to pin Tauri to at least a minor version when using `with_webview`.

### Method
POST

### Endpoint
`/webview/with_webview`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **f** (FnOnce(PlatformWebview)) - Required - The closure to execute with the platform-specific webview handle.

### Request Example
```json
{
  "f": "closure_definition"
}
```

### Response
#### Success Response (200)
- **success** (boolean) - Indicates if the closure execution was successful.

#### Response Example
```json
{
  "success": true
}
```
```

```APIDOC
## GET /webview/url

### Description
Returns the current URL of the webview.

### Method
GET

### Endpoint
`/webview/url`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **url** (Url) - The current URL loaded in the webview.

#### Response Example
```json
{
  "url": "https://example.com"
}
```
```

--------------------------------

### Window Menu Management

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

APIs for getting, setting, and removing the window menu.

```APIDOC
## GET /websites/rs-tauri/menu

### Description
Returns the current window menu.

### Method
GET

### Endpoint
`/websites/rs-tauri/menu`

### Response
#### Success Response (200)
- **Option<Menu<R>>** - The current window menu, or None if not set.

#### Response Example
{
  "example": "{\"items\": [...]}"
}

## POST /websites/rs-tauri/set-menu

### Description
Sets the window menu and returns the previous one.

### Method
POST

### Endpoint
`/websites/rs-tauri/set-menu`

### Parameters
#### Request Body
- **menu** (Menu<R>) - Required - The new menu to set for the window.

### Request Example
{
  "example": "{\"items\": [...]}"
}

### Response
#### Success Response (200)
- **Option<Menu<R>>** - The previous window menu, or None if no menu was set before.

#### Response Example
{
  "example": "{\"items\": [...]}"
}

## DELETE /websites/rs-tauri/menu

### Description
Removes the window menu and returns it.

### Method
DELETE

### Endpoint
`/websites/rs-tauri/menu`

### Response
#### Success Response (200)
- **Option<Menu<R>>** - The removed window menu, or None if no menu was set.

#### Response Example
{
  "example": "{\"items\": [...]}"
}
```

--------------------------------

### Window Configuration

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/window

Methods for initializing and configuring window properties.

```APIDOC
## Window Builder API

### Description

This API provides methods for configuring and building application windows.

### Methods

#### `new()`

Initializes a new window attributes builder.

##### Returns

- `Self`: A new instance of the window builder.

#### `with_config(config: &WindowConfig)`

Initializes a new window builder from a `WindowConfig`.

- **config** (`&WindowConfig`) - The window configuration to use.

##### Returns

- `Self`: The window builder initialized with the provided configuration.

#### `center()`

Shows the window in the center of the screen.

##### Returns

- `Self`: The updated window builder.

#### `position(x: f64, y: f64)`

Sets the initial position of the window.

- **x** (`f64`) - The x-coordinate of the window's position.
- **y** (`f64`) - The y-coordinate of the window's position.

##### Returns

- `Self`: The updated window builder.

#### `inner_size(width: f64, height: f64)`

Sets the inner size of the window.

- **width** (`f64`) - The desired width of the window's inner area.
- **height** (`f64`) - The desired height of the window's inner area.

##### Returns

- `Self`: The updated window builder.

#### `min_inner_size(min_width: f64, min_height: f64)`

Sets the minimum inner size of the window.

- **min_width** (`f64`) - The minimum allowed width of the window's inner area.
- **min_height** (`f64`) - The minimum allowed height of the window's inner area.

##### Returns

- `Self`: The updated window builder.

#### `max_inner_size(max_width: f64, max_height: f64)`

Sets the maximum inner size of the window.

- **max_width** (`f64`) - The maximum allowed width of the window's inner area.
- **max_height** (`f64`) - The maximum allowed height of the window's inner area.

##### Returns

- `Self`: The updated window builder.

#### `inner_size_constraints(constraints: WindowSizeConstraints)`

Sets the inner size constraints for the window.

- **constraints** (`WindowSizeConstraints`) - An object containing minimum and maximum width and height constraints.

##### Returns

- `Self`: The updated window builder.

#### `prevent_overflow()`

Prevents the window from overflowing the working area (e.g., monitor size minus taskbar size) on creation.

*Note: Unsupported on iOS and Android.*

##### Returns

- `Self`: The updated window builder.

#### `prevent_overflow_with_margin(margin: dpi::Size)`

Prevents the window from overflowing the working area with a specified margin on creation.

*Note: Unsupported on iOS and Android.*

- **margin** (`dpi::Size`) - The margin to apply around the window to prevent overflow.

##### Returns

- `Self`: The updated window builder.

#### `resizable(resizable: bool)`

Determines whether the window is resizable or not. Setting this to `false` automatically disables the native window's maximize button.

- **resizable** (`bool`) - `true` to make the window resizable, `false` otherwise.

##### Returns

- `Self`: The updated window builder.

#### `set_maximized(maximized: bool)`

Sets whether the window is maximized or not.

- **maximized** (`bool`) - `true` to maximize the window, `false` to restore it.

##### Returns

- `Self`: The updated window builder.

#### `title(title: &str)`

Sets the title of the window.

- **title** (`&str`) - The desired title for the window.

##### Returns

- `Self`: The updated window builder.

#### `visible(visible: bool)`

Sets whether the window is initially visible or not.

- **visible** (`bool`) - `true` to make the window visible, `false` to hide it.

##### Returns

- `Self`: The updated window builder.

#### `fullscreen(fullscreen: bool)`

Sets whether the window should be in fullscreen mode.

- **fullscreen** (`bool`) - `true` to enable fullscreen, `false` to disable.

##### Returns

- `Self`: The updated window builder.

#### `decorations(decorations: bool)`

Sets whether the window should have native window decorations (like title bar, minimize/maximize/close buttons).

- **decorations** (`bool`) - `true` to enable decorations, `false` to disable.

##### Returns

- `Self`: The updated window builder.

#### `always_on_top(always_on_top: bool)`

Sets whether the window should always be on top of other windows.

- **always_on_top** (`bool`) - `true` to keep the window on top, `false` otherwise.

##### Returns

- `Self`: The updated window builder.

#### `transparent(transparent: bool)`

Sets whether the window should be transparent.

- **transparent** (`bool`) - `true` to make the window transparent, `false` otherwise.

##### Returns

- `Self`: The updated window builder.

#### `resizable_with_constraints(constraints: WindowSizeConstraints)`

Sets the resizable constraints for the window.

- **constraints** (`WindowSizeConstraints`) - An object containing minimum and maximum width and height constraints for resizing.

##### Returns

- `Self`: The updated window builder.

#### `build()`

Builds and creates the window based on the configured properties.

##### Returns

- `Result<Window, Error>`: A `Result` containing the created `Window` on success, or an `Error` if creation fails.

### Data Structures

#### `WindowSizeConstraints`

Represents the size constraints for a window.

- **min_width** (`Option<PixelUnit>`) - The minimum width a window can be. `None` means no minimum width.
- **min_height** (`Option<PixelUnit>`) - The minimum height a window can be. `None` means no minimum height.
- **max_width** (`Option<PixelUnit>`) - The maximum width a window can be. `None` means no maximum width.
- **max_height** (`Option<PixelUnit>`) - The maximum height a window can be. `None` means no maximum height.

#### `CursorIcon` Deserialization

This deserializer handles converting string representations of cursor icons into the `CursorIcon` enum. It performs a case-insensitive match.

- **Input**: A string representing a cursor icon (e.g., "default", "crosshair").
- **Output**: A `CursorIcon` enum variant or `CursorIcon::Default` if the input is unrecognized.

```

--------------------------------

### Rust: Implement StateManager Get and TryGet Methods

Source: https://docs.rs/tauri/2.8.5/src/tauri/state

Provides methods to retrieve state associated with a specific type from the StateManager. `get` panics if the state is not found, while `try_get` returns an `Option`. Both require the state type `T` to be Send and Sync, and 'static.

```rust
pub fn get<T: Send + Sync + 'static>(&self) -> State<'_, T> {
    self
      .try_get()
      .unwrap_or_else(|| panic!("state not found for type {}", std::any::type_name::<T>()))
}

/// Gets the state associated with the specified type.
pub fn try_get<T: Send + Sync + 'static>(&self) -> Option<State<'_, T>> {
    let map = self.map.lock().unwrap();
    let type_id = TypeId::of::<T>();
    let ptr = map.get(&type_id)?;
    let value = unsafe {
      ptr
        .downcast_ref::<T>()
        // SAFETY: the type of the key is the same as the type of the value
        .unwrap_unchecked()
    };
    // SAFETY: We ensure the lifetime of `value` is the same as [StateManager] and `value` will not be mutated/moved.
    let v_ref = unsafe { &*(value as *const T) };
    Some(State(v_ref))
}
}
```

--------------------------------

### Create and Write to Output File in Rust (tauri-build)

Source: https://docs.rs/tauri/-build/latest/src/tauri_build/codegen/context

This Rust code snippet demonstrates the process of creating a directory if it doesn't exist and then creating an output file. It uses `BufWriter` for efficient writing and includes context-specific error messages for file creation and writing operations. This is part of the tauri-build process.

```rust
create_dir_all(parent)?;

let mut file = File::create(&out).map(BufWriter::new).with_context(|| {
  format!(
    "Unable to create output file during tauri-build {}",
    out.display()
  )
})?;

writeln!(file, "{code}").with_context(|| {
  format!(
    "Unable to write tokenstream to out file during tauri-build {}",
    out.display()
  )
})?;

Ok(out)
```

--------------------------------

### Get Webview

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Fetches a specific webview from the manager using its label.

```APIDOC
## GET /webviews/{label}

### Description
Fetches a single webview from the manager by its label.

*   **Stability**: Requires the `unstable` feature.

### Method
GET

### Endpoint
/webviews/{label}

### Parameters
#### Path Parameters
- **label** (string) - Required - The unique label of the webview to retrieve.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **Option<Webview<R>>** (Webview | null) - The Webview object if found, otherwise null.

#### Response Example
```json
{
  "label": "main-webview",
  "url": "https://example.com"
}
```
```

--------------------------------

### Get Window

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Fetches a specific window from the manager using its label.

```APIDOC
## GET /windows/{label}

### Description
Fetches a single window from the manager by its label.

*   **Stability**: Requires the `unstable` feature.

### Method
GET

### Endpoint
/windows/{label}

### Parameters
#### Path Parameters
- **label** (string) - Required - The unique label of the window to retrieve.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **Window<R>** (Window) - The Window object if found, otherwise None.

#### Response Example
```json
{
  "label": "main",
  "title": "My App",
  "is_resizable": true
}
```
```

--------------------------------

### Iterator methods for Box (Rust)

Source: https://docs.rs/tauri/-runtime/2.8.0/tauri_runtime/webview/type

Provides standard iterator functionality for boxed iterators, including retrieving the next item, estimating remaining elements, getting the nth element, and consuming the iterator to get the last element.

```Rust
fn next(&mut self) -> Option<<I as Iterator>::Item>
// Advances the iterator and returns the next value. Read more
```

```Rust
fn size_hint(&self) -> (usize, Option<usize>)
// Returns the bounds on the remaining length of the iterator. Read more
```

```Rust
fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item>
// Returns the `n`th element of the iterator. Read more
```

```Rust
fn last(self) -> Option<<I as Iterator>::Item>
// Consumes the iterator, returning the last element. Read more
```

--------------------------------

### Builder API

Source: https://docs.rs/tauri/latest/src/tauri/app

The Builder struct provides methods to configure and run your Tauri application. You can set up invoke handlers, manage plugins, and define setup hooks.

```APIDOC
## Builder Struct

### Description
Represents a builder for creating and configuring a Tauri application.

### Fields
- **runtime_any_thread** (bool) - Optional - Indicates if the runtime must be started on an environment that supports the event loop not on the main thread. (Windows, Linux only)
- **invoke_handler** (InvokeHandler<R>) - The JS message handler.
- **invoke_initialization_script** (String) - The script that initializes the `window.__TAURI_INTERNALS__.postMessage` function.
- **channel_interceptor** (Option<ChannelInterceptor<R>>) - An optional channel interceptor.
- **setup** (SetupHook<R>) - The setup hook, called when the application starts.
- **on_page_load** (Option<Arc<OnPageLoad<R>>>) - An optional hook for page load events.
- **plugins** (PluginStore<R>) - A store for managing plugins.
- **uri_scheme_protocols** (HashMap<String, Arc<UriSchemeProtocol<R>>>) - A map of custom URI scheme protocols.
- **state** (StateManager) - Manages application state.
- **menu** (Option<Box<dyn FnOnce(&AppHandle<R>) -> crate::Result<Menu<R>> + Send>>) - Optional - A closure that returns the menu set to all windows. (Desktop only)
- **menu_event_listeners** (Vec<GlobalMenuEventListener<AppHandle<R>>>) - Listeners for global menu events. (Desktop only)
- **tray_icon_event_listeners** (Vec<GlobalTrayIconEventListener<AppHandle<R>>>) - Listeners for global tray icon events. (Desktop and tray-icon feature only)
- **enable_macos_default_menu** (bool) - Enable macOS default menu creation.
- **window_event_listeners** (Vec<GlobalWindowEventListener<R>>) - Listeners for global window events.
- **webview_event_listeners** (Vec<GlobalWebviewEventListener<R>>) - Listeners for global webview events.
- **device_event_filter** (DeviceEventFilter) - The device event filter.
- **invoke_key** (String) - A unique key used for invoke communication.

### Methods
- **new() -> Self**: Creates a new App builder.
- **default() -> Self**: Creates a new App builder with default settings (requires the `wry` feature).

### Example
```rust
use tauri::Builder;

let builder = Builder::default();
```
```

--------------------------------

### Start Window Resize Dragging in Tauri

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Initiates a resize operation for the window by dragging. Requires specifying the direction of the resize.

```rust
/// Starts resize-dragging the window.
pub fn start_resize_dragging(
    &self,
    direction: tauri_runtime::ResizeDirection,
  ) -> crate::Result<()>
{
  self
    .window
    .dispatcher
    .start_resize_dragging(direction)
    .map_err(Into::into)
}
```

--------------------------------

### Mock Tauri App Creation and IPC Test

Source: https://docs.rs/tauri/2.8.4/src/tauri/test/mod

Demonstrates how to create a mock Tauri application, define a command, and test it using IPC. It shows the setup for a testable application environment and how to invoke commands programmatically.

```rust
use tauri::test::{mock_builder, mock_context, noop_assets};

#[tauri::command]
fn ping() -> &'static str {
    "pong"
}

fn create_app<R: tauri::Runtime>(builder: tauri::Builder<R>) -> tauri::App<R> {
    builder
        .invoke_handler(tauri::generate_handler![ping])
        // remove the string argument to use your app's config file
        .build(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
        .expect("failed to build app")
}

fn main() {
    // Use `tauri::Builder::default()` to use the default runtime rather than the `MockRuntime`;
    // let app = create_app(tauri::Builder::default());
    let app = create_app(mock_builder());
    let webview = tauri::WebviewWindowBuilder::new(&app, "main", Default::default()).build().unwrap();

    // run the `ping` command and assert it returns `pong`
    let res = tauri::test::get_ipc_response(
        &webview,
        tauri::webview::InvokeRequest {
            cmd: "ping".into(),
            callback: tauri::ipc::CallbackFn(0),
            error: tauri::ipc::CallbackFn(1),
            // alternatively use "tauri://localhost"
            url: "http://tauri.localhost".parse().unwrap(),
            body: tauri::ipc::InvokeBody::default(),
            headers: Default::default(),
            invoke_key: tauri::test::INVOKE_KEY.to_string(),
        },
    ).map(|b| b.deserialize::<String>().unwrap());
}
```

--------------------------------

### Rust: PluginStore Window and Webview Hooks

Source: https://docs.rs/tauri/2.8.5/src/tauri/plugin

Methods to trigger window creation and webview creation hooks for all registered plugins. These hooks allow plugins to react to the creation of new windows or webviews.

```rust
pub(crate) fn window_created(&mut self, window: Window<R>) {
    self.store.iter_mut().for_each(|plugin| {
      #[cfg(feature = "tracing")]
      let _span = tracing::trace_span!("plugin::hooks::created", name = plugin.name()).entered();
      plugin.window_created(window.clone())
    })
  }

  /// Runs the webview created hook for all plugins in the store.
  pub(crate) fn webview_created(&mut self, webview: Webview<R>) {
    self
      .store
      .iter_mut()
      .for_each(|plugin| plugin.webview_created(webview.clone()))
  }
```

--------------------------------

### Rust Macro for Tauri App Entry Point

Source: https://docs.rs/tauri/-macros/2.4.0/src/tauri_macros/mobile

This Rust macro, `entry_point`, is used to define the main entry point for a Tauri application. It handles environment variable loading for Android package details and sets up the necessary functions for starting the app, including platform-specific configurations for Android and iOS.

```rust
use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::{format_ident, quote};
use std::env::var;
use syn::{parse_macro_input, spanned::Spanned, ItemFn};

fn get_env_var(name: &str, error: &mut Option<TokenStream2>, function: &ItemFn) -> TokenStream2 {
  match var(name) {
    Ok(value) => {
      let ident = format_ident!("{value}");
      quote!(#ident)
    }
    Err(_) => {
      error.replace(
        syn::Error::new(
          function.span(),
          format!("`{name}` env var not set, do you have a build script with tauri-build?",),
        )
        .into_compile_error(),
      );
      quote!()
    }
  }
}

pub fn entry_point(_attributes: TokenStream, item: TokenStream) -> TokenStream {
  let function = parse_macro_input!(item as ItemFn);
  let function_name = function.sig.ident.clone();

  let mut error = None;
  let domain = get_env_var("TAURI_ANDROID_PACKAGE_NAME_PREFIX", &mut error, &function);
  let app_name = get_env_var("TAURI_ANDROID_PACKAGE_NAME_APP_NAME", &mut error, &function);

  let (wrapper, wrapper_name) = if function.sig.asyncness.is_some() {
    let wrapper_name = syn::Ident::new(&format!("{function_name}_wrapper"), function_name.span());
    (
      quote! {
        #function

        fn #wrapper_name() {
          ::tauri::async_runtime::block_on(#function_name());
        }
      },
      wrapper_name,
    )
  } else {
    (
      quote! {
        #function
      },
      function_name,
    )
  };

  if let Some(e) = error {
    quote!(#e).into()
  } else {
    quote!(
      fn stop_unwind<F: FnOnce() -> T, T>(f: F) -> T {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(f)) {
          Ok(t) => t,
          Err(err) => {
            eprintln!("attempt to unwind out of `rust` with err: {:?}", err);
            std::process::abort()
          }
        }
      }

      #wrapper

      fn _start_app() {
        #[cfg(target_os = "ios")]
        ::tauri::log_stdout();
        #[cfg(target_os = "android")]
        {
          ::tauri::android_binding!(#domain, #app_name, _start_app, ::tauri::wry);
        }
        stop_unwind(#wrapper_name);
      }

      // be careful when renaming this, the `start_app` symbol is checked by the CLI
      #[cfg(not(target_os = "android"))]
      #[no_mangle]
      #[inline(never)]
      pub extern "C" fn start_app() {
        _start_app()
      }
    )
    .into()
  }
}
```

--------------------------------

### Initialize Tauri Plugin with JavaScript Initialization Script

Source: https://docs.rs/tauri/latest/src/tauri/window/plugin

Initializes a Tauri plugin, in this case, for window management. It includes a JavaScript initialization script, specifically for drag and drop functionality, which is rendered based on the operating system. This script is executed when the webview is loaded.

```rust
pub fn init<R: Runtime>() -> TauriPlugin<R> {
  use serialize_to_javascript::{default_template, DefaultTemplate, Template};

  let mut init_script = String::new();

  #[derive(Template)]
  #[default_template("./scripts/drag.js")]
  struct Drag<'a> {
    os_name: &'a str,
  }

  init_script.push_str(
    &Drag {
      os_name: std::env::consts::OS,
    }
    .render_default(&Default::default())
    .unwrap()
    .into_string(),
  );

  Builder::new("window")
    .js_init_script(init_script)
    .invoke_handler(
      #[cfg(desktop)]
      crate::generate_handler![
        #![plugin(window)]
        // ... other commands ...
      ]
    )
    .build()
}
```

--------------------------------

### Set Fullscreen Mode (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Configures the window to start in fullscreen mode upon creation.

```rust
pub fn fullscreen(mut self, fullscreen: bool) -> Self {
  self.window_builder = self.window_builder.fullscreen(fullscreen);
  self
}
```

--------------------------------

### Run Tauri Application (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/app

Provides a convenient method to build and run the configured Tauri application. This is a shortcut for separately calling `build` and `run` methods, offering a streamlined execution process for the application.

```rust
/// Builds the configured application and runs it.
///
/// This is a shorthand for [`Self::build`] followed by [`App::run`].
/// For more flexibility, consider using those functions manually.
pub fn run(self, context: Context<R>) -> crate::Result<()> {
  self.build(context)?.run(|_, _| {});
  Ok(())
}

```

--------------------------------

### Windows Update Install Modes Enum in Rust

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Defines an enum for specifying the installation mode of Windows updates, offering options like BasicUI, Quiet, and Passive. It includes implementations for Display, Default, Serialize, and Deserialize to handle different representations and conversions.

```rust
/// Install modes for the Windows update.
#[derive(Debug, PartialEq, Eq, Clone)]
#[cfg_attr(feature = "schema", derive(schemars::JsonSchema))]
#[cfg_attr(feature = "schema", schemars(rename_all = "camelCase"))]
pub enum WindowsUpdateInstallMode {
  /// Specifies there's a basic UI during the installation process, including a final dialog box at the end.
  BasicUi,
  /// The quiet mode means there's no user interaction required.
  /// Requires admin privileges if the installer does.
  Quiet,
  /// Specifies unattended mode, which means the installation only shows a progress bar.
  Passive,
}

impl Display for WindowsUpdateInstallMode {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!
      (
        f,
        "{}",
        match self {
          Self::BasicUi => "basicUI",
          Self::Quiet => "quiet",
          Self::Passive => "passive",
        }
      )
  }
}

impl Default for WindowsUpdateInstallMode {
  fn default() -> Self {
    Self::Passive
  }
}

impl Serialize for WindowsUpdateInstallMode {
  fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    serializer.serialize_str(self.to_string().as_ref())
  }
}

impl<'de> Deserialize<'de> for WindowsUpdateInstallMode {
  fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
  where
    D: Deserializer<'de>,
  {
    let s = String::deserialize(deserializer)?;
    match s.to_lowercase().as_str() {
      "basicui" => Ok(Self::BasicUi),
      "quiet" => Ok(Self::Quiet),
      "passive" => Ok(Self::Passive),
      _ => Err(DeError::custom(format!(
        "unknown update install mode '{s}'"
      ))),
    }
  }
}
```

--------------------------------

### MockWindowDispatcher: Get Theme (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/test/mock_runtime

Returns `Theme::Light` as the default theme for the mock window. This is a fixed mock value.

```rust
fn theme(&self) -> Result<Theme> {
  Ok(Theme::Light)
}
```

--------------------------------

### Window Creation

Source: https://docs.rs/tauri/-runtime/2.8.0/tauri_runtime/trait

Create new application windows or webviews.

```APIDOC
## POST /window/create

### Description
Creates a new application window.

### Method
POST

### Endpoint
/window/create

### Parameters
#### Request Body
- **pending** (PendingWindow<T, Runtime>) - Required - Configuration for the new window.
- **after_window_creation** (function | null) - Optional - A callback function to execute after the window is created.

### Request Example
```json
{
  "pending": {
    "title": "New Window",
    "width": 800,
    "height": 600
  },
  "after_window_creation": "function(rawWindow) { console.log('Window created:', rawWindow); }"
}
```

### Response
#### Success Response (200)
- **detached_window** (DetachedWindow<T, Runtime>) - A handle to the newly created detached window.

#### Response Example
```json
{
  "detached_window": "detached-window-handle-123"
}
```

## POST /window/webview/create

### Description
Creates a new webview.

### Method
POST

### Endpoint
/window/webview/create

### Parameters
#### Request Body
- **pending** (PendingWebview<T, Runtime>) - Required - Configuration for the new webview.

### Request Example
```json
{
  "pending": {
    "url": "https://example.com",
    "title": "Webview Window"
  }
}
```

### Response
#### Success Response (200)
- **detached_webview** (DetachedWebview<T, Runtime>) - A handle to the newly created detached webview.

#### Response Example
```json
{
  "detached_webview": "detached-webview-handle-456"
}
```
```

--------------------------------

### Build Tauri Application with Context

Source: https://docs.rs/tauri/latest/src/tauri/app

Constructs the Tauri application instance using the provided context. It handles platform-specific configurations like macOS default menus and initializes the application manager with various handlers and settings. This function is instrumented for tracing when the 'tracing' feature is enabled.

```rust
#[allow(clippy::type_complexity, unused_mut)]
#[cfg_attr(
  feature = "tracing",
  tracing::instrument(name = "app::build", skip_all)
)]
pub fn build(mut self, context: Context<R>) -> crate::Result<App<R>> {
  #[cfg(target_os = "macos"]
  if self.menu.is_none() && self.enable_macos_default_menu {
    self.menu = Some(Box::new(|app_handle| {
      crate::menu::Menu::default(app_handle)
    }));
  }

  let manager = Arc::new(AppManager::with_handlers(
    context,
    self.plugins,
    self.invoke_handler,
    self.on_page_load,
    self.uri_scheme_protocols,
    self.state,
    #[cfg(desktop)]
    self.menu_event_listeners,
    #[cfg(all(desktop, feature = "tray-icon"))]
    self.tray_icon_event_listeners,
    self.window_event_listeners,
    self.webview_event_listeners,
    #[cfg(desktop)]
    HashMap::new(),
    self.invoke_initialization_script,
    self.channel_interceptor,
    self.invoke_key,
  ));

  #[cfg(any(
    target_os = "linux",
    target_os = "dragonfly",
    target_os = "freebsd",
    target_os = "netbsd",
    target_os = "openbsd"
  ))]
  let app_id = if manager.config.app.enable_gtk_app_id {
    Some(manager.config.identifier.clone())
  } else {
    None
  };

  let runtime_args = RuntimeInitArgs {
    #[cfg(any(
      target_os = "linux",
      target_os = "dragonfly",
      target_os = "freebsd",
      target_os = "netbsd",
      target_os = "openbsd"
    ))]
    app_id,

    #[cfg(windows)]
    msg_hook: {
      let menus = manager.menu.menus.clone();
      Some(Box::new(move |msg| {
        use windows::Win32::UI::WindowsAndMessaging::{TranslateAcceleratorW, HACCEL, MSG};
        unsafe {
          let msg = msg as *const MSG;
          for menu in menus.lock().unwrap().values() {
            let translated =
              TranslateAcceleratorW((*msg).hwnd, HACCEL(menu.inner().haccel() as _), msg);
            if translated == 1 {
              return true;
            }
          }

          false
        }
      }))
    },
  };

  // The env var must be set before the Runtime is created so that GetAvailableBrowserVersionString picks it up.
  #[cfg(windows)]
  {
    if let crate::utils::config::WebviewInstallMode::FixedRuntime { path } = 
      &manager.config.bundle.windows.webview_install_mode
    {
      if let Some(exe_dir) = crate::utils::platform::current_exe()
        .ok()
        .and_then(|p| p.parent().map(|p| p.to_path_buf()))

```

--------------------------------

### Example: Registering an Asynchronous Custom URI Scheme Protocol

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

This Rust code snippet demonstrates registering an asynchronous custom URI scheme protocol named 'app-files'. The handler function spawns a new thread to read a file and then uses the provided responder to send the response. This example illustrates how to manage asynchronous operations for custom protocols.

```rust
tauri::Builder::default()
  .register_asynchronous_uri_scheme_protocol("app-files", |_ctx, request, responder| {
    // skip leading `/`
    let path = request.uri().path()[1..].to_string();
    std::thread::spawn(move || {
      if let Ok(data) = std::fs::read(path) {
        responder.respond(
          http::Response::builder()
            .body(data)
            .unwrap()
        );
      } else {
        responder.respond(
          http::Response::builder()
            .status(http::StatusCode::BAD_REQUEST)
            .header(http::header::CONTENT_TYPE, mime::TEXT_PLAIN.essence_str())
            .body("failed to read file".as_bytes().to_vec())
            .unwrap()
        );
    }
  });
  });
```

--------------------------------

### Mock Runtime Window Creation (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/test/mock_runtime

Illustrates the `create_window` method within the `MockRuntimeHandle`. This function simulates the creation of a new window by assigning a unique ID, managing associated webviews, and updating the internal window registry. It's a core part of mocking the Tauri runtime for testing.

```rust
use tauri_runtime::{
  webview::{DetachedWebview, PendingWebview},
  window::{DetachedWindow, DetachedWindowWebview, PendingWindow, RawWindow, WindowBuilderBase, WindowId},
  UserEvent, Result
};
use std::{
  cell::RefCell,
  collections::HashMap,
  sync::{
    atomic::{AtomicU32, Ordering},
    Arc,
  },
};

// Mock implementations for missing types
struct Webview;
struct Window {
  label: String,
  webviews: Vec<Webview>,
}

// Mock structure for RuntimeContext (as defined in previous snippet)
#[derive(Clone)]
pub struct RuntimeContext {
  is_running: Arc<AtomicBool>,
  windows: Arc<RefCell<HashMap<WindowId, Window>>>, 
  shortcuts: Arc<Mutex<ShortcutMap>>,
  run_tx: SyncSender<Message>,
  next_window_id: Arc<AtomicU32>,
  next_webview_id: Arc<AtomicU32>,
  next_window_event_id: Arc<AtomicU32>,
  next_webview_event_id: Arc<AtomicU32>,
}

impl RuntimeContext {
  fn next_window_id(&self) -> WindowId {
    self.next_window_id.fetch_add(1, Ordering::Relaxed).into()
  }

  fn next_webview_id(&self) -> u32 {
    self.next_webview_id.fetch_add(1, Ordering::Relaxed)
  }
}

// Placeholder for MockRuntimeHandle (as defined in previous snippet)
#[derive(Debug, Clone)]
pub struct MockRuntimeHandle {
  context: RuntimeContext,
}

// Placeholder for RuntimeHandle trait
trait RuntimeHandle<T: UserEvent> {
    type Runtime;
    fn create_proxy(&self) -> EventProxy;
    fn request_exit(&self, code: i32) -> Result<()>;
    // Add create_window to the trait for the implementation
    fn create_window<F: Fn(RawWindow<'_>) + Send + 'static>(
      &self,
      pending: PendingWindow<T, Self::Runtime>,
      _after_window_creation: Option<F>,
    ) -> Result<DetachedWindow<T, Self::Runtime>>;
}

// Placeholder for EventProxy
pub struct EventProxy {}
impl<T: UserEvent> EventLoopProxy<T> for EventProxy {
  fn send_event(self, _event: T) -> Result<()> {
    Ok(())
  }
}

// Placeholder for MockRuntime
pub struct MockRuntime;

impl<T: UserEvent> RuntimeHandle<T> for MockRuntimeHandle {
  type Runtime = MockRuntime;

  fn create_proxy(&self) -> EventProxy {
    EventProxy {}
  }

  fn request_exit(&self, _code: i32) -> Result<()> {
    unimplemented!()
  }

  /// Create a new webview window.
  fn create_window(
    &self,
    pending: PendingWindow<T, Self::Runtime>,
    _after_window_creation: Option<impl Fn(RawWindow<'_>) + Send + 'static>,
  ) -> Result<DetachedWindow<T, Self::Runtime>> {
    let id = self.context.next_window_id();

    let (webview_id, webviews) = if let Some(w) = &pending.webview {
      (Some(self.context.next_webview_id()), vec![Webview])
    } else {
      (None, Vec::new())
    };

    self.context.windows.borrow_mut().insert(
      id,
      Window {
        label: pending.label.clone(),
        webviews,
      },
    );

    let webview = webview_id.map(|id| DetachedWebview {
      webview: DetachedWebview {
        label: pending.label.clone(),
        id: id.into(), // Assuming WindowEventId can be converted from u32
      },
      proxy: self.create_proxy(),
    });

    Ok(DetachedWindow {
      id: id.into(), // Assuming WindowId can be converted from WindowId
      webview,
      proxy: self.create_proxy(),
    })
  }
}

```

--------------------------------

### Get Base Name in Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/path/plugin

Retrieves the base name of a file path, optionally stripping a given extension. It uses `app.path().file_name()` to get the file name. If an extension is provided, it attempts to remove it from the end of the file name.

```rust
pub fn basename<R: Runtime>(app: AppHandle<R>, path: &str, ext: Option<&str>) -> Result<String> {
  let file_name = app.path().file_name(path);
  match file_name {
    Some(p) => {
      let maybe_stripped = if let Some(ext) = ext {
        p.strip_suffix(ext).unwrap_or(&p).to_string()
      } else {
        p
      };
      Ok(maybe_stripped)
    }
    None => Err(Error::NoBasename),
  }
}
```

--------------------------------

### Window Positioning and Size

Source: https://docs.rs/tauri/-runtime/2.8.0/tauri_runtime/trait

Get and set the position and size of the application window.

```APIDOC
## GET /window/position

### Description
Retrieves the position of the top-left corner of the window's client area relative to the top-left corner of the desktop.

### Method
GET

### Endpoint
/window/position

### Parameters
None

### Request Example
(No request body for GET requests)

### Response
#### Success Response (200)
- **inner_position** (PhysicalPosition<i32>) - The position of the window's client area.

#### Response Example
```json
{
  "inner_position": {"x": 100, "y": 100}
}
```

## GET /window/outer_position

### Description
Retrieves the position of the top-left corner of the window relative to the top-left corner of the desktop.

### Method
GET

### Endpoint
/window/outer_position

### Parameters
None

### Request Example
(No request body for GET requests)

### Response
#### Success Response (200)
- **outer_position** (PhysicalPosition<i32>) - The position of the window.

#### Response Example
```json
{
  "outer_position": {"x": 95, "y": 95}
}
```

## GET /window/inner_size

### Description
Retrieves the physical size of the window's client area (excluding title bar and borders).

### Method
GET

### Endpoint
/window/inner_size

### Parameters
None

### Request Example
(No request body for GET requests)

### Response
#### Success Response (200)
- **inner_size** (PhysicalSize<u32>) - The physical size of the window's client area.

#### Response Example
```json
{
  "inner_size": {"width": 800, "height": 600}
}
```

## GET /window/outer_size

### Description
Retrieves the physical size of the entire window, including the title bar and borders.

### Method
GET

### Endpoint
/window/outer_size

### Parameters
None

### Request Example
(No request body for GET requests)

### Response
#### Success Response (200)
- **outer_size** (PhysicalSize<u32>) - The physical size of the entire window.

#### Response Example
```json
{
  "outer_size": {"width": 816, "height": 638}
}
```

## POST /window/center

### Description
Centers the window on the screen.

### Method
POST

### Endpoint
/window/center

### Parameters
None

### Request Example
(No request body for POST requests)

### Response
#### Success Response (200)
(No response body for successful centering)

#### Response Example
(No response body)
```

--------------------------------

### WebviewWindowBuilder::from_config

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Creates a new WebviewWindowBuilder from a given configuration. This is useful for initializing a webview window with pre-defined settings.

```APIDOC
## POST /websites/rs-tauri/WebviewWindowBuilder/from_config

### Description
Creates a new WebviewWindowBuilder from a given configuration.

### Method
POST

### Endpoint
/websites/rs-tauri/WebviewWindowBuilder/from_config

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **manager** (M) - Required - The manager object.
- **config** (WindowConfig) - Required - The window configuration.

### Request Example
```json
{
  "manager": "<manager_object>",
  "config": {
    "label": "my-window",
    "url": "tauri://index.html"
  }
}
```

### Response
#### Success Response (200)
- **WebviewWindowBuilder** (Self) - The created WebviewWindowBuilder instance.

#### Response Example
```json
{
  "window_builder": {
    "label": "my-window",
    "url": "tauri://index.html"
  },
  "webview_builder": {
    "url": "tauri://index.html"
  }
}
```
```

--------------------------------

### Rust: Tauri PathResolver Parse Method Example

Source: https://docs.rs/tauri/latest/src/tauri/path/mod

This example shows how to use the `parse` method of Tauri's `PathResolver` to interpret a path string that may contain a `BaseDirectory` variable. If a variable like `$HOME` is found, it's replaced with the actual home directory path. This is useful for handling user-defined paths.

```rust
use tauri::Manager;

tauri::Builder::default()
  .setup(|app| {
    let path = app.path().parse("$HOME/.bashrc")?;
    assert_eq!(path.to_str().unwrap(), "/home/${whoami}/.bashrc");
    Ok(())
  });

```

--------------------------------

### Example Remote URL Configuration JSON

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/acl/capability

Shows how to configure remote URLs for a capability using JSON. The `urls` array accepts patterns that define which remote domains the capability applies to.

```json
{
  "urls": ["https://*.mydomain.dev"]
}
```

--------------------------------

### WebviewWindow Builder API

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Provides a way to construct and configure new WebviewWindow instances.

```APIDOC
## POST /websites/rs-tauri/builder

### Description
Creates a new WebviewWindowBuilder.

### Method
POST

### Endpoint
/websites/rs-tauri/builder

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **manager** (Manager<R>) - Required - The manager for the window.
- **label** (L) - Required - The label for the window.
- **url** (WebviewUrl) - Required - The initial URL for the webview.

### Request Example
```json
{
  "manager": "...",
  "label": "main",
  "url": {
    "url": "https://tauri.app"
  }
}
```

### Response
#### Success Response (200)
- **WebviewWindowBuilder** - The created webview window builder.

#### Response Example
```json
{
  "builder": "..."
}
```
```

--------------------------------

### Example: Open Multiple Windows with Unique Labels (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/webview/webview_window

Shows how to open multiple instances of a window based on a configuration, ensuring each window has a unique label. This is achieved by modifying the cloned `WindowConfig`'s label before building the window.

```rust
#[tauri::command]
async fn open_window_multiple(app: tauri::AppHandle) {
  let mut conf = app.config().app.windows.iter().find(|c| c.label == "template-for-multiwindow").unwrap().clone();
  // This should be a unique label for all windows. For example, we can use a random suffix:
  // conf.label = format!("{}-{}", conf.label, rand::random::<u32>());
  // let webview_window = tauri::WebviewWindowBuilder::from_config(&app, &conf)
  //   .unwrap()
  //   .build()
  //   .unwrap();
}

```

--------------------------------

### WebviewWindowBuilder: Window Configuration Methods

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Provides methods to configure various properties of the webview window, such as menu, position, size, and resizability.

```APIDOC
## POST /webview/configure

### Description
Configures various properties of the webview window builder.

### Method
POST

### Endpoint
/webview/configure

### Parameters
#### Request Body
- **menu** (object) - Optional - Sets the menu for the window.
- **center** (boolean) - Optional - Centers the window on the screen.
- **position** (object) - Optional - Sets the initial position of the window. Requires `x` and `y` (number).
- **inner_size** (object) - Optional - Sets the inner size of the window. Requires `width` and `height` (number).
- **min_inner_size** (object) - Optional - Sets the minimum inner size of the window. Requires `min_width` and `min_height` (number).
- **max_inner_size** (object) - Optional - Sets the maximum inner size of the window. Requires `max_width` and `max_height` (number).
- **inner_size_constraints** (object) - Optional - Sets constraints for the window's inner size.
- **prevent_overflow** (boolean) - Optional - Prevents the window from overflowing the working area on creation.
- **prevent_overflow_with_margin** (object) - Optional - Prevents overflow with a specified margin. Requires `width` and `height` (number).
- **resizable** (boolean) - Optional - Determines if the window is resizable.
- **maximizable** (boolean) - Optional - Enables or disables the window's native maximize button.

### Request Example
```json
{
  "resizable": true,
  "inner_size": {
    "width": 800,
    "height": 600
  },
  "prevent_overflow": true
}
```

### Response
#### Success Response (200)
- **status** (string) - 'success' - Indicates the configuration was applied successfully.

#### Response Example
```json
{
  "status": "success"
}
```
```

--------------------------------

### Window Fullscreen Configuration

Source: https://docs.rs/tauri/latest/src/tauri/webview/webview_window

Sets whether the window should start in fullscreen mode.

```APIDOC
## POST /window/fullscreen

### Description
Sets whether the window should be in fullscreen mode upon creation.

### Method
POST

### Endpoint
/window/fullscreen

### Parameters
#### Request Body
- **fullscreen** (boolean) - Required - Whether the window should be fullscreen.

### Request Example
```json
{
  "fullscreen": true
}
```

### Response
#### Success Response (200)
- **message** (string) - Confirmation message.

#### Response Example
```json
{
  "message": "Window fullscreen property updated."
}
```
```

--------------------------------

### Open Multiple Windows with Unique Labels Example (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Demonstrates a strategy for opening multiple instances of a window that is initially defined by a configuration in `tauri.conf.json`. It involves cloning the configuration and assigning a unique label (e.g., with a random suffix) to each new window to avoid conflicts.

```rust
#[tauri::command]
async fn open_window_multiple(app: tauri::AppHandle) {
  let mut conf = app.config().app.windows.iter().find(|c| c.label == "template-for-multiwindow").unwrap().clone();
  // This should be a unique label for all windows. For example, we can use a random suffix:
  conf.label = format!("{}-{}", conf.label, rand::random::<u32>());
  let webview_window = tauri::WebviewWindowBuilder::from_config(&app, &conf)
    .unwrap()
    .build()
    .unwrap();
}

```

--------------------------------

### AppHandle: Create Tao Window (Wry Runtime)

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Allows creating a new Tao window using a provided closure. This function is specific to the Wry runtime and requires the event loop to be running. It returns a weak reference to the created Tao window.

```rust
pub fn create_tao_window<
    F: FnOnce() -> (String, tauri_runtime_wry::TaoWindowBuilder) + Send + 'static,
  >(
    &self,
    f: F,
  ) -> crate::Result<std::sync::Weak<tauri_runtime_wry::Window>> {
    self.runtime_handle.create_tao_window(f).map_err(Into::into)
  }
```

--------------------------------

### Taskbar and Overlay API (Platform-Specific)

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/mod

Endpoints for managing taskbar-related features, with platform-specific implementations.

```APIDOC
## POST /window/overlay-icon

### Description
Sets the overlay icon on the taskbar. This is **Windows only**.

### Method
POST

### Endpoint
`/window/overlay-icon`

### Parameters
#### Request Body
- **icon** (Image | null) - Optional - The image data for the overlay icon, or `null` to remove it.

### Request Example
```json
{
  "icon": "base64_encoded_image_data"
}
```

### Response
#### Success Response (200)
- **message** (string) - Confirmation message.

#### Response Example
```json
{
  "message": "Overlay icon set successfully."
}
```

## POST /window/badge-count

### Description
Sets the taskbar badge count. Using `0` or `None` will remove the badge.

### Method
POST

### Endpoint
`/window/badge-count`

### Parameters
#### Request Body
- **count** (integer | null) - Optional - The badge count to display, or `null` to remove it.

### Request Example
```json
{
  "count": 5
}
```

### Response
#### Success Response (200)
- **message** (string) - Confirmation message.

#### Response Example
```json
{
  "message": "Badge count set successfully."
}
```

## POST /window/badge-label

### Description
Sets the taskbar badge label. This is **macOS only**.

### Method
POST

### Endpoint
`/window/badge-label`

### Parameters
#### Request Body
- **label** (string | null) - Optional - The badge label to display, or `null` to remove it.

### Request Example
```json
{
  "label": "New"
}
```

### Response
#### Success Response (200)
- **message** (string) - Confirmation message.

#### Response Example
```json
{
  "message": "Badge label set successfully."
}
```

## POST /window/progress-bar

### Description
Sets the taskbar progress bar state.

### Method
POST

### Endpoint
`/window/progress-bar`

### Parameters
#### Request Body
- **progress_state** (ProgressBarState) - Required - An object containing the progress status and value.
  - **status** (string) - The status of the progress bar (e.g., 'normal', 'indeterminate', 'error', 'paused').
  - **progress** (float) - The progress value, between 0.0 and 1.0.

### Request Example
```json
{
  "progress_state": {
    "status": "normal",
    "progress": 0.75
  }
}
```

### Response
#### Success Response (200)
- **message** (string) - Confirmation message.

#### Response Example
```json
{
  "message": "Progress bar state set successfully."
}
```

## POST /window/title-bar-style

### Description
Sets the title bar style. This is **macOS only**.

### Method
POST

### Endpoint
`/window/title-bar-style`

### Parameters
#### Query Parameters
- **style** (TitleBarStyle) - Required - The desired title bar style (e.g., 'default', 'transparent').

### Request Example
```json
{
  "style": "transparent"
}
```

### Response
#### Success Response (200)
- **message** (string) - Confirmation message.

#### Response Example
```json
{
  "message": "Title bar style set successfully."
}
```
```

--------------------------------

### BeforeDev Command Configuration

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config_v1/mod

Defines shell commands to be executed before starting the `tauri dev` process.

```APIDOC
## BeforeDev Command Configuration

### Description
Configuration for shell commands that should be executed before the `tauri dev` command starts.

### Types
- **Script(String)**: Executes a given script string with default options.
- **ScriptWithOptions**:
    - **script** (String): The script to execute.
    - **cwd** (Option<String>): The current working directory for the script.
    - **wait** (bool): Whether `tauri dev` should wait for the command to finish. Defaults to `false`.
```

--------------------------------

### Rust: StateManager get() and try_get() methods

Source: https://docs.rs/tauri/latest/src/tauri/state

Provides methods to retrieve state managed by StateManager. `get()` panics if the state is not found, while `try_get()` returns an Option, allowing for graceful handling of missing state. Both require the state type `T` to be Send and Sync.

```rust
pub fn get<T: Send + Sync + 'static>(&self) -> State<'_, T> {
    self
      .try_get()
      .unwrap_or_else(|| panic!("state not found for type {}", std::any::type_name::<T>()))
}

/// Gets the state associated with the specified type.
pub fn try_get<T: Send + Sync + 'static>(&self) -> Option<State<'_, T>> {
    let map = self.map.lock().unwrap();
    let type_id = TypeId::of::<T>();
    let ptr = map.get(&type_id)?;
    let value = unsafe {
      ptr
        .downcast_ref::<T>()
        // SAFETY: the type of the key is the same as the type of the value
        .unwrap_unchecked()
    };
    // SAFETY: We ensure the lifetime of `value` is the same as [StateManager] and `value` will not be mutated/moved.
    let v_ref = unsafe { &*(value as *const T) };
    Some(State(v_ref))
}

```

--------------------------------

### Window Fullscreen Configuration

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Sets whether the window should start in fullscreen mode.

```APIDOC
## POST /window/config/fullscreen

### Description
Sets whether the window should start in fullscreen mode.

### Method
POST

### Endpoint
/window/config/fullscreen

### Parameters
#### Request Body
- **fullscreen** (boolean) - Required - Whether the window should be in fullscreen mode.

### Request Example
{
  "fullscreen": true
}

### Response
#### Success Response (200)
- **success** (boolean) - Indicates if the operation was successful.

#### Response Example
{
  "success": true
}
```

--------------------------------

### Register Global Menu Event Listener for Tauri Window (Rust)

Source: https://docs.rs/tauri/2/tauri/webview/struct

Provides an example of setting up a global menu event listener using `WebviewWindowBuilder::on_menu_event`. This allows handling menu actions across different windows and the tray icon.

```rust
use tauri::menu::{Menu, Submenu, MenuItem};
tauri::Builder::default()
  .setup(|app| {
    let handle = app.handle();
    let save_menu_item = MenuItem::new(handle, "Save", true, None::<&str>)?;
    let menu = Menu::with_items(handle, &[
      &Submenu::with_items(handle, "File", true, &[
        &save_menu_item,
      ])?,
    ])?;
    let webview_window = tauri::WebviewWindowBuilder::new(app, "editor", tauri::WebviewUrl::App("index.html".into()))
      .menu(menu)
      .on_menu_event(move |window, event| {
        if event.id == save_menu_item.id() {
          // save menu item
        }
      })
      .build()
      .unwrap();

    Ok(())
  });

```

--------------------------------

### Open Multiple Tauri Windows from Config in Command (Rust)

Source: https://docs.rs/tauri/2/tauri/webview/struct

Shows how to create multiple instances of a Tauri window from a base configuration using `WebviewWindowBuilder::from_config`. It highlights the necessity of assigning unique labels to each new window.

```rust
#[tauri::command]
async fn open_window_multiple(app: tauri::AppHandle) {
  let mut conf = app.config().app.windows.iter().find(|c| c.label == "template-for-multiwindow").unwrap().clone();
  // This should be a unique label for all windows. For example, we can use a random suffix:
  let mut buf = [0u8; 1];
  assert_eq!(getrandom::fill(&mut buf), Ok(()));
  conf.label = format!("my-multiwindow-{}", buf[0]);
  let webview_window = tauri::WebviewWindowBuilder::from_config(&app, &conf)
    .unwrap()
    .build()
    .unwrap();
}

```

--------------------------------

### Rust: Handle Webview Ready Events

Source: https://docs.rs/tauri/2.8.4/src/tauri/plugin

Sets a callback that is executed when a webview is ready. This allows for direct interaction with the `Webview` object immediately after its creation, such as logging or initial setup.

```rust
pub fn on_webview_ready<F>(mut self, on_webview_ready: F) -> Self
where
  F: FnMut(Webview<R>) + Send + 'static,
{
  self.on_webview_ready = Box::new(on_webview_ready);
  self
}
```

--------------------------------

### Application Build and Run

Source: https://docs.rs/tauri/2.8.5/tauri/struct

Methods for building and running the configured Tauri application.

```APIDOC
## POST /build

### Description
Builds the application with the provided context.

### Method
POST

### Endpoint
`/build`

### Parameters
#### Request Body
- **context** (Context<R>) - Required - The application context.

### Request Example
```json
{
  "context": {
    "bin_path": "path/to/binary",
    "config": {},
    "dev_path": "path/to/dev"
  }
}
```

### Response
#### Success Response (200)
- **app** (App<R>) - The built application instance.

#### Response Example
```json
{
  "app": { ... }
}
```

## POST /run

### Description
Builds the configured application and runs it. This is a shorthand for `Self::build` followed by `App::run`. For more flexibility, consider using those functions manually.

### Method
POST

### Endpoint
`/run`

### Parameters
#### Request Body
- **context** (Context<R>) - Required - The application context.

### Request Example
```json
{
  "context": {
    "bin_path": "path/to/binary",
    "config": {},
    "dev_path": "path/to/dev"
  }
}
```

### Response
#### Success Response (200)
- **result** (Result<()>) - Indicates the success or failure of running the application.

#### Response Example
```json
{
  "result": "Ok()"
}
```
```

--------------------------------

### Get Available Monitors (Rust)

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

Retrieves a list of all available monitors connected to the system. Each monitor is wrapped and converted into a displayable format.

```rust
fn available_monitors(&self) -> Vec<MonitorHandleWrapper> {
    self.context.window_id_map.values().map(|w| MonitorHandleWrapper(w.monitor.clone().unwrap())).collect()
}
```

--------------------------------

### AssetResolver API

Source: https://docs.rs/tauri/latest/src/tauri/app

Provides methods to get and iterate over application assets.

```APIDOC
## GET /asset/resolve

### Description
Retrieves an application asset based on its path. This method attempts to infer the correct URL scheme and falls back to reading from the distribution directory if necessary.

### Method
GET

### Endpoint
`/asset/resolve`

### Parameters
#### Query Parameters
- **path** (string) - Required - The path to the asset.
- **use_https_scheme** (boolean) - Optional - If `true`, uses `https://tauri.localhost` for the CSP header; otherwise, `http://tauri.localhost`.

### Request Example
```json
{
  "path": "index.html",
  "use_https_scheme": true
}
```

### Response
#### Success Response (200)
- **asset** (Asset) - The requested asset, containing bytes, mime type, and CSP header.

#### Response Example
```json
{
  "asset": {
    "bytes": "PGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PkhlbGxvLCBXb3JsZCE8L2JvZHk+PC9odG1s>",
    "mime_type": "text/html",
    "csp_header": "default-src 'self' https://tauri.localhost"
  }
}
```

## GET /assets

### Description
Iterates over all available application assets.

### Method
GET

### Endpoint
`/assets`

### Parameters
None

### Response
#### Success Response (200)
- **assets_iterator** (AssetsIter) - An iterator yielding all assets.

### Response Example
(Response is an iterator, not a direct JSON object)

## POST /windows/create

### Description
Creates a new Tao window using a callback function. This operation requires the event loop to be running.

### Method
POST

### Endpoint
`/windows/create`

### Parameters
#### Request Body
- **callback** (function) - Required - A function that returns the window title and a `TaoWindowBuilder`.

### Request Example
(Example would depend on the specific callback implementation)

### Response
#### Success Response (200)
- **window** (Weak<Window>) - A weak reference to the newly created Tao window.

#### Response Example
(Response is a weak reference, not a direct JSON object)

## POST /windows/:window_id/send_event

### Description
Sends a window message to the event loop for a specific Tao window.

### Method
POST

### Endpoint
`/windows/:window_id/send_event`

### Parameters
#### Path Parameters
- **window_id** (TaoWindowId) - Required - The ID of the target Tao window.

#### Request Body
- **message** (WindowMessage) - Required - The message to send to the window.

### Request Example
```json
{
  "message": {
    "event": "CustomEvent",
    "payload": "some data"
  }
}
```

### Response
#### Success Response (200)
- **success** (boolean) - Indicates if the message was sent successfully.

#### Response Example
```json
{
  "success": true
}
```
```

--------------------------------

### MockWindowDispatcher: Show Window (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/test/mock_runtime

A placeholder implementation for showing the mock window. It currently does nothing and always returns Ok(()).

```rust
fn show(&self) -> Result<()> {
  Ok(())
}
```

--------------------------------

### AssetResolver: Get Application Assets

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Provides methods to retrieve application assets. The `get` method resolves assets based on the application's URL scheme, with fallbacks to the distribution directory. The `get_for_scheme` method allows explicit control over the URL scheme used for resolution. It handles embedded assets in development and production, ensuring consistency with the `distDir`.

```rust
pub fn get(&self, path: String) -> Option<Asset> {
    let use_https_scheme = self
      .manager
      .webviews()
      .values()
      .all(|webview| webview.use_https_scheme());
    self.get_for_scheme(path, use_https_scheme)
  }

  pub fn get_for_scheme(&self, path: String, use_https_scheme: bool) -> Option<Asset> {
    #[cfg(dev)]
    {
      if let (Some(_), Some(crate::utils::config::FrontendDist::Directory(dist_path))) = (
        &self.manager.config().build.dev_url,
        &self.manager.config().build.frontend_dist,
      ) {
        let asset_path = std::path::PathBuf::from(&path)
          .components()
          .filter(|c| !matches!(c, std::path::Component::RootDir))
          .collect::<std::path::PathBuf>();

        let asset_path = self
          .manager
          .config_parent()
          .map(|p| p.join(dist_path).join(&asset_path))
          .unwrap_or_else(|| dist_path.join(&asset_path));
        return std::fs::read(asset_path).ok().map(|bytes| {
          let mime_type = crate::utils::mime_type::MimeType::parse(&bytes, &path);
          Asset {
            bytes,
            mime_type,
            csp_header: None,
          }
        });
      }
    }

    self.manager.get_asset(path, use_https_scheme).ok()
  }
```

--------------------------------

### WebviewWindow Core Functionality

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Provides core functionalities for the WebviewWindow, including its structure, comparison, and command argument handling.

```APIDOC
## WebviewWindow Core Functionality

### Description
This section details the `WebviewWindow` struct and its associated implementations, covering its basic structure, how it's compared with other instances, and how it can be used as a command argument.

### Struct Definition

```rust
pub struct WebviewWindow<R: Runtime> {
  pub window: Window<R>,
  pub webview: Webview<R>,
}
```

### Implementations

#### `AsRef<Webview<R>>`

*   **Description**: Allows a `WebviewWindow` to be referenced as a `Webview`.

#### `Clone`

*   **Description**: Enables cloning of a `WebviewWindow` instance.

#### `Eq` and `PartialEq`

*   **Description**: Defines equality comparison for `WebviewWindow` instances. Equality is determined solely by the `Webview`'s label.
*   **Method**: `eq(&self, other: &Self) -> bool`

#### `HasWindowHandle` and `HasDisplayHandle`

*   **Description**: Provides access to the underlying window and display handles for the `WebviewWindow`.

#### `CommandArg<'de, R>`

*   **Description**: Enables the `WebviewWindow` to be used as an argument in commands, allowing extraction of the `Window` and `Webview` from a `CommandItem`.
*   **Method**: `from_command(command: CommandItem<'de, R>) -> Result<Self, InvokeError>`
    *   **Parameters**: `command` (CommandItem<'de, R>) - The command item to extract the `WebviewWindow` from.
    *   **Returns**: A `Result` containing the `WebviewWindow` or an `InvokeError` if the current webview is not a `WebviewWindow`.

### Initialization

*   **Method**: `WebviewWindow::new(label: &str, url: &str) -> Result<Self, WebviewError>` (Conceptual, based on context)
    *   **Description**: Initializes a new `WebviewWindow` with a given label and URL. This is a common starting point for creating a webview window.
    *   **Parameters**:
        *   `label` (string) - Required - The unique label for the webview window.
        *   `url` (string) - Required - The initial URL to load in the webview.
    *   **Returns**: A `Result` containing the newly created `WebviewWindow` or a `WebviewError` if initialization fails.
```

--------------------------------

### Window Information Retrieval

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Methods for getting the title of the window and information about the monitors it interacts with.

```APIDOC
## GET /window/title

### Description
Gets the current title of the window.

### Method
GET

### Endpoint
/window/title

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **title** (string) - The current title of the window.

#### Response Example
```json
{
  "title": "My Tauri App"
}
```

## GET /window/monitor/current

### Description
Returns the monitor on which the window currently resides. Returns None if the current monitor cannot be detected.

### Method
GET

### Endpoint
/window/monitor/current

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **monitor** (object | null) - An object containing monitor details, or null if not detected.
  - **id** (string) - Unique identifier for the monitor.
  - **name** (string) - Name of the monitor.
  - **position** (object) - The top-left corner of the monitor. 
    - **x** (number) - X-coordinate.
    - **y** (number) - Y-coordinate.
  - **size** (object) - The dimensions of the monitor.
    - **width** (number) - Width of the monitor.
    - **height** (number) - Height of the monitor.
  - **scale_factor** (number) - The scale factor of the monitor.
  - **is_primary** (boolean) - Indicates if this is the primary monitor.

#### Response Example
```json
{
  "monitor": {
    "id": "\\\\.\\DISPLAY1",
    "name": "Generic Monitor",
    "position": {
      "x": 0,
      "y": 0
    },
    "size": {
      "width": 1920,
      "height": 1080
    },
    "scale_factor": 1.0,
    "is_primary": true
  }
}
```

## GET /window/monitor/from-point

### Description
Returns the monitor that contains the given point (x, y).

### Method
GET

### Endpoint
/window/monitor/from-point

### Parameters
#### Query Parameters
- **x** (number) - Required - The x-coordinate.
- **y** (number) - Required - The y-coordinate.

### Request Example
None

### Response
#### Success Response (200)
- **monitor** (object | null) - An object containing monitor details, or null if no monitor contains the point.
  - **id** (string) - Unique identifier for the monitor.
  - **name** (string) - Name of the monitor.
  - **position** (object) - The top-left corner of the monitor. 
    - **x** (number) - X-coordinate.
    - **y** (number) - Y-coordinate.
  - **size** (object) - The dimensions of the monitor.
    - **width** (number) - Width of the monitor.
    - **height** (number) - Height of the monitor.
  - **scale_factor** (number) - The scale factor of the monitor.
  - **is_primary** (boolean) - Indicates if this is the primary monitor.

#### Response Example
```json
{
  "monitor": {
    "id": "\\\\.\\DISPLAY1",
    "name": "Generic Monitor",
    "position": {
      "x": 0,
      "y": 0
    },
    "size": {
      "width": 1920,
      "height": 1080
    },
    "scale_factor": 1.0,
    "is_primary": true
  }
}
```

## GET /window/monitor/primary

### Description
Returns the primary monitor of the system. Returns None if it can't identify any monitor as a primary one.

### Method
GET

### Endpoint
/window/monitor/primary

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **monitor** (object | null) - An object containing primary monitor details, or null if not detected.
  - **id** (string) - Unique identifier for the monitor.
  - **name** (string) - Name of the monitor.
  - **position** (object) - The top-left corner of the monitor. 
    - **x** (number) - X-coordinate.
    - **y** (number) - Y-coordinate.
  - **size** (object) - The dimensions of the monitor.
    - **width** (number) - Width of the monitor.
    - **height** (number) - Height of the monitor.
  - **scale_factor** (number) - The scale factor of the monitor.
  - **is_primary** (boolean) - Indicates if this is the primary monitor.

#### Response Example
```json
{
  "monitor": {
    "id": "\\\\.\\DISPLAY1",
    "name": "Generic Monitor",
    "position": {
      "x": 0,
      "y": 0
    },
    "size": {
      "width": 1920,
      "height": 1080
    },
    "scale_factor": 1.0,
    "is_primary": true
  }
}
```

## GET /window/monitors/available

### Description
Returns the list of all the monitors available on the system.

### Method
GET

### Endpoint
/window/monitors/available

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **monitors** (array) - An array of monitor objects.
  - Each object contains:
    - **id** (string) - Unique identifier for the monitor.
    - **name** (string) - Name of the monitor.
    - **position** (object) - The top-left corner of the monitor. 
      - **x** (number) - X-coordinate.
      - **y** (number) - Y-coordinate.
    - **size** (object) - The dimensions of the monitor.
      - **width** (number) - Width of the monitor.
      - **height** (number) - Height of the monitor.
    - **scale_factor** (number) - The scale factor of the monitor.
    - **is_primary** (boolean) - Indicates if this is the primary monitor.

#### Response Example
```json
{
  "monitors": [
    {
      "id": "\\\\.\\DISPLAY1",
      "name": "Generic Monitor",
      "position": {
        "x": 0,
        "y": 0
      },
      "size": {
        "width": 1920,
        "height": 1080
      },
      "scale_factor": 1.0,
      "is_primary": true
    },
    {
      "id": "\\\\.\\DISPLAY2",
      "name": "Another Monitor",
      "position": {
        "x": 1920,
        "y": 0
      },
      "size": {
        "width": 1600,
        "height": 900
      },
      "scale_factor": 1.25,
      "is_primary": false
    }
  ]
}
```
```

--------------------------------

### Webview Download Handler API

Source: https://docs.rs/tauri/latest/src/tauri/webview/mod

Configures a closure to handle download events. Returning `false` from the handler can prevent a download from starting.

```APIDOC
## POST /webview/download

### Description
Sets a download event handler to be notified when a download is requested or finished. Returning `false` prevents the download from happening on a [`DownloadEvent::Requested`] event.

### Method
POST

### Endpoint
/webview/download

### Parameters
#### Request Body
- **f** (Fn(Webview<R>, DownloadEvent<'_>) -> bool + Send + Sync + 'static) - Required - A closure that takes a Webview instance and a DownloadEvent, returning a boolean to indicate if the download should proceed.

### Request Example
```json
{
  "f": "<closure_definition>"
}
```

### Response
#### Success Response (200)
- **Self** (WebviewBuilder<R>) - Returns the modified WebviewBuilder instance for chaining.

#### Response Example
```json
{
  "message": "WebviewBuilder updated successfully"
}
```
```

--------------------------------

### WebviewWindowBuilder::from_config

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Creates a new WebviewWindowBuilder from a given configuration.

```APIDOC
## POST /websites/rs-tauri/from_config

### Description
Creates a new WebviewWindowBuilder from a given configuration.

### Method
POST

### Endpoint
/websites/rs-tauri/from_config

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **manager** (object) - Required - The window manager.
- **config** (object) - Required - The window configuration.

### Request Example
{
  "manager": "...",
  "config": {
    "label": "my-window",
    "url": "https://example.com"
  }
}

### Response
#### Success Response (200)
- **WebviewWindowBuilder** (object) - The created WebviewWindowBuilder instance.

#### Response Example
{
  "webview_builder": {
    "config": {
      "label": "my-window",
      "url": "https://example.com"
    }
  }
}
```

--------------------------------

### Create Webview Window Builder

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Initializes a WebviewWindowBuilder for creating new webview windows. It requires a manager, a label, and a URL. The `webview-data-url` feature flag is necessary for supporting data URLs.

```rust
/// Data URLs are only supported with the `webview-data-url` feature flag.
pub fn builder<M: Manager<R>, L: Into<String>>(
  manager: &M,
  label: L,
  url: WebviewUrl,
) -> WebviewWindowBuilder<'_, R, M> {
  WebviewWindowBuilder::new(manager, label, url)
}
```

--------------------------------

### Monitor API

Source: https://docs.rs/tauri/latest/src/tauri/app

Provides methods to get information about the system's monitors.

```APIDOC
## GET /tauri/monitors

### Description
Retrieves a list of all available monitors connected to the system.

### Method
GET

### Endpoint
/tauri/monitors

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **monitors** (array) - A list of monitor objects.
  - **id** (integer) - Unique identifier for the monitor.
  - **name** (string) - The name of the monitor.
  - **scale_factor** (float) - The scale factor of the monitor.
  - **position** (object) - The position of the monitor on the desktop.
    - **x** (float) - The x-coordinate of the monitor's top-left corner.
    - **y** (float) - The y-coordinate of the monitor's top-left corner.
  - **size** (object) - The dimensions of the monitor.
    - **width** (float) - The width of the monitor.
    - **height** (float) - The height of the monitor.
  - **is_primary** (boolean) - Indicates if this is the primary monitor.

#### Response Example
```json
{
  "monitors": [
    {
      "id": 0,
      "name": "Display 1",
      "scale_factor": 1.0,
      "position": {"x": 0, "y": 0},
      "size": {"width": 1920, "height": 1080},
      "is_primary": true
    }
  ]
}
```
```

--------------------------------

### Plugin Initialization Script

Source: https://docs.rs/tauri/2.8.5/src/tauri/plugin

Configures a JavaScript initialization script to be executed on all frames within the webview.

```APIDOC
## POST /websites/rs-tauri/js_init_script_on_all_frames

### Description
Configures a JavaScript initialization script to run on all frames.

### Method
POST

### Endpoint
/websites/rs-tauri/js_init_script_on_all_frames

### Parameters
#### Request Body
- **js_init_script** (string) - Required - The JavaScript code to execute.

### Request Example
```json
{
  "js_init_script": "console.log('Initializing script...')"
}
```

### Response
#### Success Response (200)
- **Self** (object) - Returns the updated builder instance.

#### Response Example
```json
{
  "message": "Script configured successfully"
}
```
```

--------------------------------

### Get Window Label

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Retrieves the label of the current window.

```APIDOC
## Get Window Label

### Description
Retrieves the label of the current window.

### Method
`GET`

### Endpoint
`/websites/rs-tauri/{window_label}/label`

### Parameters
#### Path Parameters
- **window_label** (string) - Required - The label of the window.

#### Query Parameters
None

#### Request Body
None

### Request Example
`GET /websites/rs-tauri/my-window/label`

### Response
#### Success Response (200)
- **label** (string) - The label of the window.

#### Response Example
```json
{
  "label": "my-window"
}
```
```

--------------------------------

### Initialize Tauri Plugin with Drag Script (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/plugin

Initializes the Tauri window plugin, including a JavaScript script for drag-and-drop functionality. The script path is relative to the project, and it dynamically includes the OS name.

```rust
pub fn init<R: Runtime>() -> TauriPlugin<R> {
  use serialize_to_javascript::{default_template, DefaultTemplate, Template};

  let mut init_script = String::new();

  #[derive(Template)]
  #[default_template("./scripts/drag.js")]
  struct Drag<'a> {
    os_name: &'a str,
  }

  init_script.push_str(
    &Drag {
      os_name: std::env::consts::OS,
    }
    .render_default(&Default::default())
    .unwrap()
    .into_string(),
  );

  Builder::new("window")
    .js_init_script(init_script)
    .invoke_handler(
      #[cfg(desktop)]
      crate::generate_handler![
        #![plugin(window)]
        desktop_commands::create,
        // getters
        desktop_commands::get_all_windows,
        desktop_commands::scale_factor,
        desktop_commands::inner_position,
        desktop_commands::outer_position,
        desktop_commands::inner_size,
        desktop_commands::outer_size,
        desktop_commands::is_fullscreen,
        desktop_commands::is_minimized,
        desktop_commands::is_maximized,
        desktop_commands::is_focused,
        desktop_commands::is_decorated,
        desktop_commands::is_resizable,
        desktop_commands::is_maximizable,
        desktop_commands::is_minimizable,
        desktop_commands::is_closable,
        desktop_commands::is_visible,
        desktop_commands::is_enabled,
        desktop_commands::title,
        desktop_commands::current_monitor,
        desktop_commands::primary_monitor,
        desktop_commands::monitor_from_point,
        desktop_commands::available_monitors,
        desktop_commands::cursor_position,
        desktop_commands::theme,
        desktop_commands::is_always_on_top,
        // setters
        desktop_commands::center,
        desktop_commands::request_user_attention,
        desktop_commands::set_resizable,
        desktop_commands::set_maximizable,
        desktop_commands::set_minimizable,
        desktop_commands::set_closable,
        desktop_commands::set_title,
        desktop_commands::maximize,
        desktop_commands::unmaximize,
        desktop_commands::minimize,
        desktop_commands::unminimize,
        desktop_commands::show,
        desktop_commands::hide,
        desktop_commands::close,
        desktop_commands::destroy,
        desktop_commands::set_decorations,
        desktop_commands::set_shadow,
        desktop_commands::set_effects,
        desktop_commands::set_always_on_top,
        desktop_commands::set_always_on_bottom,
        desktop_commands::set_content_protected,
      ]
    )
    .build()
}
```

--------------------------------

### Monitor Information

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Provides methods to get information about the monitors connected to the system.

```APIDOC
## GET /window/current_monitor

### Description
Returns the monitor on which the window currently resides. Returns None if current monitor can't be detected.

### Method
GET

### Endpoint
/window/current_monitor

### Response
#### Success Response (200)
- **monitor** (Monitor) - The current monitor object.

#### Response Example
```json
{
  "monitor": {
    "name": "monitor name",
    "size": {
      "width": 1920,
      "height": 1080
    },
    "position": {
      "x": 0,
      "y": 0
    },
    "scale_factor": 1.0
  }
}
```

## GET /window/primary_monitor

### Description
Returns the primary monitor of the system. Returns None if it can't identify any monitor as a primary one.

### Method
GET

### Endpoint
/window/primary_monitor

### Response
#### Success Response (200)
- **monitor** (Monitor) - The primary monitor object.

#### Response Example
```json
{
  "monitor": {
    "name": "monitor name",
    "size": {
      "width": 1920,
      "height": 1080
    },
    "position": {
      "x": 0,
      "y": 0
    },
    "scale_factor": 1.0
  }
}
```

## GET /window/monitor_from_point

### Description
Returns the monitor that contains the given point.

### Method
GET

### Endpoint
/window/monitor_from_point

### Query Parameters
- **x** (number) - Required - The x-coordinate of the point.
- **y** (number) - Required - The y-coordinate of the point.

### Response
#### Success Response (200)
- **monitor** (Monitor) - The monitor object containing the point.

#### Response Example
```json
{
  "monitor": {
    "name": "monitor name",
    "size": {
      "width": 1920,
      "height": 1080
    },
    "position": {
      "x": 0,
      "y": 0
    },
    "scale_factor": 1.0
  }
}
```

## GET /window/available_monitors

### Description
Returns the list of all the monitors available on the system.

### Method
GET

### Endpoint
/window/available_monitors

### Response
#### Success Response (200)
- **monitors** (array) - An array of Monitor objects.

#### Response Example
```json
{
  "monitors": [
    {
      "name": "monitor name 1",
      "size": {
        "width": 1920,
        "height": 1080
      },
      "position": {
        "x": 0,
        "y": 0
      },
      "scale_factor": 1.0
    },
    {
      "name": "monitor name 2",
      "size": {
        "width": 1600,
        "height": 900
      },
      "position": {
        "x": 1920,
        "y": 0
      },
      "scale_factor": 1.0
    }
  ]
}
```
```

--------------------------------

### GET /url

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Retrieves the current URL being displayed by the webview.

```APIDOC
## GET /url

### Description
Returns the current url of the webview.

### Method
GET

### Endpoint
`/url`

### Parameters
None

### Response
#### Success Response (200)
- **url** (string) - The current URL of the webview.

#### Response Example
```json
{
  "url": "https://tauri.app"
}
```
```

--------------------------------

### Mobile Entry Point Macro for Tauri

Source: https://docs.rs/tauri/-macros/2.4.0/src/tauri_macros/lib

The `#[mobile_entry_point]` attribute macro is used to designate the entry point for Tauri applications on mobile platforms. It handles the necessary setup and initialization required for mobile execution environments. This macro is part of Tauri's internal mechanisms.

```rust
#[proc_macro_attribute]
pub fn mobile_entry_point(attributes: TokenStream, item: TokenStream) -> TokenStream {
  mobile::entry_point(attributes, item)
}
```

--------------------------------

### Get Inner Window Size on Non-macOS (Rust)

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/x86_64-unknown-linux-gnu/src/tauri_runtime_wry/lib

This function provides a platform-agnostic way to get the inner window size, primarily used on systems other than macOS. It directly returns the window's inner size, ignoring webview specifics. The `#[allow(unused_variables)]` attribute indicates that the `webviews` and `has_children` parameters might not be used on this platform.

```rust
#[cfg(not(target_os = "macos"))]
#[allow(unused_variables)]
fn inner_size(
  window: &Window,
  webviews: &[WebviewWrapper],
  has_children: bool,
) -> TaoPhysicalSize<u32> {
  window.inner_size()
```

--------------------------------

### WixLanguageConfig

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Configuration for a specific language locale within the Wix installer.

```APIDOC
## WixLanguageConfig

### Description
Configuration for a specific language locale (`.wxl` file) used in the WiX installer.

### Method
N/A (Configuration Structure)

### Endpoint
N/A (Configuration Structure)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **locale_path** (string) - Optional - The path to a locale (`.wxl`) file.

### Request Example
```json
{
  "locale_path": "path/to/your/locale.wxl"
}
```

### Response
#### Success Response (200)
N/A (Configuration Structure)

#### Response Example
N/A (Configuration Structure)
```

--------------------------------

### Initialize Runtime (Rust)

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

Initializes the Wry runtime with a given `EventLoop`. It sets up the necessary context, including window management, thread IDs, and web context.

```rust
fn init(event_loop: EventLoop<Message<T>>) -> Result<Self> {
    let main_thread_id = current_thread().id();
    let web_context = WebContextStore::default();

    let windows = Arc::new(WindowsStore(RefCell::new(BTreeMap::default())));
    let window_id_map = WindowIdStore::default();

    let context = Context {
      window_id_map,
      main_thread_id,
      proxy: event_loop.create_proxy(),
      main_thread: DispatcherMainThreadContext {
        window_target: event_loop.deref().clone(),
        web_context,
        windows,
        #[cfg(feature = "tracing")]
        active_tracing_spans: Default::default(),
       },
      plugins: Default::default(),
      next_window_id: Default::default(),
      next_webview_id: Default::default(),
      next_window_event_id: Default::default(),
      next_webview_event_id: Default::default(),
      webview_runtime_installed: wry::webview_version().is_ok(),
    };

    Ok(Self {
      context,
      event_loop,
    })
}
```

--------------------------------

### Tauri App Configuration and Info Access (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Provides access to the application's configuration and package information. The `config` method returns a reference to the `Config` struct loaded from `tauri.conf.json`, while `package_info` returns details about the application's package. These methods are essential for understanding the application's setup and metadata.

```rust
macro_rules! shared_app_impl {
  ($app: ty) => {
    impl<R: Runtime> $app {
      /// Gets the app's configuration, defined on the `tauri.conf.json` file.
      pub fn config(&self) -> &Config {
        self.manager.config()
      }

      /// Gets the app's package information.
      pub fn package_info(&self) -> &PackageInfo {
        self.manager.package_info()
      }
      // ... other methods ...
    }
  };
}
```

--------------------------------

### Create Tauri Asset Instance

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/assets

Constructs a new instance of the Assets struct from a provided map of static string keys to byte slices, a static slice of global CSP hashes, and a map of static string keys to static slices of CSP hashes for HTML assets. This is the primary method for initializing the asset store.

```rust
pub const fn new(
    map: phf::Map<&'static str, &'static [u8]>,
    global_hashes: &'static [CspHash<'static>],
    html_hashes: phf::Map<&'static str, &'static [CspHash<'static>]>,
  ) -> Self {
    Self {
      assets: map,
      global_hashes,
      html_hashes,
    }
  }
```

--------------------------------

### Get Submenu Text

Source: https://docs.rs/tauri/latest/src/tauri/menu/submenu

Retrieves the current text label of the submenu.

```APIDOC
## GET /menus/submenu/text

### Description
Get the text for this submenu.

### Method
GET

### Endpoint
`/menus/submenu/text`

### Response
#### Success Response (200)
- **String** - The text label of the submenu.

#### Response Example
```json
"Submenu Title"
```
```

--------------------------------

### Creating a New Tokio Runtime

Source: https://docs.rs/tauri/2.8.4/tauri/async_runtime/struct

Demonstrates how to create a new Tokio runtime instance with default configuration. This function initializes the multi-threaded scheduler, I/O driver, and time driver. It returns a Result, indicating potential errors during creation. This is an alternative to the `#[tokio::main]` attribute for more complex setups.

```rust
use tokio::runtime::Runtime;

let rt = Runtime::new()
    .unwrap();

// Use the runtime...
```

--------------------------------

### Initialize WebView with Context and Attributes

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

This snippet shows the initialization of a WebView builder in Rust using Tauri. It extracts necessary attributes from a pending WebView and configures the builder with various settings, including URL, transparency, and focus. It also handles the management of web contexts, ensuring they persist across webview instances.

```rust
use std::collections::HashSet;
use std::sync::{Arc, Mutex};

use wry::webview_protocol::WryDragDropEvent;
use wry::webview_protocol::DragDropEvent;
use wry::util::backend::WryWebContext;
use std::collections::hash_map::Entry::{Occupied, Vacant};
use tauri_utils::config::BackgroundThrottlingPolicy;

// Assuming necessary imports and definitions for PendingWebview, WebviewWrapper, Error, WebContext, Wry, etc.

// Placeholder for actual context and pending data structures
struct Context<T, Wry> { 
    main_thread: MainThread<T, Wry>,
    webview_runtime_installed: bool,
    proxy: Arc<tauri_async_runtime::TokioSender<crate::runtime::channel_event::ChannelEvent>>
}

struct MainThread<T, Wry> {
    web_context: Mutex<std::collections::HashMap<String, WebContext>>
}

struct PendingWebview<T, Wry> {
    webview_attributes: WebviewAttributes,
    uri_scheme_protocols: Vec<()>, // Placeholder type
    label: String,
    ipc_handler: Option<Box<dyn Fn(&Window, Message) -> bool + Send + Sync>>,
    url: String
}

struct WebviewAttributes {
    focus: bool,
    transparent: bool,
    accept_first_mouse: bool,
    incognito: bool,
    clipboard: bool,
    zoom_hotkeys_enabled: bool,
    webview_configuration: Option<()>, // Placeholder type
    use_https_scheme: bool,
    background_throttling: Option<BackgroundThrottlingPolicy>,
    javascript_disabled: bool,
    background_color: Option<String>,
    drag_drop_handler_enabled: bool,
    data_directory: String
}

struct WebContext {
    inner: WryWebContext,
    referenced_by_webviews: HashSet<String>,
    registered_custom_protocols: HashSet<()>
}

impl WryWebContext {
    fn new(key: String) -> Self { unimplemented!() }
    fn set_allows_automation(&mut self, allowed: bool) { unimplemented!() }
}

struct WebViewBuilder;

impl WebViewBuilder {
    fn new_with_web_context(web_context: &mut WryWebContext) -> Self { unimplemented!() }
    fn with_id(self, id: &str) -> Self { unimplemented!() }
    fn with_focused(self, focus: bool) -> Self { unimplemented!() }
    fn with_transparent(self, transparent: bool) -> Self { unimplemented!() }
    fn with_accept_first_mouse(self, accept: bool) -> Self { unimplemented!() }
    fn with_incognito(self, incognito: bool) -> Self { unimplemented!() }
    fn with_clipboard(self, clipboard: bool) -> Self { unimplemented!() }
    fn with_hotkeys_zoom(self, enabled: bool) -> Self { unimplemented!() }
    #[cfg(target_os = "macos")]
    fn with_webview_configuration(self, config: ()) -> Self { unimplemented!() }
    #[cfg(any(target_os = "windows", target_os = "android"))]
    fn with_https_scheme(self, use_https: bool) -> Self { unimplemented!() }
    fn with_background_throttling(self, policy: wry::BackgroundThrottlingPolicy) -> Self { unimplemented!() }
    fn with_javascript_disabled(self) -> Self { unimplemented!() }
    fn with_background_color(self, color: (u8, u8, u8, u8)) -> Self { unimplemented!() }
    fn with_drag_drop_handler<F>(self, handler: F) -> Self where F: Fn(WryDragDropEvent) -> bool + Send + Sync + 'static { unimplemented!() }
    fn with_url(self, url: &str) -> Self { unimplemented!() }
}

enum Error { WebviewRuntimeNotInstalled } 

struct Window;
struct Message;

fn create_webview_wrapper<T, Wry>(context: Context<T, Wry>, pending: PendingWebview<T, Wry>, window_id: String) -> Result<WebviewWrapper> {
    #[cfg(all(not(debug_assertions), windows))]
    if !context.webview_runtime_installed {
        // dialog::error(...);
        return Err(Error::WebviewRuntimeNotInstalled);
    }

    let PendingWebview { 
        webview_attributes, 
        uri_scheme_protocols, 
        label, 
        ipc_handler, 
        url, 
        .. 
    } = pending;

    let mut web_context = context.main_thread.web_context.lock().expect("poisoned WebContext store");
    let is_first_context = web_context.is_empty();
    let automation_enabled = std::env::var("TAURI_WEBVIEW_AUTOMATION").as_deref() == Ok("true");
    let web_context_key = webview_attributes.data_directory;
    let entry = web_context.entry(web_context_key.clone());
    let web_context = match entry {
        Occupied(occupied) => {
            let occupied = occupied.into_mut();
            occupied.referenced_by_webviews.insert(label.clone());
            occupied
        },
        Vacant(vacant) => {
            let mut web_context = WryWebContext::new(web_context_key.clone());
            web_context.set_allows_automation(if automation_enabled { is_first_context } else { false });
            vacant.insert(WebContext {
                inner: web_context,
                referenced_by_webviews: [label.clone()].into(),
                registered_custom_protocols: HashSet::new()
            })
        }
    };

    let mut webview_builder = WebViewBuilder::new_with_web_context(&mut web_context.inner)
        .with_id(&label)
        .with_focused(webview_attributes.focus)
        .with_transparent(webview_attributes.transparent)
        .with_accept_first_mouse(webview_attributes.accept_first_mouse)
        .with_incognito(webview_attributes.incognito)
        .with_clipboard(webview_attributes.clipboard)
        .with_hotkeys_zoom(webview_attributes.zoom_hotkeys_enabled);

    if url != "about:blank" {
        webview_builder = webview_builder.with_url(&url);
    }

    #[cfg(target_os = "macos")]
    if let Some(webview_configuration) = webview_attributes.webview_configuration {
        webview_builder = webview_builder.with_webview_configuration(webview_configuration);
    }

    #[cfg(any(target_os = "windows", target_os = "android"))]
    {
        webview_builder = webview_builder.with_https_scheme(webview_attributes.use_https_scheme);
    }

    if let Some(background_throttling) = webview_attributes.background_throttling {
        webview_builder = webview_builder.with_background_throttling(match background_throttling {
            BackgroundThrottlingPolicy::Disabled => wry::BackgroundThrottlingPolicy::Disabled,
            BackgroundThrottlingPolicy::Suspend => wry::BackgroundThrottlingPolicy::Suspend,
            BackgroundThrottlingPolicy::Throttle => wry::BackgroundThrottlingPolicy::Throttle,
        });
    }

    if webview_attributes.javascript_disabled {
        webview_builder = webview_builder.with_javascript_disabled();
    }

    if let Some(color) = webview_attributes.background_color {
        // Assuming color is parseable into (u8, u8, u8, u8)
        let color_tuple = (0, 0, 0, 0); // Placeholder
        webview_builder = webview_builder.with_background_color(color_tuple);
    }

    if webview_attributes.drag_drop_handler_enabled {
        let proxy = context.proxy.clone();
        let window_id_ = window_id.clone();
        webview_builder = webview_builder.with_drag_drop_handler(move |event|
            let event = match event {
                WryDragDropEvent::Enter { paths, position: (x, y) } => DragDropEvent::Enter {
                    paths,
                    position: PhysicalPosition::new(x as _, y as _)
                },
                WryDragDropEvent::Over { position: (x, y) } => DragDropEvent::Over {
                    position: PhysicalPosition::new(x as _, y as _)
                },
                WryDragDropEvent::Drop { paths, position: (x, y) } => DragDropEvent::Drop {
                    paths,
                    position: PhysicalPosition::new(x as _, y as _)
                },
                WryDragDropEvent::Leave => DragDropEvent::Leave,
                _ => unimplemented!(),
            };
            true // Placeholder return value
        );
    }

    // Placeholder for the actual creation and return of WebviewWrapper
    struct WebviewWrapper;
    struct PhysicalPosition<T> { x: T, y: T }
    type Result<T> = std::result::Result<T, Error>;
    Ok(WebviewWrapper)
}

```

--------------------------------

### Get Menu Item

Source: https://docs.rs/tauri/latest/src/tauri/menu/submenu

Retrieves a menu item from the submenu based on its ID.

```APIDOC
## GET /menus/submenu/item/{id}

### Description
Retrieves the menu item matching the given identifier.

### Method
GET

### Endpoint
`/menus/submenu/item/{id}`

### Parameters
#### Path Parameters
- **id** (`&I`) - Required - The identifier of the menu item to retrieve.

### Response
#### Success Response (200)
- **MenuItemKind<R>** - The found menu item.

#### Response Example
```json
{
  "id": "ItemId",
  "text": "Item Text"
}
```
```

--------------------------------

### Runtime Interface

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

Defines the essential methods for interacting with the webview runtime, including window and webview creation, event loop proxying, and accessing runtime handles.

```APIDOC
## Runtime Interface

### Description
The `Runtime` trait provides a set of methods for managing webview windows and their associated functionalities. It allows for the creation of new windows and webviews, interaction with the event loop, and access to platform-specific features.

### Methods

*   **`new(args: RuntimeInitArgs) -> Result<Self>`**: Creates a new webview runtime. Must be used on the main thread.
*   **`new_any_thread(args: RuntimeInitArgs) -> Result<Self>`**: Creates a new webview runtime on any thread. (Platform-specific: Windows, Linux)
*   **`create_proxy(&self) -> Self::EventLoopProxy`**: Creates an `EventLoopProxy` that can be used to dispatch user events to the main event loop.
*   **`handle(&self) -> Self::Handle`**: Gets a runtime handle.
*   **`create_window<F: Fn(RawWindow) + Send + 'static>(&self, pending: PendingWindow<T, Self>, after_window_creation: Option<F>) -> Result<DetachedWindow<T, Self::Runtime>>`**: Creates a new window.
*   **`create_webview(&self, window_id: WindowId, pending: PendingWebview<T, Self::Runtime>) -> Result<DetachedWebview<T, Self::Runtime>>`**: Creates a new webview.
*   **`run_on_main_thread<F: FnOnce() + Send + 'static>(&self, f: F) -> Result<()>`**: Runs a task on the main thread.
*   **`display_handle(&self) -> std::result::Result<DisplayHandle<'_>, raw_window_handle::HandleError>`**: Gets a handle to the display controller of the windowing system.
*   **`primary_monitor(&self) -> Option<Monitor>`**: Returns the primary monitor of the system. Returns `None` if it can't identify any monitor as a primary one.
*   **`monitor_from_point(&self, x: f64, y: f64) -> Option<Monitor>`**: Returns the monitor that contains the given point.
*   **`available_monitors(&self) -> Vec<Monitor>`**: Returns the list of all the monitors available on the system.
*   **`cursor_position(&self) -> Result<PhysicalPosition<f64>>`**: Gets the cursor position relative to the top-left hand corner of the desktop.
*   **`set_theme(&self, theme: Option<Theme>)`**: Sets the app theme.
*   **`show(&self) -> Result<()>`**: Shows the application, but does not automatically focus it. (Platform-specific: macOS)
*   **`hide(&self) -> Result<()>`**: Hides the application. (Platform-specific: macOS)
*   **`set_device_event_filter(&self, filter: DeviceEventFilter)`**: Changes the device event filter mode.
*   **`find_class<'a>(&self, env: &mut jni::JNIEnv<'a>, activity: &jni::objects::JObject<'_>, name: impl Into<String>) -> std::result::Result<jni::objects::JClass<'a>, jni::errors::Error>`**: Finds an Android class in the project scope. (Platform-specific: Android)
*   **`run_on_android_context<F>(&self, f: F)`**: Dispatches a closure to run on the Android context. (Platform-specific: Android)
*   **`fetch_data_store_identifiers<F: FnOnce(Vec<[u8; 16]>) + Send + 'static>(&self, cb: F) -> Result<()>`**: Fetches data store identifiers. (Platform-specific: macOS, iOS)
*   **`remove_data_store<F: FnOnce(Result<()>) + Send + 'static>(&self, uuid: [u8; 16], cb: F) -> Result<()>`**: Removes a data store. (Platform-specific: macOS, iOS)

### Type Aliases

*   **`WindowDispatcher`**: The window message dispatcher.
*   **`WebviewDispatcher`**: The webview message dispatcher.
*   **`Handle`**: The runtime handle type.
*   **`EventLoopProxy`**: The proxy type.
```

--------------------------------

### Rust: Example of Testing Tauri Commands

Source: https://docs.rs/tauri/latest/src/tauri/test/mod

Demonstrates how to set up a testable Tauri application and invoke commands within a test environment. It utilizes `mock_builder` to create a mock runtime and `get_ipc_response` to simulate command calls and check their responses. Note that `tauri.conf.json` is required for `generate_context`.

```rust
use tauri::test::{mock_builder, mock_context, noop_assets};

#[tauri::command]
fn ping() -> &'static str {
    "pong"
}

fn create_app<R: tauri::Runtime>(builder: tauri::Builder<R>) -> tauri::App<R> {
    builder
        .invoke_handler(tauri::generate_handler![ping])
        // remove the string argument to use your app's config file
        .build(tauri::generate_context!("test/fixture/src-tauri/tauri.conf.json"))
        .expect("failed to build app")
}

fn main() {
    // Use `tauri::Builder::default()` to use the default runtime rather than the `MockRuntime`;
    // let app = create_app(tauri::Builder::default());
    let app = create_app(mock_builder());
    let webview = tauri::WebviewWindowBuilder::new(&app, "main", Default::default()).build().unwrap();

    // run the `ping` command and assert it returns `pong`
    let res = tauri::test::get_ipc_response(
        &webview,
        tauri::webview::InvokeRequest {
            cmd: "ping".into(),
            callback: tauri::ipc::CallbackFn(0),
            error: tauri::ipc::CallbackFn(1),
            // alternatively use "tauri://localhost"
            url: "http://tauri.localhost".parse().unwrap(),
            body: tauri::ipc::InvokeBody::default(),
            headers: Default::default(),
            invoke_key: tauri::test::INVOKE_KEY.to_string(),
        },
    ).map(|b| b.deserialize::<String>().unwrap());
}

```

--------------------------------

### Configure Fullscreen Mode in Rust Tauri

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Determines whether the window should start in fullscreen mode upon creation.

```rust
/// Whether to start the window in fullscreen or not.
#[must_use]
pub fn fullscreen(mut self, fullscreen: bool) -> Self {
  self.window_builder = self.window_builder.fullscreen(fullscreen);
  self
}
```

--------------------------------

### Rust Tauri: Create About App Menu Item

Source: https://docs.rs/tauri/latest/tauri/menu/struct

Creates an about app menu item. This item typically displays application information. It requires a manager and optional about metadata. Available on desktop platforms.

```rust
pub fn about<M: Manager<R>>( manager: &M, text: Option<&str>, metadata: Option<AboutMetadata<'_>>, ) -> Result<Self>
```

--------------------------------

### Cursor API

Source: https://docs.rs/tauri/latest/src/tauri/app

Provides methods to get the current cursor position.

```APIDOC
## GET /tauri/cursor-position

### Description
Gets the current cursor position relative to the top-left corner of the desktop.

### Method
GET

### Endpoint
/tauri/cursor-position

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **position** (object) - The physical position of the cursor.
  - **x** (float) - The x-coordinate of the cursor.
  - **y** (float) - The y-coordinate of the cursor.

#### Response Example
```json
{
  "position": {"x": 800.5, "y": 600.25}
}
```
```

--------------------------------

### Initialize Webview Builder (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/mod

Initializes a `WebviewBuilder` with a given window label and a URL to load. Supports data URLs if the `webview-data-url` feature is enabled.

```rust
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn builder<L: Into<String>>(label: L, url: WebviewUrl) -> WebviewBuilder<R> {
  WebviewBuilder::new(label.into(), url)
}
```

--------------------------------

### GET /theme

Source: https://docs.rs/tauri/2.8.5/src/tauri/window/mod

Retrieves the current theme of the window. This feature is only supported on macOS 10.14+.

```APIDOC
## GET /theme

### Description
Returns the current window theme. This is only supported on macOS 10.14+.

### Method
GET

### Endpoint
/theme

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **theme** (Theme) - The current theme of the window (e.g., "Light", "Dark").

#### Response Example
```json
{
  "theme": "Dark"
}
```
```

--------------------------------

### Define Initialization Script

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/webview

Represents a script to be run during WebView initialization. It includes the script content and a flag to specify if it should only be injected into the main frame.

```rust
pub struct InitializationScript {
  pub script: String,
  pub for_main_frame_only: bool,
}
```

--------------------------------

### MockWindowDispatcher Methods for Window Properties and Actions (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/test/mock_runtime

This snippet showcases various methods implemented in the MockWindowDispatcher for interacting with a mock Tauri window. It includes functions to evaluate JavaScript, get window URL, bounds, position, size, and perform actions like navigation, closing, and setting properties. These are mock implementations, often returning default values or unimplemented states.

```rust
fn eval_script<S: Into<String>>(&self, script: S) -> Result<()> {
    self
      .last_evaluated_script
      .lock()
      .unwrap()
      .replace(script.into());
    Ok(())
  }

  fn url(&self) -> Result<String> {
    Ok(self.url.lock().unwrap().clone())
  }

  fn bounds(&self) -> Result<tauri_runtime::dpi::Rect> {
    Ok(tauri_runtime::dpi::Rect::default())
  }

  fn position(&self) -> Result<PhysicalPosition<i32>> {
    Ok(PhysicalPosition { x: 0, y: 0 })
  }

  fn size(&self) -> Result<PhysicalSize<u32>> {
    Ok(PhysicalSize {
      width: 0,
      height: 0,
    })
  }

  fn navigate(&self, url: Url) -> Result<()> {
    *self.url.lock().unwrap() = url.to_string();
    Ok(())
  }

  fn reload(&self) -> Result<()> {
    Ok(())
  }

  fn print(&self) -> Result<()> {
    Ok(())
  }

  fn close(&self) -> Result<()> {
    Ok(())
  }

  fn set_bounds(&self, bounds: tauri_runtime::dpi::Rect) -> Result<()> {
    Ok(())
  }

  fn set_size(&self, _size: Size) -> Result<()> {
    Ok(())
  }

  fn set_position(&self, _position: Position) -> Result<()> {
    Ok(())
  }

  fn set_focus(&self) -> Result<()> {
    Ok(())
  }

  fn reparent(&self, window_id: WindowId) -> Result<()> {
    Ok(())
  }

  fn cookies(&self) -> Result<Vec<tauri_runtime::Cookie<'static>>> {
    Ok(Vec::new())
  }

  fn cookies_for_url(&self, url: Url) -> Result<Vec<tauri_runtime::Cookie<'static>>> {
    Ok(Vec::new())
  }

  fn set_cookie(&self, cookie: tauri_runtime::Cookie<'_>) -> Result<()> {
    Ok(())
  }

  fn delete_cookie(&self, cookie: tauri_runtime::Cookie<'_>) -> Result<()> {
    Ok(())
  }

  fn set_auto_resize(&self, auto_resize: bool) -> Result<()> {
    Ok(())
  }

  fn clear_all_browsing_data(&self) -> Result<()> {
    Ok(())
  }

  fn hide(&self) -> Result<()> {
    Ok(())
  }

  fn show(&self) -> Result<()> {
    Ok(())
  }

  fn set_background_color(&self, color: Option<tauri_utils::config::Color>) -> Result<()> {
    Ok(())
  }
```

--------------------------------

### Get Available Monitors (Rust)

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

Returns a list of all monitors available on the system. Returns a Result<Vec<Monitor>>.

```rust
/// Returns the list of all the monitors available on the system.
fn available_monitors(&self) -> Result<Vec<Monitor>>;
```

--------------------------------

### Get Focused Window

Source: https://docs.rs/tauri/2.8.4/src/tauri/lib

Retrieves the currently focused window in the application.

```APIDOC
## GET /focused_window

### Description
Fetches the currently focused window. Returns `None` if there is not any focused window.

*   **Stability**: Requires the `unstable` feature.

### Method
GET

### Endpoint
/focused_window

### Parameters
None

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **Option<Window<R>>** (Window | null) - The focused Window object if one exists, otherwise null.

#### Response Example
```json
{
  "label": "main",
  "title": "My App",
  "is_resizable": true
}
```
```

--------------------------------

### tauri_macros: mobile_entry_point Attribute Macro

Source: https://docs.rs/tauri/-macros/2.4.0/tauri_macros/index

The `mobile_entry_point` attribute macro is used to designate the entry point for Tauri applications on mobile platforms. It simplifies the setup for mobile builds.

```rust
/// Marks the entry point function for Tauri mobile applications.
///
/// # Example
///
/// ```rust
/// #[tauri_macros::mobile_entry_point]
/// fn run_app() {
///     tauri::Builder::default()
///         .run(tauri::generate_context!());
/// }
/// ```
```

--------------------------------

### Handle WebView2Loader.dll Copy for Windows GNU Toolchain

Source: https://docs.rs/tauri/-build/latest/src/tauri_build/lib

This snippet handles the copying of the `WebView2Loader.dll` for Windows builds targeting the GNU toolchain. It iterates through build artifacts to find the correct DLL and copies it to the main target directory. This is essential for the WebView2 runtime to function correctly on Windows with the GNU toolchain.

```rust
    let target_env = env::var("CARGO_CFG_TARGET_ENV").unwrap();
    match target_env.as_str() {
      "gnu" => {
        let target_arch = match env::var("CARGO_CFG_TARGET_ARCH").unwrap().as_str() {
          "x86_64" => Some("x64"),
          "x86" => Some("x86"),
          "aarch64" => Some("arm64"),
          arch => None,
        };
        if let Some(target_arch) = target_arch {
          for entry in fs::read_dir(target_dir.join("build"))? {
            let path = entry?.path();
            let webview2_loader_path = path
              .join("out")
              .join(target_arch)
              .join("WebView2Loader.dll");
            if path.to_string_lossy().contains("webview2-com-sys") && webview2_loader_path.exists() {
              fs::copy(webview2_loader_path, target_dir.join("WebView2Loader.dll"))?;
              break;
            }
          }
        }
      }
      "msvc" => {
        if env::var("STATIC_VCRUNTIME").is_ok_and(|v| v == "true") {
          static_vcruntime::build();
        }
      }
      _ => (),
    }
```

--------------------------------

### WixConfig

Source: https://docs.rs/tauri/-utils/2.7.0/src/tauri_utils/config

Configuration for the MSI bundle using WiX. This structure allows customization of various aspects of the Windows Installer package.

```APIDOC
## WixConfig

### Description
Configuration for the MSI bundle using WiX. Allows customization of installer version, upgrade codes, languages, templates, fragments, and UI elements.

### Method
N/A (Configuration Structure)

### Endpoint
N/A (Configuration Structure)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **version** (string) - Optional - MSI installer version in the format `major.minor.patch.build`. Defaults to `Config::version` if not set.
- **upgrade_code** (uuid::Uuid) - Optional - A GUID upgrade code for MSI installer. Must remain consistent across updates.
- **language** (WixLanguage) - Optional - The installer languages to build. Defaults to `WixLanguage::One("en-US".into())`.
- **template** (PathBuf) - Optional - A custom `.wxs` template to use.
- **fragment_paths** (array of PathBuf) - Optional - A list of paths to `.wxs` files with WiX fragments to use.
- **component_group_refs** (array of string) - Optional - The ComponentGroup element IDs to reference from fragments.
- **component_refs** (array of string) - Optional - The Component element IDs to reference from fragments.
- **feature_group_refs** (array of string) - Optional - The FeatureGroup element IDs to reference from fragments.
- **feature_refs** (array of string) - Optional - The Feature element IDs to reference from fragments.
- **merge_refs** (array of string) - Optional - The Merge element IDs to reference from fragments.
- **enable_elevated_update_task** (boolean) - Optional - Create an elevated update task within Windows Task Scheduler. Defaults to `false`.
- **banner_path** (PathBuf) - Optional - Path to a bitmap file for the installer banner (493px  58px).
- **dialog_image_path** (PathBuf) - Optional - Path to a bitmap file for installer dialogs (493px  312px).
- **fips_compliant** (boolean) - Optional - Enables FIPS compliant algorithms. Defaults to `false`.

### Request Example
```json
{
  "version": "1.0.0",
  "upgrade_code": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
  "language": {
    "Localized": {
      "en-US": {
        "locale_path": "path/to/en-US.wxl"
      }
    }
  },
  "template": "path/to/custom.wxs",
  "fragment_paths": ["path/to/fragment1.wxs", "path/to/fragment2.wxs"],
  "component_group_refs": ["MyComponentGroup1"],
  "component_refs": ["MyComponent1"],
  "feature_group_refs": ["MyFeatureGroup1"],
  "feature_refs": ["MyFeature1"],
  "merge_refs": ["MyMerge1"],
  "enable_elevated_update_task": true,
  "banner_path": "path/to/banner.bmp",
  "dialog_image_path": "path/to/dialog.bmp",
  "fips_compliant": true
}
```

### Response
#### Success Response (200)
N/A (Configuration Structure)

#### Response Example
N/A (Configuration Structure)
```

--------------------------------

### Tauri Window Configuration Methods (Rust)

Source: https://docs.rs/tauri/2.8.5/src/tauri/test/mock_runtime

This Rust code defines a series of methods for configuring a Tauri window. These methods allow for setting window dimensions, resizability, title, fullscreen mode, and various other visual and behavioral properties. Some methods are conditional based on the target operating system or feature flags.

```rust
fn center(self) -> Self {
    self
  }

  fn position(self, x: f64, y: f64) -> Self {
    self
  }

  fn inner_size(self, min_width: f64, min_height: f64) -> Self {
    self
  }

  fn min_inner_size(self, min_width: f64, min_height: f64) -> Self {
    self
  }

  fn max_inner_size(self, max_width: f64, max_height: f64) -> Self {
    self
  }

  fn inner_size_constraints(
    self,
    constraints: tauri_runtime::window::WindowSizeConstraints,
  ) -> Self {
    self
  }

  fn prevent_overflow(self) -> Self {
    self
  }

  fn prevent_overflow_with_margin(self, margin: tauri_runtime::dpi::Size) -> Self {
    self
  }

  fn resizable(self, resizable: bool) -> Self {
    self
  }

  fn maximizable(self, resizable: bool) -> Self {
    self
  }

  fn minimizable(self, resizable: bool) -> Self {
    self
  }

  fn closable(self, resizable: bool) -> Self {
    self
  }

  fn title<S: Into<String>>(self, title: S) -> Self {
    self
  }

  fn fullscreen(self, fullscreen: bool) -> Self {
    self
  }

  fn focused(self, focused: bool) -> Self {
    self
  }

  fn focusable(self, focusable: bool) -> Self {
    self
  }

  fn maximized(self, maximized: bool) -> Self {
    self
  }

  fn visible(self, visible: bool) -> Self {
    self
  }

  #[cfg(any(not(target_os = "macos"), feature = "macos-private-api"))]
  #[cfg_attr(
    docsrs,
    doc(cfg(any(not(target_os = "macos"), feature = "macos-private-api")))
  )]
  fn transparent(self, transparent: bool) -> Self {
    self
  }

  fn decorations(self, decorations: bool) -> Self {
    self
  }

  fn always_on_bottom(self, always_on_bottom: bool) -> Self {
    self
  }

  fn always_on_top(self, always_on_top: bool) -> Self {
    self
  }

  fn visible_on_all_workspaces(self, visible_on_all_workspaces: bool) -> Self {
    self
  }

  fn content_protected(self, protected: bool) -> Self {
    self
  }

  fn icon(self, icon: Icon<'_>) -> Result<Self> {
    Ok(self)
  }

  fn skip_taskbar(self, skip: bool) -> Self {
    self
  }

  fn window_classname<S: Into<String>>(self, classname: S) -> Self {
    self
  }

  fn shadow(self, enable: bool) -> Self {
    self
  }

  #[cfg(windows)]
  fn owner(self, owner: HWND) -> Self {
    self
  }

  #[cfg(windows)]
  fn parent(self, parent: HWND) -> Self {
    self
  }

  #[cfg(target_os = "macos")]
  fn parent(self, parent: *mut std::ffi::c_void) -> Self {
    self
  }

  #[cfg(any(
    target_os = "linux",
    target_os = "dragonfly",
    target_os = "freebsd",
    target_os = "netbsd",
    target_os = "openbsd"
  ))]
  fn transient_for(self, parent: &impl gtk::glib::IsA<gtk::Window>) -> Self {
    self
  }

  #[cfg(windows)]
  fn drag_and_drop(self, enabled: bool) -> Self {
    self
  }

  #[cfg(target_os = "macos")]
  fn title_bar_style(self, style: TitleBarStyle) -> Self {
    self
  }

  #[cfg(target_os = "macos")]
  fn traffic_light_position<P: Into<Position>>(self, position: P) -> Self {
    self
  }

  #[cfg(target_os = "macos")]
  fn hidden_title(self, transparent: bool) -> Self {
    self
  }

  #[cfg(target_os = "macos")]
  fn tabbing_identifier(self, identifier: &str) -> Self {
    self
  }

  fn theme(self, theme: Option<Theme>) -> Self {
    self
  }

  fn has_icon(&self) -> bool {
    false
  }

  fn get_theme(&self) -> Option<Theme> {
    None
  }

  fn background_color(self, _color: tauri_utils::config::Color) -> Self {
    self
  }
}

```

--------------------------------

### Webview Ready Handling

Source: https://docs.rs/tauri/2.8.5/tauri/plugin/struct

Registers a callback that is triggered when a webview instance is created and ready.

```APIDOC
## POST /plugin/on_webview_ready

### Description
Callback invoked when the webview is created.

### Method
POST

### Endpoint
/plugin/on_webview_ready

### Parameters
#### Request Body
- **on_webview_ready** (function) - Required - A callback function that receives the created `Webview` object.

### Request Example
```json
{
  "on_webview_ready": "function(webview) { console.log(`Webview created: ${webview.label()}`); }"
}
```

### Response
#### Success Response (200)
- **message** (string) - Indicates the webview ready handler has been set.

#### Response Example
```json
{
  "message": "Webview ready handler set."
}
```
```

--------------------------------

### Rust: Get and Set CheckMenuItem properties

Source: https://docs.rs/tauri/2.8.5/src/tauri/menu/check

This set of methods allows retrieval and modification of a CheckMenuItem's properties. Methods include getting the associated application handle (`app_handle`), its unique identifier (`id`), its text (`text`), its enabled state (`is_enabled`), and its checked state (`is_checked`). Corresponding setter methods (`set_text`, `set_enabled`, `set_accelerator`, `set_checked`) are also provided to modify these properties.

```rust
impl<R: Runtime> CheckMenuItem<R> {
  /// The application handle associated with this type.
  pub fn app_handle(&self) -> &AppHandle<R> {
    &self.0.app_handle
  }

  /// Returns a unique identifier associated with this menu item.
  pub fn id(&self) -> &MenuId {
    &self.0.id
  }

  /// Get the text for this menu item.
  pub fn text(&self) -> crate::Result<String> {
    run_item_main_thread!(self, |self_: Self| (*self_.0).as_ref().text())
  }

  /// Set the text for this menu item. `text` could optionally contain
  /// an `&` before a character to assign this character as the mnemonic
  /// for this menu item. To display a `&` without assigning a mnemenonic, use `&&`.
  pub fn set_text<S: AsRef<str>>(&self, text: S) -> crate::Result<()> {
    let text = text.as_ref().to_string();
    run_item_main_thread!(self, |self_: Self| (*self_.0).as_ref().set_text(text))
  }

  /// Get whether this menu item is enabled or not.
  pub fn is_enabled(&self) -> crate::Result<bool> {
    run_item_main_thread!(self, |self_: Self| (*self_.0).as_ref().is_enabled())
  }

  /// Enable or disable this menu item.
  pub fn set_enabled(&self, enabled: bool) -> crate::Result<()> {
    run_item_main_thread!(self, |self_: Self| (*self_.0).as_ref().set_enabled(enabled))
  }

  /// Set this menu item accelerator.
  pub fn set_accelerator<S: AsRef<str>>(&self, accelerator: Option<S>) -> crate::Result<()> {
    let accel = accelerator.and_then(|s| s.as_ref().parse().ok());
    run_item_main_thread!(self, |self_: Self| {
      (*self_.0).as_ref().set_accelerator(accel)
    })? \
    .map_err(Into::into)
  }

  /// Get whether this check menu item is checked or not.
  pub fn is_checked(&self) -> crate::Result<bool> {
    run_item_main_thread!(self, |self_: Self| (*self_.0).as_ref().is_checked())
  }

  /// Check or Uncheck this check menu item.
  pub fn set_checked(&self, checked: bool) -> crate::Result<()> {
    run_item_main_thread!(self, |self_: Self| (*self_.0).as_ref().set_checked(checked))
  }
}

```

--------------------------------

### Window Configuration Methods

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/window

This section details methods for configuring various aspects of a Tauri window, such as transient behavior, drag and drop, title bar appearance, and theming.

```APIDOC
## Window Configuration Methods

### Description
Provides methods to configure window properties like transient parent, drag and drop, title bar style, traffic light position, hidden title, tabbing identifier, theme, window class name, and icon status.

### Methods

- **`transient_for(self, parent: &impl gtk::glib::IsA<gtk::Window>) -> Self`**: Sets the window as transient for a parent window. (Linux/Unix specific)
- **`drag_and_drop(self, enabled: bool) -> Self`**: Enables or disables drag and drop support for the window. (Windows specific)
- **`title_bar_style(self, style: tauri_utils::TitleBarStyle) -> Self`**: Sets the style of the window's title bar. (macOS specific)
- **`traffic_light_position<P: Into<dpi::Position>>(self, position: P) -> Self`**: Changes the position of window controls on macOS.
- **`hidden_title(self, hidden: bool) -> Self`**: Hides the window title. (macOS specific)
- **`tabbing_identifier(self, identifier: &str) -> Self`**: Defines a tabbing identifier for macOS window grouping.
- **`theme(self, theme: Option<Theme>) -> Self`**: Forces a theme or uses system settings.
- **`window_classname<S: Into<String>>(self, window_classname: S) -> Self`**: Sets a custom window class name for Windows.

### Utility Methods

- **`has_icon(&self) -> bool`**: Checks if the window has an icon set.
- **`get_theme(&self) -> Option<Theme>`**: Retrieves the current theme of the window.
```

--------------------------------

### Add Tauri Plugin Dynamically (Rust)

Source: https://docs.rs/tauri/2.8.4/x86_64-unknown-linux-gnu/tauri/app/struct

Adds a Tauri application plugin that can be loaded dynamically, for example, after user authentication. For plugins initialized at app startup, use `Builder::plugin`.

```rust
pub fn plugin<P: Plugin<R> + 'static>(&self, plugin: P) -> Result<()>
```

```rust
use tauri::plugin::{Builder as PluginBuilder, TauriPlugin};

fn init_plugin<R: Runtime>() -> TauriPlugin<R> {
  PluginBuilder::new("dummy").build()
}

tauri::Builder::default()
  .setup(move |app| {
    let handle = app.handle().clone();
    std::thread::spawn(move || {
      handle.plugin(init_plugin());
    });

    Ok(())
  });
```

--------------------------------

### Rust: Mock Runtime Handle Implementation

Source: https://docs.rs/tauri/2.8.5/src/tauri/test/mock_runtime

Implements the `RuntimeHandle` trait for `MockRuntimeHandle`, providing mock functionalities for creating windows and managing proxies. This allows for testing Tauri applications without a full runtime environment. Methods like `create_window` simulate window creation by assigning IDs and managing internal state.

```rust
#[derive(Debug, Clone)]
pub struct MockRuntimeHandle {
  context: RuntimeContext,
}

impl<T: UserEvent> RuntimeHandle<T> for MockRuntimeHandle {
  type Runtime = MockRuntime;

  fn create_proxy(&self) -> EventProxy {
    EventProxy {}
  }

  #[cfg(target_os = "macos")]
  #[cfg_attr(docsrs, doc(cfg(target_os = "macos")))]
  fn set_activation_policy(
    &self,
    activation_policy: tauri_runtime::ActivationPolicy,
  ) -> Result<()> {
    Ok(())
  }

  #[cfg(target_os = "macos")]
  #[cfg_attr(docsrs, doc(cfg(target_os = "macos")))]
  fn set_dock_visibility(&self, visible: bool) -> Result<()> {
    Ok(())
  }

  fn request_exit(&self, code: i32) -> Result<()> {
    unimplemented!()
  }

  /// Create a new webview window.
  fn create_window<F: Fn(RawWindow<'_>) + Send + 'static>(
    &self,
    pending: PendingWindow<T, Self::Runtime>,
    _after_window_creation: Option<F>,
  ) -> Result<DetachedWindow<T, Self::Runtime>> {
    let id = self.context.next_window_id();

    let (webview_id, webviews) = if let Some(w) = &pending.webview {
      (Some(self.context.next_webview_id()), vec![Webview])
    } else {
      (None, Vec::new())
    };

    self.context.windows.borrow_mut().insert(
      id,
      Window {
        label: pending.label.clone(),
        webviews,
      },
    );

    let webview = webview_id.map(|id| DetachedWindowWebview {
      webview: DetachedWebview {
        label: pending.label.clone(),

```

--------------------------------

### Get Window Theme (Rust)

Source: https://docs.rs/tauri/-runtime/2.8.0/src/tauri_runtime/lib

Retrieves the current theme of the window. Returns a Result<Theme>.

```rust
/// Returns the current window theme.
fn theme(&self) -> Result<Theme>;
```

--------------------------------

### Webview Initialization Script for All Frames

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Configures a JavaScript script to be executed in all frames (main and sub-frames) of the webview after the global object is created but before the HTML document is parsed. Use with caution and consider `window.location` checks.

```APIDOC
## POST /webview/initialization_script_for_all_frames

### Description
Adds a JavaScript initialization script that runs in all frames (main and sub-frames) of the webview. It executes after the global object is created and before the HTML document is parsed.

### Method
POST

### Endpoint
`/webview/initialization_script_for_all_frames`

### Parameters
#### Request Body
- **script** (string) - Required - The JavaScript code to execute in all frames.

### Request Example
```json
{
  "script": "if (window.location.origin === 'https://example.com') { console.log('Script running in all frames.'); }"
}
```

### Response
#### Success Response (200)
- **message** (string) - Indicates successful configuration.

#### Response Example
```json
{
  "message": "Initialization script for all frames set successfully."
}
```
```

--------------------------------

### Open DevTools Example (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Demonstrates how to open the developer tools for a specific webview window in a Tauri application. This functionality is typically enabled only in debug builds or when the `devtools` feature is active.

```rust
  /// Opens the developer tools window (Web Inspector).
  /// The devtools is only enabled on debug builds or with the `devtools` feature flag.
  ///
  /// ## Platform-specific
  ///
  /// - **macOS:** Only supported on macOS 10.15+.
  ///   This is a private API on macOS, so you cannot use this if your application will be published on the App Store.
  ///
  /// # Examples
  ///
  #[cfg_attr(
    feature = "unstable",
    doc = r####"
1901```rust,no_run
1902use tauri::Manager;
tauri::Builder::default()
  .setup(|app| {
    #[cfg(debug_assertions)]
    app.get_webview("main").unwrap().open_devtools();
    Ok(())
  });
1903```
1904  "####
  )]
  
```

--------------------------------

### Get Menu Item Text

Source: https://docs.rs/tauri/2.8.5/src/tauri/menu/plugin

Retrieves the text of a specific menu item.

```APIDOC
## POST /text

### Description
Retrieves the text of a specific menu item.

### Method
POST

### Endpoint
`/text`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
- **rid** (ResourceId) - Required - The resource ID of the menu item's parent menu.
- **kind** (ItemKind) - Required - The type of the menu item (MenuItem, Submenu, etc.).

### Request Example
```json
{
  "rid": "menu-resource-id",
  "kind": "MenuItem"
}
```

### Response
#### Success Response (200)
- **String** - The text of the menu item.

#### Response Example
```json
"File"
```
```

--------------------------------

### Initialize Tauri Application Runtime and Event Handlers (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/app

Initializes the Tauri application runtime, including platform-specific configurations for Windows and Linux. It sets up event handlers for menu and tray icons, essential for desktop applications. This code prepares the application's core components and manages dependencies.

```rust
std::env::set_var("WEBVIEW2_BROWSER_EXECUTABLE_FOLDER", exe_dir.join(path));
}

#[cfg(any(windows, target_os = "linux"))]
let mut runtime = if self.runtime_any_thread {
  R::new_any_thread(runtime_args)?
} else {
  R::new(runtime_args)?
};
#[cfg(not(any(windows, target_os = "linux")))]
let mut runtime = R::new(runtime_args)?;

#[cfg(desktop)]
{
  // setup menu event handler
  let proxy = runtime.create_proxy();
  muda::MenuEvent::set_event_handler(Some(move |e: muda::MenuEvent| {
    let _ = proxy.send_event(EventLoopMessage::MenuEvent(e.into()));
  }));

  // setup tray event handler
  #[cfg(feature = "tray-icon")]
  {
    let proxy = runtime.create_proxy();
    tray_icon::TrayIconEvent::set_event_handler(Some(move |e: tray_icon::TrayIconEvent| {
      let _ = proxy.send_event(EventLoopMessage::TrayIconEvent(e.into()));
    }));
  }
}

runtime.set_device_event_filter(self.device_event_filter);

let runtime_handle = runtime.handle();

#[allow(unused_mut)]
let mut app = App {
  runtime: Some(runtime),
  setup: Some(self.setup),
  manager: manager.clone(),
  handle: AppHandle {
    runtime_handle,
    manager,
    event_loop: Arc::new(Mutex::new(EventLoop {
      main_thread_id: std::thread::current().id(),
    })),
  },
  ran_setup: false,
};

#[cfg(desktop)]
if let Some(menu) = self.menu {
  let menu = menu(&app.handle)?;
  app
    .manager
    .menu
    .menus_stash_lock()
    .insert(menu.id().clone(), menu.clone());

  #[cfg(target_os = "macos")]
  init_app_menu(&menu)?;

  app.manager.menu.menu_lock().replace(menu);
}

app.register_core_plugins()?;

let env = Env::default();
app.manage(env);

app.manage(Scopes {
  #[cfg(feature = "protocol-asset")]
  asset_protocol: crate::scope::fs::Scope::new(
    &app,
    &app.config().app.security.asset_protocol.scope,
  )?,
});

app.manage(ChannelDataIpcQueue::default());
app.handle.plugin(crate::ipc::channel::plugin())?;

let handle = app.handle();

// initialize default tray icon if defined
#[cfg(all(desktop, feature = "tray-icon"))]
{
  let config = app.config();
  if let Some(tray_config) = &config.app.tray_icon {
    #[allow(deprecated)]
    let mut tray =
      TrayIconBuilder::with_id(tray_config.id.clone().unwrap_or_else(|| "main".into()))
        .icon_as_template(tray_config.icon_as_template)
        .menu_on_left_click(tray_config.menu_on_left_click)
        .show_menu_on_left_click(tray_config.show_menu_on_left_click);
    if let Some(icon) = &app.manager.tray.icon {
      tray = tray.icon(icon.clone());
    }
    if let Some(title) = &tray_config.title {
      tray = tray.title(title);
    }
    if let Some(tooltip) = &tray_config.tooltip {
      tray = tray.tooltip(tooltip);
    }
    tray.build(handle)?;
  }
}

app.manager.initialize_plugins(handle)?;

Ok(app)
}

```

--------------------------------

### Get Application Package Information (Rust)

Source: https://docs.rs/tauri/2.8.4/x86_64-unknown-linux-gnu/tauri/app/struct

Retrieves a reference to the application's package information. This includes details such as the bundle identifier, version, and build information, typically populated from the project's configuration.

```rust
pub fn package_info(&self) -> &PackageInfo
```

--------------------------------

### Compile Windows Resources and Set Version Info in Tauri Build

Source: https://docs.rs/tauri/-build/latest/src/tauri_build/lib

This snippet handles the compilation of Windows resource files for Tauri applications. It utilizes the `tauri-winres` crate to set version information, product name, company name, file description, and legal copyright based on the Tauri configuration. It also handles finding and setting the application icon.

```rust
    use semver::Version;
    use tauri_winres::{VersionInfo, WindowsResource};

    fn find_icon<F: Fn(&&String) -> bool>(config: &Config, predicate: F, default: &str) -> PathBuf {
      let icon_path = config
        .bundle
        .icon
        .iter()
        .find(|i| predicate(i))
        .cloned()
        .unwrap_or_else(|| default.to_string());
      icon_path.into()
    }

    let window_icon_path = attributes
      .windows_attributes
      .window_icon_path
      .unwrap_or_else(|| find_icon(&config, |i| i.ends_with(".ico"), "icons/icon.ico"));

    let mut res = WindowsResource::new();

    if let Some(manifest) = attributes.windows_attributes.app_manifest {
      res.set_manifest(&manifest);
    }

    if let Some(version_str) = &config.version {
      if let Ok(v) = Version::parse(version_str) {
        let version = (v.major << 48) | (v.minor << 32) | (v.patch << 16);
        res.set_version_info(VersionInfo::FILEVERSION, version);
        res.set_version_info(VersionInfo::PRODUCTVERSION, version);
      }
    }

    if let Some(product_name) = &config.product_name {
      res.set("ProductName", product_name);
    }

    let company_name = config.bundle.publisher.unwrap_or_else(|| {
      config
        .identifier
        .split('.')
        .nth(1)
        .unwrap_or(&config.identifier)
        .to_string()
    });

    res.set("CompanyName", &company_name);

    let file_description = config
      .product_name
      .or_else(|| manifest.package.as_ref().map(|p| p.name.clone()))
      .or_else(|| std::env::var("CARGO_PKG_NAME").ok());

    res.set("FileDescription", &file_description.unwrap());

    if let Some(copyright) = &config.bundle.copyright {
      res.set("LegalCopyright", copyright);
    }

    if window_icon_path.exists() {
      res.set_icon_with_id(&window_icon_path.display().to_string(), "32512");
    } else {
      return Err(anyhow!(format!(
        "`{}` not found; required for generating a Windows Resource file during tauri-build",
        window_icon_path.display()
      )));
    }

    res.compile().with_context(|| {
      format!(
        "failed to compile `{}` into a Windows Resource file during tauri-build",
        window_icon_path.display()
      )
    })?;
```

--------------------------------

### Get Monitor From Point API

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Returns the monitor that contains the given point.

```APIDOC
## GET /monitor_from_point

### Description
Returns the monitor that contains the given point.

### Method
GET

### Endpoint
/monitor_from_point

### Parameters
#### Query Parameters
- **x** (number) - Required - The x-coordinate.
- **y** (number) - Required - The y-coordinate.

### Response
#### Success Response (200)
- **monitor** (object | null) - The monitor object containing the point or null if not found.

#### Response Example
```json
{
  "monitor": { ... } // or null
}
```
```

--------------------------------

### Initialize AppManager with Mock Runtime

Source: https://docs.rs/tauri/2.8.4/src/tauri/manager/mod

Sets up an AppManager instance using a mock runtime for testing purposes. It configures the manager with necessary components like context, plugin store, and state manager. This is part of the testing setup for Tauri applications.

```rust
@cfg(test)
mod test {
  use std::sync::mpsc::{channel, Receiver, Sender};
  use std::time::Duration;

  use crate::{
    event::EventTarget,
    generate_context,
    plugin::PluginStore,
    test::{mock_app, MockRuntime},
    webview::WebviewBuilder,
    window::WindowBuilder,
    App, Emitter, Listener, Manager, StateManager, Webview, WebviewWindow, WebviewWindowBuilder,
    Window,
    Wry,
  };

  use super::AppManager;

  const APP_LISTEN_ID: &str = "App::listen";
  const APP_LISTEN_ANY_ID: &str = "App::listen_any";
  const WINDOW_LISTEN_ID: &str = "Window::listen";
  const WINDOW_LISTEN_ANY_ID: &str = "Window::listen_any";
  const WEBVIEW_LISTEN_ID: &str = "Webview::listen";
  const WEBVIEW_LISTEN_ANY_ID: &str = "Webview::listen_any";
  const WEBVIEW_WINDOW_LISTEN_ID: &str = "WebviewWindow::listen";
  const WEBVIEW_WINDOW_LISTEN_ANY_ID: &str = "WebviewWindow::listen_any";
  const TEST_EVENT_NAME: &str = "event";

  #[test]
  fn check_get_url() {
    let context = generate_context!("test/fixture/src-tauri/tauri.conf.json", crate, test = true);
    let manager: AppManager<Wry> = AppManager::with_handlers(
      context,
      PluginStore::default(),
      Box::new(|_| false),
      None,
      Default::default(),
      StateManager::new(),
      Default::default(),
      #[cfg(all(desktop, feature = "tray-icon"))]
      Default::default(),
      Default::default(),
      Default::default(),
      Default::default(),
    );
  }
}
```

--------------------------------

### Initialize Tauri Application Context (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/manager/mod

This code snippet initializes the application context with various configurations and states. It sets up plugins, listeners, the application state, configuration, assets, and other necessary components for the Tauri application. The `Mutex` ensures thread-safe access to the plugins.

```Rust
plugins: Mutex::new(plugins),
listeners: Listeners::default(),
state: Arc::new(state),
config: context.config,
#[cfg(dev)]
config_parent: context.config_parent,
assets: context.assets,
app_icon: context.app_icon,
package_info: context.package_info,
pattern: Arc::new(context.pattern),
plugin_global_api_scripts: Arc::new(context.plugin_global_api_scripts),
resources_table: Arc::default(),
invoke_key,
channel_interceptor,
restart_on_exit: AtomicBool::new(false),
```

--------------------------------

### WebviewWindowBuilder::on_page_load

Source: https://docs.rs/tauri/latest/src/tauri/webview/webview_window

Registers a callback for page load events. The callback is invoked when a page starts or finishes loading.

```APIDOC
## POST /windows/webview

### Description
Registers a callback for page load events. The callback is invoked when a page starts or finishes loading.

### Method
POST

### Endpoint
`/windows/webview/on_page_load`

### Parameters
#### Query Parameters
- **event_type** (string) - Required - Specifies whether to listen for 'started' or 'finished' page load events.

#### Request Body
- **callback_url** (string) - Required - The URL to send the event data to.

### Request Example
```json
{
  "callback_url": "http://localhost:3000/event"
}
```

### Response
#### Success Response (200)
- **status** (string) - Indicates the success of the operation.

#### Response Example
```json
{
  "status": "ok"
}
```
```

--------------------------------

### On Webview Ready Callback

Source: https://docs.rs/tauri/latest/src/tauri/plugin

Registers a callback that is invoked when a webview instance is created. This callback provides access to the `Webview` object, allowing for setup or configuration immediately after its creation.

```APIDOC
## POST /websites/rs-tauri/on_webview_ready

### Description
Sets a callback to be invoked when a webview instance is created.

### Method
POST

### Endpoint
`/websites/rs-tauri/on_webview_ready`

### Parameters
#### Request Body
- **on_webview_ready** (function) - Required - The callback function that receives the created `Webview` object.

### Request Example
```json
{
  "on_webview_ready": "(webview) => console.log(`Webview ${webview.label} is ready`)"
}
```

### Response
#### Success Response (200)
- **Self** (object) - Returns the builder instance for chaining.

#### Response Example
```json
{
  "message": "Builder instance returned"
}
```
```

--------------------------------

### Get Window Label in Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Returns the unique label of the current window as a string slice.

```rust
/// The label of this window.
pub fn label(&self) -> &str {
  &self.window.label
}
```

--------------------------------

### POST /websites/rs-tauri/extensions_path

Source: https://docs.rs/tauri/2/tauri/webview/struct

Sets the directory path from which browser extensions should be loaded. Extensions must be unpacked Chrome extensions on Windows and compiled `.so` extensions on Linux. Browser extensions must be enabled first on Windows.

```APIDOC
## POST /websites/rs-tauri/extensions_path

### Description
Set the path from which to load extensions from. Extensions stored in this path should be unpacked Chrome extensions on Windows, and compiled `.so` extensions on Linux.

**Platform-specific:**
  * **Windows** : Browser extensions must first be enabled. See `browser_extensions_enabled`
  * **MacOS / iOS / Android** - Unsupported.

### Method
POST

### Endpoint
`/websites/rs-tauri/extensions_path`

### Parameters
#### Request Body
- **path** (string) - Required - The path to the directory containing extensions.

### Request Example
```json
{
  "path": "/path/to/extensions"
}
```

### Response
#### Success Response (200)
- **Self** (object) - The updated webview builder instance.

#### Response Example
```json
{
  "message": "Extensions path set successfully"
}
```
```

--------------------------------

### Create Tauri Webview Window in Async Command (Rust)

Source: https://docs.rs/tauri/2/tauri/webview/struct

Illustrates creating a webview window within an asynchronous Tauri command. This approach is recommended on Windows to prevent deadlocks, as it executes in a separate context.

```rust
#[tauri::command]
async fn create_window(app: tauri::AppHandle) {
  let webview_window = tauri::WebviewWindowBuilder::new(&app, "label", tauri::WebviewUrl::App("index.html".into()))
    .build()
    .unwrap();
}

```

--------------------------------

### Start Window Dragging (Rust)

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

Initiates the window dragging operation, allowing the user to move the window by clicking and dragging a specific area (often the title bar).

```rust
fn start_dragging(&self) -> Result<()>;

```

--------------------------------

### Window Dragging Operations

Source: https://docs.rs/tauri/-runtime/2.8.0/x86_64-unknown-linux-gnu/src/tauri_runtime/lib

Methods to initiate dragging and resizing operations for the window.

```APIDOC
## Window Dragging Operations

### `start_dragging`

Starts the window dragging operation.

*   **Method**: POST
*   **Endpoint**: `/window/start_dragging`
*   **Parameters**:
    *   **Path Parameters**: None
    *   **Query Parameters**: None
    *   **Request Body**: None

### `start_resize_dragging`

Starts the window resize-dragging operation.

*   **Method**: POST
*   **Endpoint**: `/window/start_resize_dragging`
*   **Parameters**:
    *   **Path Parameters**: None
    *   **Query Parameters**: None
    *   **Request Body**:
        *   `direction` (string) - Required - The direction of the resize (e.g., `left`, `right`, `up`, `down`, `topLeft`, `topRight`, `bottomLeft`, `bottomRight`).

```

--------------------------------

### POST /websites/rs-tauri/browser_extensions_enabled

Source: https://docs.rs/tauri/2/tauri/webview/struct

Determines whether browser extensions can be installed and used within the webview process. This setting is primarily effective on Windows.

```APIDOC
## POST /websites/rs-tauri/browser_extensions_enabled

### Description
Whether browser extensions can be installed for the webview process.

**Platform-specific:**
  * **Windows** : Enables the WebView2 environments `AreBrowserExtensionsEnabled`
  * **MacOS / Linux / iOS / Android** - Unsupported.

### Method
POST

### Endpoint
`/websites/rs-tauri/browser_extensions_enabled`

### Parameters
#### Request Body
- **enabled** (boolean) - Required - `true` to enable browser extensions, `false` to disable.

### Request Example
```json
{
  "enabled": true
}
```

### Response
#### Success Response (200)
- **Self** (object) - The updated webview builder instance.

#### Response Example
```json
{
  "message": "Browser extensions enabled state set successfully"
}
```
```

--------------------------------

### MockWindowDispatcher: Get Available Monitors (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/test/mock_runtime

Returns an empty vector of monitors. This mock implementation does not provide any information about available displays.

```rust
fn available_monitors(&self) -> Result<Vec<Monitor>> {
  Ok(Vec::new())
}
```

--------------------------------

### Window Resizing and Sizing

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/tauri_runtime_wry/struct

Methods for controlling the resizable state, minimum and maximum dimensions, and setting the window size.

```APIDOC
## Window Resizing and Sizing

### Description
Methods for controlling the resizable state, minimum and maximum dimensions, and setting the window size.

### `set_resizable`
#### Description
Updates the window resizable flag.

#### Method
`PUT` (or equivalent for internal state update)

#### Endpoint
`/websites/rs-tauri/window/resizable

#### Parameters
- **resizable** (boolean) - Required - Whether the window should be resizable.

### `set_size`
#### Description
Resizes the window to the specified dimensions.

#### Method
`PUT`

#### Endpoint
`/websites/rs-tauri/window/size

#### Parameters
- **size** (object) - Required - The new dimensions for the window. Should contain `width` and `height`.
  - **width** (number) - Required - The new width.
  - **height** (number) - Required - The new height.

### `set_min_size`
#### Description
Updates the window's minimum inner size constraints.

#### Method
`PUT`

#### Endpoint
`/websites/rs-tauri/window/min_size

#### Parameters
- **size** (object or null) - Optional - The minimum size for the window. If null, there is no minimum size.
  - **width** (number) - Required - The minimum width.
  - **height** (number) - Required - The minimum height.

### `set_max_size`
#### Description
Updates the window's maximum inner size constraints.

#### Method
`PUT`

#### Endpoint
`/websites/rs-tauri/window/max_size

#### Parameters
- **size** (object or null) - Optional - The maximum size for the window. If null, there is no maximum size.
  - **width** (number) - Required - The maximum width.
  - **height** (number) - Required - The maximum height.

### `set_size_constraints`
#### Description
Sets the window's minimum inner width and height.

#### Method
`PUT`

#### Endpoint
`/websites/rs-tauri/window/size_constraints

#### Parameters
- **constraints** (object) - Required - The size constraints for the window.
  - **min_width** (number) - Required - The minimum width.
  - **min_height** (number) - Required - The minimum height.
  - **max_width** (number) - Optional - The maximum width.
  - **max_height** (number) - Optional - The maximum height.

```

--------------------------------

### Configure Windows Resource from Cargo.toml (TOML)

Source: https://docs.rs/tauri/-winres/0.3.3/tauri_winres/struct

Example of how to specify custom Windows resource values within the `[package.metadata.tauri-winres]` section of a `Cargo.toml` file. These values override defaults.

```TOML
#Cargo.toml
[package.metadata.tauri-winres]
OriginalFilename = "testing.exe"
FileDescription = ""
LegalCopyright = "Copyright  2016"

```

--------------------------------

### MockWindowDispatcher: Get Primary Monitor (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/test/mock_runtime

Returns `None` to indicate that there is no primary monitor accessible to the mock window. This is a mock implementation.

```rust
fn primary_monitor(&self) -> Result<Option<Monitor>> {
  Ok(None)
}
```

--------------------------------

### Initialize Window Builder in Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Initializes a `WindowBuilder` for creating new windows with a specified label. Requires the `unstable` feature flag. Data URLs are supported only with the `webview-data-url` feature flag.

```rust
/// Initializes a window builder with the given window label.
///
/// Data URLs are only supported with the `webview-data-url` feature flag.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn builder<M: Manager<R>, L: Into<String>>(manager: &M, label: L) -> WindowBuilder<'_, R, M> {
  WindowBuilder::new(manager, label.into())
}
```

--------------------------------

### Resource Directory

Source: https://docs.rs/tauri/2.8.5/src/tauri/path/desktop

Function to get the path to the application's resource directory, with detailed platform-specific resolutions.

```APIDOC
## GET /resource-dir

### Description
Retrieves the path to the resource directory of the application. The exact path can vary based on the operating system and how the application is run (e.g., AppImage, development build).

### Method
GET

### Endpoint
/resource-dir

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **path** (string) - The path to the resource directory.

#### Response Example
{
  "path": "/usr/lib/my-app"
}

```

--------------------------------

### Context API

Source: https://docs.rs/tauri/2.8.5/src/tauri/lib

Methods for accessing and creating the application's context.

```APIDOC
## Context Methods

### Description
Provides access to various components of the application context.

### Methods

- `package_info()`: Returns an immutable reference to the `PackageInfo`.
- `package_info_mut()`: Returns a mutable reference to the `PackageInfo`.
- `pattern()`: Returns an immutable reference to the `Pattern`.
- `runtime_authority_mut()`: Returns a mutable reference to the `RuntimeAuthority` (unstable).
- `new()`: Creates a new `Context` with the provided configuration and assets.
- `with_config_parent()`: Sets the configuration parent path (for development).

### Parameters for `new()`

- `config` (Config): The application configuration.
- `assets` (Box<dyn Assets<R>>): Application assets.
- `default_window_icon` (Option<image::Image<'static>>): The default window icon.
- `app_icon` (Option<Vec<u8>>): The application icon.
- `package_info` (PackageInfo): Information about the application package.
- `pattern` (Pattern): The application pattern.
- `runtime_authority` (RuntimeAuthority): The runtime authority.
- `plugin_global_api_scripts` (Option<&'static [&'static str]>): Optional global API scripts for plugins.

### Parameters for `with_config_parent()`

- `config_parent` (impl AsRef<std::path::Path>): The path to the configuration parent.
```

--------------------------------

### Set Window Visibility on Creation in Tauri

Source: https://docs.rs/tauri/2/tauri/webview/struct

Controls whether the webview window is immediately visible when created. Setting this to `false` allows for setup before showing the window to the user.

```rust
pub fn visible(self, visible: bool) -> Self

```

--------------------------------

### Window Dragging API

Source: https://docs.rs/tauri/latest/src/tauri/window/mod

APIs to initiate window dragging and resize-dragging.

```APIDOC
## POST /window/start-dragging

### Description
Starts dragging the window.

### Method
POST

### Endpoint
/window/start-dragging

### Response
#### Success Response (204)
No content.

## POST /window/start-resize-dragging

### Description
Starts resize-dragging the window.

### Method
POST

### Endpoint
/window/start-resize-dragging

### Parameters
#### Request Body
- **direction** (ResizeDirection) - Required - The direction of the resize drag.

### Response
#### Success Response (204)
No content.
```

--------------------------------

### MockWindowDispatcher: Get Window Title (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/test/mock_runtime

Returns an empty string as the title for the mock window. This is a mock implementation.

```rust
fn title(&self) -> Result<String> {
  Ok(String::new())
}
```

--------------------------------

### iOS Plugin Binding

Source: https://docs.rs/tauri/latest/src/tauri/lib

Macro to set up the binding that initializes an iOS plugin. This is conditionally compiled for iOS targets.

```APIDOC
## ios_plugin_binding

### Description
Macro to set up the binding that initializes an iOS plugin. This is conditionally compiled for iOS targets.

### Method
Macro

### Endpoint
N/A

### Parameters
#### Path Parameters
N/A

#### Query Parameters
N/A

#### Request Body
N/A

### Request Example
N/A

### Response
#### Success Response (200)
N/A

#### Response Example
N/A
```

--------------------------------

### MockWindowDispatcher: Get GTK Window (Linux) (Rust)

Source: https://docs.rs/tauri/latest/src/tauri/test/mock_runtime

This function is intended to return a GTK `ApplicationWindow` on Linux-based systems. However, it is marked with `unimplemented!()`, indicating it is not yet implemented in this mock or specific build.

```rust
#[cfg(any(
  target_os = "linux",
  target_os = "dragonfly",
  target_os = "freebsd",
  target_os = "netbsd",
  target_os = "openbsd"
))]
fn gtk_window(&self) -> Result<gtk::ApplicationWindow> {
  unimplemented!()
}
```

--------------------------------

### Rust: Handle Window Ready Events

Source: https://docs.rs/tauri/2.8.4/src/tauri/plugin

Specifies a callback that is invoked when a new window is successfully created. This callback receives the `Window` object, allowing for post-creation configuration or actions.

```rust
pub fn on_window_ready<F>(mut self, on_window_ready: F) -> Self
where
  F: FnMut(Window<R>) + Send + 'static,
{
  self.on_window_ready = Box::new(on_window_ready);
  self
}
```

--------------------------------

### Cursor and Theme API

Source: https://docs.rs/tauri/2.8.4/src/tauri/app

Provides functionality to get the current cursor position and set the application theme.

```APIDOC
## GET /cursor/position

### Description
Gets the cursor position relative to the top-left corner of the desktop.

### Method
GET

### Endpoint
`/cursor/position`

### Parameters
None

### Request Example
None

### Response
#### Success Response (200)
- **position** (PhysicalPosition<f64>) - The cursor's X and Y coordinates.

#### Response Example
```json
{
  "position": {
    "x": 123.45,
    "y": 678.90
  }
}
```

## POST /theme/set

### Description
Sets the application theme. This is unsupported on iOS and Android.

### Method
POST

### Endpoint
`/theme/set`

### Parameters
#### Request Body
- **theme** (Option<Theme>) - The theme to set. Use `null` for auto theme.

### Request Example
```json
{
  "theme": "dark"
}
```

### Response
#### Success Response (200)
None

#### Response Example
None
```

--------------------------------

### WebviewWindowBuilder::on_page_load

Source: https://docs.rs/tauri/2.8.5/src/tauri/webview/webview_window

Sets a callback that is triggered when a page load event occurs in the webview. This can be either the start or finish of a page load.

```APIDOC
## POST /websites/rs-tauri/on_page_load

### Description
Sets a callback function that will be invoked when a page load event occurs within the webview. This allows for handling events such as `PageLoadEvent::Started` or `PageLoadEvent::Finished`.

### Method
POST

### Endpoint
`/websites/rs-tauri/on_page_load`

### Parameters
#### Query Parameters
- **event_type** (string) - Required - The type of page load event to listen for (e.g., "Started", "Finished").

#### Request Body
- **callback** (function) - Required - The function to execute when the specified page load event occurs. It receives the `WebviewWindow` and `PageLoadPayload` as arguments.

### Request Example
```json
{
  "event_type": "Finished",
  "callback": "function(window, payload) { console.log(payload.url() + ' finished loading'); }"
}
```

### Response
#### Success Response (200)
- **status** (string) - Indicates successful registration of the callback.

#### Response Example
```json
{
  "status": "callback registered successfully"
}
```
```

--------------------------------

### Tauri Create Raw Window with Softbuffer (Windows)

Source: https://docs.rs/tauri/-runtime-wry/2.8.1/src/tauri_runtime_wry/lib

Handles the creation of a raw window on Windows, with support for transparent backgrounds using the softbuffer crate. It builds the window using a provided handler, maps its ID, and optionally initializes a softbuffer surface for drawing if transparency is enabled and the background color is set.

```rust
Message::CreateRawWindow(window_id, handler, sender) => {
      let (label, builder) = handler();

      #[cfg(windows)]
      let background_color = builder.window.background_color;
      #[cfg(windows)]
      let is_window_transparent = builder.window.transparent;

      if let Ok(window) = builder.build(event_loop) {
        window_id_map.insert(window.id(), window_id);

        let window = Arc::new(window);

        #[cfg(windows)]
        let surface = if is_window_transparent {
          if let Ok(context) = softbuffer::Context::new(window.clone()) {
            if let Ok(mut surface) = softbuffer::Surface::new(&context, window.clone()) {
              window.draw_surface(&mut surface, background_color);
              Some(surface)
            } else {
              None
            }
          } else {
            None
          }
        } else {
          None
        };

        windows.0.borrow_mut().insert(
          window_id,
          WindowWrapper {
            label,

```

--------------------------------

### Get State

Source: https://docs.rs/tauri/latest/src/tauri/lib

Retrieves the managed state for a given type. This method will panic if the state has not been managed.

```APIDOC
## GET /state/{type}

### Description
Retrieves the global managed state for a specific type `T`. Panics if the state has not been previously managed.

### Method
`GET` (conceptually, as it's called via a builder method or command)

### Endpoint
N/A (Builder Method or Command Context)

### Parameters
#### Path Parameters
None (type `T` is generic)

#### Query Parameters
None

#### Request Body
None

### Request Example
```rust
// Inside a tauri command or setup hook
let my_state = app.state::<MyState>();
println!("State data: {}", my_state.data);
```

### Response
#### Success Response (200)
Returns the managed state of type `T`.

#### Response Example
(Response is the actual state object, not JSON. Example shown conceptually.)
```rust
// State object of type MyState
MyState { data: "some data" }
```
```

--------------------------------

### GET /resources/any/{rid}

Source: https://docs.rs/tauri/2.8.5/src/tauri/resources/mod

Retrieves any resource using its ResourceId. Returns an error if the ID is not found.

```APIDOC
## GET /resources/any/{rid}

### Description
Retrieves any resource using its ResourceId. Returns an error if the ID is not found.

### Method
GET

### Endpoint
`/resources/any/{rid}`

### Parameters
#### Path Parameters
- **rid** (ResourceId) - Required - The unique identifier for the resource.

#### Query Parameters
None

#### Request Body
None

### Request Example
None

### Response
#### Success Response (200)
- **resource** (Arc<dyn Resource>) - A reference-counted pointer to the requested resource.

#### Response Example
```json
{
  "resource": "..."
}
```

#### Error Response (400)
- **error** (Error::BadResourceId) - If the ResourceId is not found.
```

--------------------------------

### Get Asset Resolver API

Source: https://docs.rs/tauri/2.8.5/src/tauri/app

Provides access to the application's asset resolver.

```APIDOC
## GET /asset_resolver

### Description
Provides access to the application's asset resolver.

### Method
GET

### Endpoint
/asset_resolver

### Response
#### Success Response (200)
- **assetResolver** (object) - The asset resolver object.

#### Response Example
```json
{
  "assetResolver": { ... }
}
```
```

--------------------------------

### Get Window Theme (Rust)

Source: https://docs.rs/tauri/2.8.4/src/tauri/window/mod

Retrieves the current theme of the window. This functionality is supported on macOS 10.14+.

```rust
/// Returns the current window theme.
///
/// ## Platform-specific
///
/// - **macOS**: Only supported on macOS 10.14+.
pub fn theme(&self) -> crate::Result<Theme> {
  self.window.dispatcher.theme().map_err(Into::into)
}
```

--------------------------------

### WebviewWindowBuilder: build Method

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Constructs and returns a new WebviewWindow instance based on the configured properties of the builder.

```APIDOC
## POST /webview/build

### Description
Builds and returns a new WebviewWindow with the specified configuration.

### Method
POST

### Endpoint
/webview/build

### Parameters
#### Request Body
This method does not take a request body as it finalizes the builder configuration.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **window_id** (string) - The unique identifier for the newly created webview window.

#### Response Example
```json
{
  "window_id": "my-webview-window"
}
```
```

--------------------------------

### GET /size

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Retrieves the physical size (width and height) of the webview's client area.

```APIDOC
## GET /size

### Description
Returns the physical size of the webview's client area.

### Method
GET

### Endpoint
`/size`

### Parameters
None

### Response
#### Success Response (200)
- **size** (PhysicalSize<u32>) - The physical size of the webview.
  - **width** (integer) - The width of the webview.
  - **height** (integer) - The height of the webview.

#### Response Example
```json
{
  "size": {
    "width": 800,
    "height": 600
  }
}
```
```

--------------------------------

### GET /bounds

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/mod

Retrieves the dimensions (x, y, width, height) of the webview's client area.

```APIDOC
## GET /bounds

### Description
Returns the bounds of the webview's client area.

### Method
GET

### Endpoint
`/bounds`

### Parameters
None

### Response
#### Success Response (200)
- **bounds** (Rect) - The rectangular area of the webview's client area.
  - **x** (integer) - The x-coordinate of the top-left corner.
  - **y** (integer) - The y-coordinate of the top-left corner.
  - **width** (integer) - The width of the bounds.
  - **height** (integer) - The height of the bounds.

#### Response Example
```json
{
  "bounds": {
    "x": 10,
    "y": 10,
    "width": 800,
    "height": 600
  }
}
```
```

--------------------------------

### Rust: macOS App Menu Initialization

Source: https://docs.rs/tauri/latest/src/tauri/app

Initializes the application menu specifically for macOS using the `init_for_nsapp` and `set_as_windows_menu_for_nsapp` methods. It handles setting up the window and help submenus, ensuring proper menu behavior on Apple platforms.

```rust
#[cfg(target_os = "macos")]
fn init_app_menu<R: Runtime>(menu: &Menu<R>) -> crate::Result<()> {
  menu.inner().init_for_nsapp();

  if let Some(window_menu) = menu.get(crate::menu::WINDOW_SUBMENU_ID) {
    if let Some(m) = window_menu.as_submenu() {
      m.set_as_windows_menu_for_nsapp()?;
    }
  }
  if let Some(help_menu) = menu.get(crate::menu::HELP_SUBMENU_ID) {
    if let Some(m) = help_menu.as_submenu() {
      m.set_as_help_menu_for_nsapp()?;
    }
  }

  Ok(())
}
```

--------------------------------

### Rust: Tauri Plugin Initialization

Source: https://docs.rs/tauri/-plugin-fs/2.4.2/src/tauri_plugin_fs/lib

Initializes the Tauri file system plugin. This function sets up the invoke handler with various file system commands and manages the necessary states for the plugin, including scope and platform-specific configurations.

```rust
pub fn init<R: Runtime>() -> TauriPlugin<R, Option<config::Config>> {
    PluginBuilder::<R, Option<config::Config>>::new("fs")
        .invoke_handler(tauri::generate_handler![...]) // Commands omitted for brevity
        .setup(|app, api| {
            let scope = Scope {
                require_literal_leading_dot: api
                    .config()
                    .as_ref()
                    .and_then(|c| c.require_literal_leading_dot),
                scope: tauri::fs::Scope::new(app, &FsScope::default())?,
            };

            #[cfg(target_os = "android")]
            {
                let fs = mobile::init(app, api)?;
                app.manage(fs);
            }
            #[cfg(not(target_os = "android"))]
            app.manage(Fs(app.clone()));

            app.manage(scope);
            Ok(())
        })
        .on_event(|app, event| {
            if let RunEvent::WindowEvent {
                label: _,

```

--------------------------------

### Start Window Dragging - Rust

Source: https://docs.rs/tauri/2.8.4/src/tauri/webview/webview_window

Initiates the window dragging operation. This method is typically used in response to a user interaction, like clicking and holding a specific window element. It returns a `Result`.

```rust
pub fn start_dragging(&self) -> crate::Result<()>
```